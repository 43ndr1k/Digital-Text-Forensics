Spam Control by Source Throttling Using
Integer Factorization
Rochak Gupta, Vinay Kumar K., and Radhesh Mohandas
Department of Computer Science and Engineering
National Institute of Technology Karnataka, Surathkal, India
gupta.rochak@gmail.com
Abstract. Existing solutions for spam control that are limited to spam
filtering at the receiver side underestimate the fact that the network
bandwidth and processing time of the recipient email servers are wasted.
To cut down these costs spam should be controlled before it reaches the
receiving email server. In this paper, we propose a solution to control
spam at the senders email server by throttling the client’s CPU using
integer factorization problem. Integer factorization is used to generate
stamps as a proof of CPU cycles expended by the senders system for
each email recipient. Cost of generating stamps is negligible when the
client is sending emails to only a few recipients. However, as the number
of recipients increases, the cost of generating stamps also increases which
adversely affects the processing speed of the client. The server requires
minimal processing time to verify stamps generated by the client.
Keywords: Integer Factorization, Source throttling, Spam, Spam con-
trol, Stamps.
1 Introduction
Techniques that control spam at the client side decrease only the costs associated
with recipients. These techniques do not reduce the costs associated with network
bandwidth to carry heavy load of spam and email servers to process spam emails.
Cost based spam control can be a solution to reduce the volume of spam
by making the senders to pay for each email being sent. Nevertheless, forcing
legitimate sender to pay money is not a good solution to achieve spam control.
However, computational proof for spam fighting is an innovative solution that
makes senders pay for sending email using computational effort rather than
money [1], [2]. The idea is to make the sender pay some digital cost by performing
a complex computation as evidence that email is worth receiving. This processing
time is a minimal burden upon legitimate senders who send few emails every day.
However, a spammer simply cannot afford to spend this additional time without
slowing down spamming activity.
Our proposed solution is a cost based spam control. It controls spam at ingress
point (sender email server) by throttling the client’s CPU i.e., to make clients pay
a stamp fee for each email recipient. The solution is based on integer factorization
which is one of the most complex mathematical problems to solve.
K.R. Venugopal and L.M. Patnaik (Eds.): ICIP 2011, CCIS 157, pp. 233–239, 2011.
c© Springer-Verlag Berlin Heidelberg 2011
234 R. Gupta, K. Vinay Kumar, and R. Mohandas
2 Related Work
The most common approaches are blacklist and whitelist. While whitelist is
effective technique, it has several drawbacks. Any email sent by a stranger will
be incorrectly classified as false positive (FP). The major flaw of blacklisting is
that spammers tend to forge header information like sender information in spam
emails and legitimate senders are also being added to blacklists.
Other spam filtering techniques are content based, phrase based and rule
based. The problem with these techniques are that they need constant update
and refinement because spammers use obfuscation techniques. Even some times
constant updates do not work. One common obfuscation technique is using leet
characters in content to disguise it from content based spam filters [3].
Researchers are working on spam filters to increase accuracy [4], [5]. Even
though, the above mentioned approaches are good enough, they have two flaws.
First, even if spam filters are fine tuned, they block or misclassified legitimate
messages as spam (false positive) [6], [7]. The damage of a single false positive
can be very serious [8]. Another problem is that they filter a message after it
is delivered and stored in the receiver’s email server. Cost of processing these
emails at recipient email server and network bandwidth wastage are same.
3 Proposed Approach
The modified client server communication procedure with our proposed solution
to achieve spam control is explained as follows:
1. At server, a list of prime numbers is generated and stored. Lists of composite
numbers are generated by simply multiplying the prime numbers. e.g., N=
p ∗ q, where ‘p’ and ‘q’ are prime numbers and N is a composite number.
2. Sender composes an email and clicks on send. After the sender clicks on send,
email client sends a ‘helo’ SMTP command and server replies with ‘250 ok’.
3. Client sends ‘mail from’ command and server replies with ‘250 ok’ message.
4. For each recipient email id, client sends rcpt to command. Server maintains
lists of composite numbers. For each session server selects one list and fetches
a composite number from that list for each email recipient. Server injects the
selected composite number with the reply message of rcpt to. Fig. 1 shows
SMTP client server communication state diagram with our solution.
5. From each reply of rcpt to command, client extracts composite number in-
jected by the email server. The client computes p and q using integer fac-
torization algorithm given in section 5.1.
6. Client builds stamps using <N , p, q> triplets. Following is format of stamps:
X-INTEGERFACT: p: q: N
Client computes stamp for each recipient of the email, and appends the
generated stamps with body of the email.
7. Client forwards the email to the sender’s email server. The server extracts
stamps appended with email body and verifies them. The server performs
verification in two steps. In first step, the server checks whether N = p ∗ q.
Spam Control by Source Throttling Using Integer Factorization 235
SMTP Client Sending SMTP Server
Client establish a connection (TCP PORT 25)
220 Service Ready
HELLO
250 ok
MAIL FROM:
250 ok
RCPT TO:<test1@gmail.com>
250 ok + INJECT COMPOSITE NUMBER
RCPT TO: <tcst2@gmail.com>
250 ok + INJECT COMPOSITE NUMBER
RCPT TO: <tests3@gmail.com>
250 ok + INJECT COMPOSITE NUMBER
DATA
354 - Start Mail Input
Mail Transaction
The terminate sequence “.” + Generated stamps
250 ok
QUIT
221 - Connection Closed
Client
extracts
composite
numbers
injected and
generates
stamps
Inject composite
numbers from the set
selected for current
session from the set
of composite
numbers
Verify stamps by
checking whether
n = P*Q
{ }
Fig. 1. SMTP Client Server Communication State Diagram with our Solution
236 R. Gupta, K. Vinay Kumar, and R. Mohandas
In second step, the server stores all the composite numbers in the order
they were sent and checks whether the received composite numbers are the
same and in that order. The result of verification process is added as an
extra header to the email, which indicates that email has passed integer
factorization spam control.
4 Countermeasures against Attacks
We discuss various scenarios where a spammer tries to find the hole in proposed
solution and the countermeasures that we have in place to defend such attacks.
Scenario 1: An attacker may calculate stamp once for one recipient and use the
same stamp again for remaining email ids.
To counter this scenario, The server stores all the composite numbers in the
order they were sent and while verifying checks whether the received composite
numbers are the same and in that order.
Scenario 2: An attacker may guess the value of N by storing all possible combi-
nations of <N, p, q> triplets.
For each session on the server side we select one list of composite numbers. When
the server receives SMTP ‘rcpt to’ command, it chooses a composite number from
selected list and appends this composite number with reply message of ‘rcpt to’
command. New list is selected periodically to avoid guesses. Table 1 gives details
about possible composite numbers and memory requirement to store them. It is
not possible for a client to store all possible combinations since it requires more
than hundred million of TERA bytes memory.
Table 1. Memory required storing composite numbers
Length of
Prime (Digit)
Possible n
Digit Primes
Possible Composite
Numbers Cn2
Memory Required Storing Com-
posite Numbers (TERA Byte)
7 586081 1717745176240 1.5
8 5096876 12989069931250 104
9 45086079 1016377237254081 8130
10 404204977 18446744073202533208 147573952
Scenario 3: The attacker may pre-compute all possible stamps and propagate
stamps to other zombie machines.
As shown in Table 1, when we use primes of length 10 digits, nither it will be
possible for attacker to store all possible numbers nor pre-compute the factors.
5 Implementation
We have implemented two modules for the Thunderbird email client and two
modules for the Sendmail SMTP server. Using these modules we have modified
Spam Control by Source Throttling Using Integer Factorization 237
existing client-server communication flow as mentioned in section 3. Details of
these modules are discussed in the subsequent sections.
5.1 Algorithm Used for Integer Factorization
The proposed solution uses Fermats algorithm to perform the factorization task
at client. This is one of the most famous factorization techniques.
5.2 Sendmail Module to Inject Composite Numbers
In order to inject composite numbers for an SMTP session, we have modified the
Sendmail SMTP server. For each recipient, this module of SMTP server injects
composite number into reply message of ‘rcpt to’ command.
5.3 Thunderbird Module to Extract Composite Numbers and to
Calculate Stamps
Modified Thunderbird email client extracts composite numbers injected by the
email server. This module uses algorithm given in section 5.1 for factorization.
After factorization, this module generates stamp in format given in section 3.
5.4 Thunderbird Module to Append Stamps with Body Part
This module appends stamps with email body as evidence that the sender spent
a certain amount of computational effort to send the email for each receiver.
5.5 Sendmail Module to Verify and to Add Extra Verification
Message
Modified Sendmail server fetches stamps from email body and verifies them.
Server performs verification in two steps as given in section 3. After verifying
the stamps, this module adds extra header as mentioned in section 3.
6 Results
Proposed solution adds delay on the client side before the email is sent to the
receiving email server. Delay depends on the number of email recipients. Fig. 2
shows Client Delay with Varying Number of Recipients. Our proposed solution
depends on number of recipients but not on the mail body size. If we fix the
number of recipients and vary the mail body size then we analyze that the delay
on the client side remains same with or without proposed solution. Fig. 3 shows
client delay with varying body size for 1 recipient. Client delay also depends on
the length of composite numbers sent by the server. Fig. 4 shows the client delay
with varying length of composite numbers for 20 recipients.
238 R. Gupta, K. Vinay Kumar, and R. Mohandas
2 10 50 200 400 600 800 1000
No. of Recipients
0
200
400
600
800
1000
D
el
ay
 (S
ec
)
Delay with Integer Factorization
Fig. 2. Client Delay with Varying Number of Recipients
1 2 3 4 5 6 7 8 9 10
Body Size (MB)
0
1
2
3
4
5
6
7
8
9
D
el
ay
 (s
ec
)
Client Delay with Varying Body Size
Fig. 3. Client delay with varying body size
11 12 13 14 15 16 17
Length of Composite numbers (Digits)
0
50
100
150
200
D
el
ay
 (s
ec
)
Client Delay with Varying length of Composite numbers
Fig. 4. Client delay with varying length of composite numbers
Spam Control by Source Throttling Using Integer Factorization 239
7 Conclusions
Proposed solution adds minor delay at the client of sending an email to each
recipient. Delay is negligible when the client sends email to few recipients but
reduces throughput of client by a huge factor if the client is sending an email to
the large number of recipients. A spammer cannot afford to spend this additional
time without slowing down spamming activity. Proposed solution adds a small
overhead to the email server which is involved in the verification of stamps.
References
1. Zhong, Z., Huang, K., Li, K.: Throttling Outgoing SPAM for Webmail Services. In:
Proceedings of the Second Conference on Email and Anti-Spam (June 2005)
2. Jagannath, S., Mohandas, R.: SPAM control using CPU Timestamps. In: Proceed-
ings of the International Conference on Information Security and Artificial Intelli-
gence (2010)
3. Hayes, B.: How many ways can you spell V1@gra? Scientific American 95(4),
298–302 (2007)
4. Yang, Y., Elfayoumy, S.: Anti-Spam Filtering Using Neural Networks and Baysian
Classifiers. In: Proceedings of the 2007 IEEE International Symposium on Com-
putational Intelligence in Robotics and Automation Jacksonville, FL, USA (June
2007)
5. Kanaris, I., Kanaris, K., Houvardas, I., Stamatatos, E.: Words vs. Character N-
Grams For Anti-Spam Filtering. International Journal On Artificial Intelligence
Tools, 1–20 (2006)
6. Delio, M.: Not All Asian E-Mail Is Spam. Wired News article (February 2002)
7. Williams, A.: Truth finally brought to light, Harvard acceptance letters discovered
unkosher. Daily Princetonian (February 15 2002)
8. Jacob, P.: The Spam Problem: Moving Beyond RBLs,
http://theory.whirlycott.com/~phil/antispam
