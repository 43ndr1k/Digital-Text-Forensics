c© 2013 by Rajhans Samdani. All rights reserved.
ALGORITHMS FOR STRUCTURAL LEARNING WITH DECOMPOSITIONS
BY
RAJHANS SAMDANI
DISSERTATION
Submitted in partial fulfillment of the requirements
for the degree of Doctor of Philosophy in Computer Science
in the Graduate College of the
University of Illinois at Urbana-Champaign, 2013
Urbana, Illinois
Doctoral Committee:
Professor Dan Roth, Chair
Professor David Forsyth
Professor Mark Hasegawa-Johnson
Professor Thorsten Joachims, Cornell University
Abstract
Structured prediction describes problems which involve predicting multiple output variables with expressive
and complex interdependencies and constraints. Learning over expressive structures (called structural learn-
ing) is usually time-consuming as exploring the structured space can be an intractable problem. The goal of
this thesis is to present different techniques for structural learning, which learn by decomposing the problem
space into simpler and tractable components. We will consider three different settings: fully supervised, un-
supervised and semi-supervised, and discriminative latent variable setting, and present learning techniques
for each case.
For supervised structural learning, we describe a paradigm called Decomposed Learning (DecL) which
decomposes the inference procedure during learning into small inference steps using additional application-
specific information. For unsupervised learning, we propose a family of Expectation Maximization [Dempster
et al., 1977] algorithms called Unified Expectation Maximization (UEM) [Samdani et al., 2012a] that covers
several seemingly divergent versions of EM e.g. hard EM. To efficiently add domain-specific declarative
constraints into learning, we use a dual projected subgradient ascent algorithm which naturally decomposes
the task into simpler components. In the discriminative latent variable scenario, we present a supervised
latent variable model for clustering called the Latent Left-Linking Model (L3M) that can efficiently cluster
items arriving in a streaming order. We decompose the learning process for L3M into small and efficient
stochastic gradient descent steps that lead to rapid convergence.
ii
To my parents and my love, Neha.
iii
Acknowledgements
I was convinced for the first two years of my undergraduate that I made a mistake by choosing computer
science as my major. Eight years later, I am writing this thesis to finish my PhD in the Department of
Computer Science at Illinois. Much has happened before and during these years that shaped my interest
and led to culmination of my PhD work. I owe much to the support of my advisors, family, and friends.
I was fortunate to have Professor Dan Roth as my PhD advisor. Dan has an exceptional ability to
walk the thin line between theoretically interesting and practically useful. During all these years, he gave
me complete freedom to choose what I want to work on and was always available to discuss my ideas and
propose new ones. Discussions with him always stimulated me to think about the broader picture and where
my work should fit in. I shall always be thankful for his guidance.
I would also like to thank Professors David Forsyth, Mark Hasegawa-Johnson, Thorsten Joachims, and
Gerald Dejong for providing great insights into many research topics and ideas. I was lucky to have Tapas
Kanungo, Scott Wen-Tau Yih, and Gideon Mann as my internship mentors. I am also thankful to my
undergraduate advisor Professor Soumen Chakrabarti who piqued my interest in Machine Learning.
I was lucky to be friends with many talented PhD students at Illinois. Yonatan is adorably hipster and
a darling. Ming-Wei holds himself and his work to the highest degree of scrutiny. Kai-Wei is extremely
hard working, helpful, and smart. Vivek has interesting things to say about almost every topic under the
sun. Dan Goldwasser is a fun travel companion, and more so with beer around. Many other names come to
mind that brought much happiness and amusement to me — my office mates, Onur and Johannes; fellow
cogcompers, Jeff, Gourab, Nick, Wei Lu, Yuancheng, Alla and others; the new kids, Ryan and Daphne; and
my gym buddy, Minas.
Six years is a long time to spend in a place like Urbana. Life would have been rather dull if it wasn’t
for my fellow desi friends at Illinois. I enjoyed spending my time with Ankur, Vinayak, Shruti, and Neha at
my apartment and with Tarun, Shweta, Shwetha, Sibin, Ankit, Mrinalini, Pritish, Zeba, Kowti, and others
at Bling Pig, Kopi, Paradiso, and other spots. While I am glad I found these friends, I am sure they are
happy to have found an easy leg-pulling target in me as well.
iv
In the last five years, Tango added many colors and flavors to my life. What started with a class with
Joe and Carlotta, resulted not only in Tango as a source of endless pleasure for the rest of my life but also
gave me some very good friends like Sahand, Evelina, Ushnish, and others.
I am also thankful to my IIT Bombay friends — my batch in Hostel three, folks at Stanford, and many
others. Also, much thanks to the members of Eliteness: Agp, Bhaski, Bop, Alekh, Ansari, Luv, and Laku.
If it wasn’t for their tough love, I may not have taken to the idea of doing a PhD in CS.
I will always be very grateful for my loving and supportive family. I have been fortunate enough to have
two sets of parents: my mom-dad and my Bade papa and Badi mummy. Over the years, I have realized
what an important role my family has played in my intellectual, emotional, and social development. My
mother and father started me on a path of education and knowledge that set a rather fruitful course for the
rest of my life. My siblings Raghav and Ina are smart and their future looks promising — they have much
to learn and achieve. I love my Grandma and miss my late Grandpa — he would have been so proud to see
me become a Doctor of Philosophy. Last by no means the least, I am glad to have found love in Neha. Last
two and a half years with her have not only been very blissful but also productive. She has been very calm,
supportive, and sweet all this while even though I could not spend enough time with her or take time off
during vacations.
Many good things have happened to me during these six years and I have no doubt I have been quite
lucky. At this point, if I were a believer, I would thank God.
v
Table of Contents
List of Figures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ix
List of Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xi
Chapter 1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1 Instances and Challenges of Learning in Structured Prediction . . . . . . . . . . . . . . . . . 2
1.1.1 Information Extraction: Labeling Text Segments . . . . . . . . . . . . . . . . . . . . . 2
1.1.2 Entity Type and Relation Type Labeling . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.3 Coreference Resolution as a Streaming Data Clustering Problem . . . . . . . . . . . . 4
1.2 Overview of this Thesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3 Contributions of this Thesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
Chapter 2 Structured Prediction: Background and Existing Work . . . . . . . . . . . . . 8
2.1 Preliminary Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.1.1 Features for Discriminative Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1.2 Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.1.3 Evaluation and Loss Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.2 Inference for Structured Prediction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.2.1 Exact Inference Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.2.2 Approximate Inference Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3 Supervised Structural Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.3.1 Global Learning of Structural SVMs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.3.2 Other Examples of Global Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.3.3 Approximate Supervised Structural Learning . . . . . . . . . . . . . . . . . . . . . . . 29
2.4 Unsupervised and Semi-supervised Learning with EM and its Variations . . . . . . . . . . . . 35
2.4.1 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.4.2 The Standard Expectation Maximization Algorithm . . . . . . . . . . . . . . . . . . . 36
2.4.3 Hard EM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
2.4.4 Constraints in EM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
2.4.5 Discriminative Semi-Supervised Learning with EM . . . . . . . . . . . . . . . . . . . . 39
2.5 Discriminative Latent Variable Structured Prediction Models . . . . . . . . . . . . . . . . . . 40
2.5.1 Motivation and Inference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
2.5.2 Learning in Discriminative Latent Variable Setting . . . . . . . . . . . . . . . . . . . . 42
Chapter 3 Efficient Decomposed Structural Learning . . . . . . . . . . . . . . . . . . . . . 45
3.1 The Problem Setting and Existing Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.1.1 Problem Setting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.1.2 Structured Prediction: Overview of Previous Learning Techniques . . . . . . . . . . . 47
3.2 Decomposed Learning (DecL) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.2.1 Learning with Neighborhoods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
3.2.2 Learning with Decompositions: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
3.3 Theoretical Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
vi
3.3.1 Separating Weights . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
3.3.2 Desired Theoretical Property: Exactness . . . . . . . . . . . . . . . . . . . . . . . . . . 55
3.3.3 Exactness of DecL for Singleton Scoring Functions with Constraints . . . . . . . . . . 57
3.3.4 Exactness for Pairwise Markov Networks . . . . . . . . . . . . . . . . . . . . . . . . . 58
3.4 Comparison with Pseudolikelihood-like Techniques . . . . . . . . . . . . . . . . . . . . . . . . 59
3.5 Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
3.5.1 Experiments on Synthetic Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
3.5.2 Multi Label Document Classification . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
3.5.3 Information Extraction: Sequence Tagging with Submodular Potentials . . . . . . . . 64
3.6 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
Chapter 4 Unified Expectation Maximization for Structured Prediction . . . . . . . . . . 68
4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.2 Unified Expectation Maximization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.3 UEM as a Generalization of Existing Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . 71
4.3.1 UEM Without Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.3.2 UEM With Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.3.3 UEM with γ ∈ [0, 1] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.3.4 Discussion: The Role of Temperature and Its Use in Previous Works . . . . . . . . . . 74
4.4 UEM with Constraints: Decomposing the Constrained E-step via Lagrangian Dual . . . . . . 77
4.4.1 Projected Subgradient Ascent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
4.4.2 Projected Subgradient based Dual Decomposition Algorithm . . . . . . . . . . . . . . 79
4.5 Relationship between γ and Initialization for UEM . . . . . . . . . . . . . . . . . . . . . . . . 82
4.5.1 Unsupervised POS Tagging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
4.5.2 Synthetic Data Experiments with Hidden Markov Models . . . . . . . . . . . . . . . . 84
4.6 Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.6.1 Semi-Supervised Entity-Relation Extraction . . . . . . . . . . . . . . . . . . . . . . . . 91
4.6.2 Word Alignment with Agreement Constraints . . . . . . . . . . . . . . . . . . . . . . . 94
4.7 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
Chapter 5 Latent Left-Linking Model for Clustering . . . . . . . . . . . . . . . . . . . . . . 97
5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
5.2 Notations and Pairwise Classifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
5.3 Probabilistic Latent Left-linking Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
5.3.1 Clustering with Latent Left-Linking Model . . . . . . . . . . . . . . . . . . . . . . . . 101
5.3.2 Alternative View of L3M as a Latent Tree-based Approach . . . . . . . . . . . . . . . 105
5.3.3 Latent Variable Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
5.4 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
5.4.1 Non-Streaming Structured Prediction based Clustering Techniques: . . . . . . . . . . . 109
5.4.2 Streaming Clustering Techniques: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
5.5 Experiments and Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
5.5.1 Coreference clustering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.5.2 Clustering of Online Forum Postings . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
5.5.3 Measuring the Impact of Streaming Ordering . . . . . . . . . . . . . . . . . . . . . . . 118
5.5.4 Measuring the Impact of Non-Convexity on SGD Learning . . . . . . . . . . . . . . . 119
5.6 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
Chapter 6 Conclusion and Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
6.1 Future research . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
6.1.1 Theoretical Analysis of Decomposed Learning . . . . . . . . . . . . . . . . . . . . . . . 121
6.1.2 Supervised Structural Learning with Lagrange Relaxation . . . . . . . . . . . . . . . . 122
6.1.3 Understanding UEM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
6.1.4 Linear Time Streaming Clustering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
vii
Appendix A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
A.1 Derivations for technical results in Section 4.4 . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
A.2 Proofs for Chapter 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
A.3 Proofs for Chapter 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
viii
List of Figures
1.1 An example labeling of an actual apartment advertisement from craigslist, borrowed from
Grenager et al. [2005]. The labels are in the type-writer font and different labels have different
colors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2 Example of coreference clustering. Mentions with the same subscript (or redundantly, the
same color) are coreferential. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2.1 The information extraction task with sequence tagging output labels shown in red color. . . . 9
2.2 Above: A sentence with mentions in brackets. Below: A clustering for the mentions. . . . . . 9
2.3 The EM algorithm. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
3.1 Labeling, (y1, y2, y3), for the x1, x2 feature space. Dashed lines separate regions with different
labelings. Significance of regions A, B, C, and D is explained in Section 3.1 . . . . . . . . . . 48
3.2 Figure highlighting the differences between typical GL and DecL. The diagrams on left and
right illustrate the general scheme for GL and DecL, respectively. We show how DecL restricts
learning-time inference by adding more information. During testing, we use exact inference. . 49
3.3 A cartoon figure showing the difference in output space explored by GL and a version of DecL.
GL, on the left, explores the entire search space which has size 26 = 64. DecL, on the right,
only considers inference over variables in bounded boxes at a time. Thus the output space
DecL explores (also shown in the figure) is 23 + 22 + 22 = 16, which is much smaller than GL. 53
3.4 A cartoon figure demonstrating the statement of Theorem 3.3.1 (on the left) as well as a
intuitive proof sketch to the right. On the left, W dec is an outerbound on W ∗ and the
required condition is that any w′ ∈ Rd not in W ∗ is also not in W dec. The right figure shows
how this implies that W dec = W ∗ (the formal proof is in the appendix.) . . . . . . . . . . . . 56
3.5 Figure illustrating how instance-specific decompositions that yield exactness can be obtained
for a pairwise Markov network. In the illustrated cartoon graph, it is known prior to learning
that green edges are submodular and magenta edges are supermodular (see Definition 8.) In
the given ground truth labeling (yj), the variables corresponding to red circles have value 1
and the variables with blue circles have value 0. The middle figure shows how we cut the edges
where the ground truth labels disagree with the edge potentials. The obtained decompositions
are connected components in the resulting graph as shown by the figure on the right. . . . . . 60
3.6 Synthetic data comparisons with varying training sizes. LL: local learning; LL+C: local learn-
ing with constraints during inference; GL: global learning; DecL-1,2,3: decomposed learning
(our approach) with all subsets of sizes 1,2, and 3 respectively. . . . . . . . . . . . . . . . . . 63
3.7 An example labeling of an actual apartment advertisement from craigslist. . . . . . . . . . . . 66
4.1 POS Experiments showing the relation between initial model parameters and γ. We report the
relative performance compared to EM (see Eq. (4.15)). The posterior uniform initialization
does not use any labeled examples. As the number of labeled examples used to create the
initial HMM model increases, the quality of the initial model improves. The results show that
the value of the best γ is sensitive to the initialization point and EM (γ = 1) and hard EM
(γ = 0) are often not the best choice. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
ix
4.2 Figure showing the performance of UEMγ for different γ values, for different initialization
qualities, and for varying model mismatch in terms of the number of hidden states. The data
is generated with H∗ = 10 hidden states. During learning, an HMM model with H(train) =
10, 20, 40, and 50 hidden states is fit. Each graph corresponds to one particular value of
H(train). The x-axis in each graph, similar to Figure 4.1, has the value of γ decreasing from
1 to 0. The y-axis reports the variation of information (VI.) Each line in the graph represents
initialization with a given value of i as per Equation 4.16 where higher value of i indicates
better initialization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
4.3 Figure showing the normalized performance of UEMγ for different γ values, for different
initialization qualities, and for varying model mismatch in terms of the number of hidden
states. Normalization is achieved by centering and dividing w.r.t. the performance of EM
(γ = 1) as in (4.15) with Accuracy replaced by Variation-of-Information (thus lower values
are better.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
4.4 Figure showing the normalized performance of UEMγ for different γ values, for H
∗ = 20.
Normalization is achieved by centering and dividing w.r.t. the performance of EM (γ = 1.) . 89
4.5 Average F1 for relation prediction for varying sizes of labeled data comparing the supervised
baseline, PR, CoDL, and UEM. UEM is statistically significantly better than supervised
baseline and PR in all the cases. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
4.6 Average F1 for entity prediction for varying sizes of labeled data comparing the supervised
baseline, PR, CoDL, and UEM. EM-based approaches do not outperform the supervised
baseline there. However, notably, for entities, for κ = 10%, UEM outperforms CoDL and PR
and for 20%, the supervised baseline outperforms PR statistically significantly. . . . . . . . . 93
5.1 Example of coreference clustering. Mentions with the same subscript (or redundantly, the
same color) are coreferent (our system needs to predict this.) . . . . . . . . . . . . . . . . . . 100
5.2 Figure showing the first modeling assumption in L3M. . . . . . . . . . . . . . . . . . . . . . . 101
5.3 Figure showing the second modeling assumption in L3M. . . . . . . . . . . . . . . . . . . . . . 101
5.4 Figure showing the third modeling assumption in L3M. . . . . . . . . . . . . . . . . . . . . . 102
x
List of Tables
3.1 Table comparing different techniques related to DecL on various relevant criteria. Max-lik is
maximum likelihood estimation for probabilistic models like conditional random fields [Laf-
ferty et al., 2001]. Pseudo-lik is Pseudolikelihood [Besag, 1974]; Comp-like is composite like-
lihood [Lindsay, 1988]; St. Comp-like is stochastic composite likelihood [Dillon and Lebanon,
2010]; Psuedomax [Sontag et al., 2010] and DecL [Samdani and Roth, 2012] are max-margin
techniques. ∗: Consistent under some stronger assumption mentioned in [Sontag et al., 2010].
†: exact for appropriate decompositions. ‡: tractable for appropriate sized sets in the decom-
position. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
3.2 Multi-label classification: Average per-instance F1, average macro-F1, and average training
times for the Reuters data. We report total time spent on inference during learning. DecL-3
is statistically significantly the best performing algorithm outperforming, surprisingly, GL.
The differences DecL-2 and GL are not statistically significant. Also note the small amount
of training time for DecL-2 and DecL-3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
3.3 Performance comparison showing average accuracy (Acc) of LL, LL+I, GL, and DecL. The
LL baseline here is a simple discriminative HMM training without constraints. The LL+I
baseline adds constraints during decision time. We also show average training time (Time)
taken for GL and DecL in minutes. Size indicates the number of training documents. . . . . . 66
4.1 Summary of different UEM algorithms. The entries marked with “(NEW)” have not been
proposed before. Equation (4.3) is the objective function for all the EM frameworks listed
in this table. Note that, in the absence of constraints, γ ∈ (−∞, 0] corresponds to hard EM
(Section 4.3.1.) Please see Section 4.3 for a detailed explanation. . . . . . . . . . . . . . . . . 72
4.2 Entity and Relation type constraints on posterior probability. . . . . . . . . . . . . . . . . . . 92
4.3 AER (Alignment Error Rate) comparisons for French-English (above) and Spanish-English
(below) alignment for various data sizes. For French-English setting, tuned γ for all data-
sizes is either 0.5 or 0.6. For Spanish-English, tuned γ for all data-sizes is 0.7. DA-0 refers
to deterministic annealing when temperature comes down from 1 all the way to 0. DA-γ is
when the best temperature (based on the performance on the development set) during the
annealing procedure is picked. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
5.1 The features we extract from mention pairs for coreference resolution [Chang et al., 2012] . . 115
5.2 Performance on ACE 2004 and OntoNotes-5.0. Corr-Clustering is proposed by Finley and
Joachims [2005]; Spanning Forest is the latent spanning forest-based approach by Yu and
Joachims [2009]; Sum-Link is a streaming data clustering technique by Haider et al. [2007];
Bin-Left-Link uses a Best-Left-Link inference and the training strategy by Bengtson and Roth
[2008]. Our proposed approach is L3M— L3M with tuned γ is when we tune the value of
γ using a development set; L3M (γ = 0) is with γ fixed to 0. Corr-Clustering-Red drops
some transitivity constraints during inference. Corr-Clustering and Spanning Forest are not
streaming clustering techniques. Sum-Link, Bin.-Left-Link, L3M (tuned γ), and L3M (γ = 0)
are streaming clustering techniques. “(1 pass)” means when trained with just one pass over
the data. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
xi
5.3 Summary statistics for the online forum data. One data stream contains postings from one
day. Last column represents maximum number of posts by any author in a single data stream.116
5.4 Results on the forum data for author-based and discussion topic-based clustering. For stream-
ing algorithms, one pass over the data was sufficient. For streaming algorithms with topic-
based clustering, we report results with one pass as well as five passes (last two columns)
during training. All the results are scaled by 100. Small VI and large FM are desirable. In
most cases, L3M (tuned γ) is statistically significantly better than all the other approaches. . 117
5.5 Results with randomized ordering of items on coreference resolution for the ACE data and on
author-based and discussion topic-based clustering for Forum data. All the results are scaled
by 100. The results for author clustering are largely the same when items were not randomized
(Table 5.4. The results for coreference resolution and topic clustering are significantly worse. 118
xii
Chapter 1
Introduction
Statistical learning techniques have facilitated tremendous advancements in many applications. Many tech-
nologies like spam detection, credit card fraud detection, and sentiment analysis make use of simple machine
learning frameworks like binary classification. However, much progress remains to be made — e.g., when
compared with human judgment — in several challenging tasks like information extraction, object detection
and recognition, machine translation, and speech understanding and synthesis. A crucial component of these
challenging applications is dealing with multiple interrelated decision variables. When a large number of
output variables of interest in such applications interact with each other then they are said to be structured
with respect to each other. Learning and prediction with structured variables comes with its own set of
challenges. The task of doing learning and inference with structured variables is called structured predic-
tion or structured output prediction. Structured prediction is very common in several fields like Natural
Language Processing (NLP) [Smith, 2011], Information extraction (IE) [Lafferty et al., 2001], Computer
vision [Forsyth and Ponce, 2002], Computational Biology [Sontag, 2010], and Speech Recognition [Keshet,
2007].
Structured output variables are linked via complex dependencies and constraints. This often makes
inference and learning over the entire monolithic structure, consisting of all the variables, time-consuming. In
several commonly occurring settings, structural learning over all the output variables is practically intractable
due to the expressiveness of the interactions between the output variables. This presents a difficult situation
as expressiveness is often the key to high accuracy of models. Hence there is a need for efficient as well as
principled techniques for structural learning to deal with expressive interactions between output variables.
This thesis will present efficient learning algorithms for structured prediction problems which decompose
a harder learning problem into simpler and more tractable components. This thesis will touch upon learning
with an entire spectrum of supervision settings — from fully supervised to unsupervised including semi-
supervised and latent-variable learning. In all the cases, the common theme is that efficiency is achieved by
the decomposition of a harder learning problem into separate, but not independent, components.
1
1.1 Instances and Challenges of Learning in Structured
Prediction
In this section, we present some of examples of structured prediction problems for information extraction,
explain the challenges involved in such problems, and describe how our algorithms attempt to solve these
problems at a conceptual level.
1.1.1 Information Extraction: Labeling Text Segments
Information extraction is a broad umbrella term used to denote extraction of structured information from
unstructured data, typically textual data. Consider a particular information extraction problem in which
you are required to label different textual segments as belonging to a particular field. For instance, consider
a particular apartment listing from craigslist, an example of which is given in Figure 1.1. The task here is to
extract relevant information from this advertisement like the neighborhood, features, rent, size, availability,
etc. one would typically associate with an apartment listing. In particular, our task here is to label each
token in the listing by a particular informational field it belongs to. An example of such a labeling is also
presented in Figure 1.1 as well where the labeled fields are colored. Our task is to train a classifier to
automatically label any apartment listing using some amount of labeled data.
Field identification for this task can be performed as a sequence-tagging task which involves tagging each
token of a given sequence. Not surprisingly, a large number of previous works have used a sequence tagger
like a Hidden Markov Model (HMM) [Grenager et al., 2005, Chang et al., 2007] for this task. An HMM
with first order Markovian dependencies is efficiently trained using labeled data using a maximum likelihood
procedure [Rabiner, 1989] or using a discriminative MAP-inference based procedure [Collins, 2002]. However,
it is known that HMM training and inference for information extraction can benefit a lot in terms of accuracy
by injection of prior knowledge-based structural constraints [Chang et al., 2007, Druck and Mccallum, 2010,
Samdani and Roth, 2012]. More specifically, constraints that specify certain global structural properties
which may not be expressed by a first order HMM with a limited Markovian window. For instance, in most
apartment listings, a particular field (e.g. nbrhd) continues for at least a few tokens and thus penalizing
labelings where fields run for less than, say, three words can help remove faulty solutions where field sizes
are too small.
However, introduction of such constraints come at the cost of efficiency. In particular, these constraints
destroy the first order Markovian property and taking into account higher order dependencies makes learning
and inference computationally harder. The proposed approach in this thesis (presented in Chapter 3) over-
2
size size size size size feat feat feat feat feat
Spacious 1 Bedroom apt . newly remodeled , gated ,
feat feat feat feat feat feat nbrhd nbrhd nbrhd nbrhd
new appliance , new carpet , near public transportation , close
nbrhd nbrhd nbrhd nbrhd rent rent rent rent
to 580 freeway , $ 500.00 Deposit (510)655-0106
Figure 1.1: An example labeling of an actual apartment advertisement from craigslist, borrowed from
Grenager et al. [2005]. The labels are in the type-writer font and different labels have different colors.
comes the key difficulty in learning by decomposing the learning procedure into smaller components. Our
approach decomposes the inference step during learning, that is a computational bottleneck, into smaller
chunks of the output variables conditioned on the remaining variables. In particular, the entire sequence of
variables is decomposed into smaller sub-sequences of variables where each sequence corresponds to contigu-
ous blocks of variables labeled with the same field in the ground truth labeling. So for the given instance
in Figure 1.1, each sub-sequence corresponds to blocks of variables labeled with just one label (with one
color.) This approach is principled and is significantly more efficient than a full scale structured prediction
approach that takes into account the constraints on the entire structure [Samdani and Roth, 2012].
1.1.2 Entity Type and Relation Type Labeling
The task of entity type labeling involves labeling a given proper noun as being of a certain semantic type e.g.
a Person, a Location, an Organization, etc. The task of relation type prediction involves predicting
the semantic relation type between two entities e.g. if a person X lives in a city Y, they are related by the
relation type Lives-in. One can imagine several such relation types like Spouse-of, Located-in, Killed,
etc. Consider, for example, the following sentence:
[Frank], who is a native of [Chicago], is a trader at [Morgan Stanley].
In the sentence above, interesting entities or mentions are marked by square brackets. The entity types of
Frank, Chicago, and Morgan Stanley are Person, Location, and Organization, respectively. Further-
more, Frank and Chicago are related to each other via Lives-in relation and Frank and Morgan Stanley
are related to each other via Works-for relation.
Entity and relation type prediction are important tasks for information extraction. While entity and
relation prediction can be simply modeled using a, say, a multi-class log-linear classifier, Roth and Yih [2007]
showed that prediction of entity and relation types can be made much more accurate by inclusion of certain
domain knowledge-based type constraints. Furthermore, for semi-supervised learning of these tasks with a
3
[Former Governor of Arkansas]1, [Bill Clinton]1, who was recently elected as the [President of the U.S.A.]1, has
been invited by the [Russian President]2, [Vladimir Putin]2, to visit [Russia]3. [President Clinton]1 said that [he]1
looks forward to strengthening the relations between [Washington]4 and [Moscow]5.
Figure 1.2: Example of coreference clustering. Mentions with the same subscript (or redundantly, the same
color) are coreferential.
small amount of labeled data, it is known that certain corpus wide constraints [Mann and McCallum, 2010,
Samdani et al., 2012a] are helpful to guide the learning process. Once again, the resulting learning problem,
with the additional constraints, has long-range global dependencies that promise higher accuracy but make
the task of learning computationally challenging. This thesis proposes an efficient learning algorithm (see
Chapter 4) for this problem that decomposes into individual learning problems over entities and relations,
which communicate via simple dual variables.
1.1.3 Coreference Resolution as a Streaming Data Clustering Problem
Coreference resolution is a challenging NLP task that involves identifying noun phrase expressions called
mentions in a single or multiple documents and clustering together those mentions that refer to the same
underlying entity. For example, in the text in Figure 1.2, mentions with same subscript numbers (and the
same color) would be termed coreferential. Coreference resolution is most commonly viewed as a supervised
clustering task based on a similarity function that gives the compatibility between pairs of mentions. That
is typically one uses a feature-based similarity function between mention pairs to construct the required
coreference clustering.
In general, there is a gap between theory and practice for coreference resolution — efficient and successful
state-of-the-art techniques for coreference tend of be rather ad hoc in terms of their machine learning
framework Bengtson and Roth [2008], Raghunathan et al. [2010], Stoyanov and Eisner [2012] and principled
structured prediction techniques [Mccallum and Wellner, 2003, Finley and Joachims, 2005, Yu and Joachims,
2009] tend not be very efficient (e.g. Mccallum and Wellner [2003] and Finley and Joachims [2005] model
coreference resolution as a correlation clustering problem [Bansal et al., 2002] which is known to be NP
hard) and do not obtain great empirical performance (see Chapter 5 for some examples.) In Chapter 5, we
present a principled structured prediction technique (still in submission) that views coreference resolution
as a clustering problem over streaming items with documents as data streams and mentions as items that
follow a natural streaming left-to-right order (right-to-left for a few languages.) Our technique is efficient
and outperforms many existing techniques. Furthermore, we present an efficient online learning technique
that can effectively decompose the learning process over individual mentions in each document.
4
1.2 Overview of this Thesis
This thesis considers different settings from fully supervised to different spectrums of weakly supervised (un-
supervised, semi-supervised, and latent variable) cases for structural learning. The fundamental focus of this
thesis is on proposing algorithms that decompose the structured problem into smaller problem components.
Critically, the problem components are not independent of each other.
Efficient Decompositions for Supervised Structural Learning: Chapter 3 focuses on supervised
discriminative structural learning. Supervised structural learning techniques need to compute either expec-
tations over parameters [Lafferty et al., 2001] or need to perform MAP inference [Collins, 2002, Tsochantaridis
et al., 2004, Taskar et al., 2004] in order to compute a gradient over the parameters. In particular, existing
techniques like structured perceptron [Collins, 2002] and structural SVM [Tsochantaridis et al., 2004, Taskar
et al., 2004] perform exact inference several times followed by parameter-updates. As inference for expressive
structures is typically slow, these learning algorithms can be prohibitively time-consuming. We propose a
novel and much faster supervised structural learning technique, which we call Decomposed Learning (DecL).
We observe that performing exact inference as a black box procedure is overkill for several applications,
which is precisely where DecL differs. DecL simplifies inference during learning by explicitly decomposing
the monolithic and, presumably, intractably large output space into smaller and tractable chunks. The
decompositions for DecL are driven by additional application-specific information about a) the actual gold
labels, b) the constraints on the output space, and c) the underlying parameters which we want to learn.
This is where it differs from Pseudolikelihood-based approaches [Besag, 1974, Sutton and Mccallum, 2009,
Sontag et al., 2010], which do not tailor their learning to the richness of the problem-at-hand and are likely
to suffer in practical settings.
Experiments on real-world problems with multi-label classification and information extraction show that
in most cases DecL is almost as accurate as approaches based on exact inference while being much faster.
Unsupervised and Semi-supervised Structural Learning with Constraints: Chapter 4 develops
a framework for the widely popular Expectation Maximization algorithm, called Unified Expectation Max-
imization (UEM), that unifies several seemingly divergent versions of EM algorithm. While EM has been
shown to very well for several tasks [McCallum et al., 1998, Nigam et al., 2000, Brown et al., 1993, Blei et al.,
2003] variations of EM like hard EM are sometimes known to work better [Spitkovsky et al., 2010]. Unified
EM provides a generalized family of algorithms which includes EM and hard EM along with a continuum
of other EM algorithms graded according to the amount of entropy of the posterior distribution obtained in
5
the E-step.
We focus on injecting domain-specific constraints into UEM in which case, UEM unifies existing con-
strained EM algorithms namely Constraint-Driven Learning (CODL) [Chang et al., 2007] and Posterior
Regularization (PR) [Ganchev et al., 2010]. Tuning a single parameter conveniently attains picking the best
version of EM from the UEM family based on the quality of initialization, data, and supervision signals like
constraints. Adding constraints to UEM makes the resulting learning problem more difficult than regular
EM and we propose an efficient dual projected subgradient ascent algorithm to this end. Our Lagrangian
dual [Bertsekas, 1999] based algorithm resembles dual decomposition in that when dealing with joint learn-
ing over multiple tasks connected via constraints, our algorithm decomposes into individual tasks thereby
making learning efficient. Using UEM, we discover new versions of EM that outperform existing EM varia-
tions in our experiments on unsupervised POS tagging, semi-supervised entity and relation extraction, and
unsupervised word-alignment.
Latent Variable Clustering of Streaming Data Chapter 5 focuses on supervised clustering of data
items with a pairwise item similarity function. Clustering in this scenario can be posed as a structured
prediction problem as the pairwise clustering decisions are dependent on each other (co-clustering item pairs
a, b and b, c should take into account the relation between a and c.) In particular, we focus on problems
where data items appear in a streaming order, which is a very plausible assumption for a lot of problems.
Several existing structured prediction techniques pose supervised clustering as a combinatorial optimiza-
tion problem e.g. correlational clustering [Mccallum and Wellner, 2003, Finley and Joachims, 2005] or
maximum spanning tree [Yu and Joachims, 2009]. However, such techniques are computationally expensive
and may not be directly applicable in a streaming setting with a potentially large number of items. While
there are techniques [Haider et al., 2007, Bengtson and Roth, 2008, Stoyanov and Eisner, 2012] that are
applicable in a streaming setting, most of such techniques are ad hoc.
We propose a new model, the Latent Left-Linking Model (L3M) that presents a novel, intuitive, and
formal structured prediction framework for clustering. L3M admits efficient greedy inference. For learning
in L3M, we propose an latent variable-based objective function. In order to minimize this function, we use
an efficient stochastic gradient descent technique that can perform learning in an online fashion making
updates to the parameter vector on a per-item basis. Experimental results indicate that our technique is not
only more efficient than the existing aforementioned techniques but is also provides higher accuracy than a
number of competitive baselines.
6
1.3 Contributions of this Thesis
This thesis makes the following specific contributions.
• We propose an efficient technique for supervised structural learning, DecL (Chapter 3). We provide
theoretical guarantees justifying DecL and convincing experimental results showing that for many
problems, simpler, decomposed inference-based learning suffices.
• We propose a new family of EM algorithms (Chapter 4), UEM, by the explicit use of a temperature pa-
rameter (related to Rose [1998], Ueda and Nakano [1998], Hofmann [2001]). UEM generalizes different
existing EM frameworks e.g. hard EM, Constraint-Driven Learning (CODL) [Chang et al., 2007] and
Posterior Regularization (PR) [Ganchev et al., 2010] and helps us better understand the relationships
between these frameworks. It also helps us discover new EM algorithms.
• We propose a general class of convex optimization techniques (Chapter 4) for solving large convex
optimization problems that arise in solving the E-step of UEM. Our optimization framework is very
general and covers existing dual decomposition and Lagrange relaxation techniques for approximating
ILP-based inference [Rush and Collins, 2011, Rush et al., 2010, Koo et al., 2010] as a limiting case and
connects them to techniques proposed earlier in the NLP literature [Ganchev et al., 2008a].
• We propose a novel latent variable framework for clustering of streaming data (Chapter 5) that can
essentially be considered as a supervised discriminative counterpart to the Chinese Restaurant Process
model (or Distance Dependent Chinese Restaurant Process [Blei and Frazier, 2011] to be more precise)
for generative non-parametric clustering.
• We present a generalized framework for latent variable learning of our clustering model (Chapter 5) and
show that, perhaps surprisingly, a stochastic gradient descent strategy is empirically very successful
for learning in our model despite being hard to characterize theoretically.
7
Chapter 2
Structured Prediction: Background
and Existing Work
In this chapter, we present basic notation and relevant existing work to help the reader appreciate the
contribution of this thesis. The notation introduced will be heavily used throughout this thesis. The
background on existing work will cover basic techniques for supervised, unsupervised, and latent variable
structured prediction.
2.1 Preliminary Notation
For a given structured prediction problem, let x represent the input, y represent the output variable of
interest, and h represent the hidden variable (also referred to as latent variable) for cases when we work
with latent variable learning with a hidden intermediate layer. Selecting an appropriate representation y is
naturally very task specific and is often not independent of the underlying prediction model and the inference,
as we want to choose a representation which is most conducive to efficient inference. Some examples of input
and output variables for a task are listed below.
1. Consider the information extraction example presented in Chapter 1. Figure 2.1 presents a snippet
from that example. This task can be modeled as a sequence-tagging problem where we associate one
output label for each word thereby forming a sequence of output labels. Each such output label is
a categorical variable taking one value out of a given set of values (e.g. feat, nbrhd, size in the
information extraction example.) The input x in this case is the text (e.g. craigslist ad) of interest.
The output y in this case is the sequence of labels y1, y2, . . . , yn (presented in Figure 2.1 in red color)
where n is the number of words in the text.
2. For the entity-relation identification problem presented in Chapter 1, x is a document with various
proper nouns of interest. The output in this consists of entity type assignments to each proper noun
and relation type assignment to each pair of proper noun. Let e1, . . . , en represent different proper
nouns in the document. The output y in this case is entity type assignment yi to each ei from a given
set of possible types (e.g. (Per, Org, Loc)) and relation type assignment yij to all pairs of entities
8
y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12
Spacious 1 Bedroom apt . newly remodeled , gated new appliance , new . . .
Figure 2.1: The information extraction task with sequence tagging output labels shown in red color.
[Mary]1 told [John]2 that [she]3 loves [his]4 [brother]5 [Billy]6.
Mary	   John	   she	   his	   Billy	  brother	  
Figure 2.2: Above: A sentence with mentions in brackets. Below: A clustering for the mentions.
(ei, ej), i 6= j, from a given set of possible relation types (e.g. (Lives-in, Works-for, Killed,
None)). Thus y is the union of entity and relation type assignments to each candidate proper noun
and proper noun pair, respectively. x will in effect represent the features associated with all the entities
and all pairs of entities.
3. For the coreference clustering example discussed in Chapter 1, the output is a clustering of mentions
(see Figure 2.2). We need to encode the clustering mathematically into an output variable y, which
can be achieved in several different ways. For example, for a document with d mentions, we can
express y as a collection of binary variables {yij |1 ≤ i < j ≤ d} where yij = 1 is i and j are in the
same cluster, else 0. Thus here we have represented the clustering as a set of
(
n
2
)
binary variables
which must obey transitivity property i.e. (yij = 1) ∧ (yjk = 1) → (yik = 1). An alternate way of
representing a clustering is through a hidden structure h which presents a sparse link-structure of the
mentions (e.g. a spanning forest over a complete graph connecting all mentions) such that the output
clustering is obtained by a transitive closure of the connected components in h [?]. Chapter 5 will
present some ways of representing coreference clustering. The input in this case is the document and
whatever features that can be useful e.g. syntactic parses of the sentences, semantic information of
words in document (e.g. gender, geo-location, profession).
Formalization: A categorical variable that takes its value from a small set of possible labels e.g. {feat,
nbrhd, size } or {Per, Org, Loc }, can be replaced by a small number of binary variables — one for each
possible label in the label set, with an additional constraint that only one of these binary variables can be
9
one. Thus, we can safely assume that y is an ordered set of n binary variables:
y = {y1, . . . , yn} (2.1)
For a given x, let Y(x) ⊆ {0, 1}n be the space of allowed output variables. Note that n may vary with x
and hence y ∈ Y(x) is a more stable and realistic assumption.
2.1.1 Features for Discriminative Models
Discriminative supervised models, with or without latent variables, rely on feature functions for learning and
prediction. Given input x and output y, we define a feature function φ(x,y). For simple classification cases
like binary classification, the features do not really have an explicit dependence on y. In such cases, we will
use only φ(x) to denote the features. For models with latent variables, we will define the feature function as
φ(x,y,h) taking into account the latent variable h. While the usage of φ is overloaded, the correct form will
be clear from the context in this thesis. Also in case of unsupervised models, we will make use of explicit
joint probability models on both x and y where we will not make use of features φ.
In general, defining φ is a modeling choice. In addition to including informative features from the input
x, φ in structured prediction is defined to capture desired level of interaction between the output variable. In
general, the components of a feature function can be likened to clique potentials in Markov Random Fields
or factors in a Factor graph model [Kschischang et al., 1998] (we will not discuss these models in this thesis).
In such cases, φ(x,y) can be defined as
φ(x,y) = (φc(x,y(c)))c∈C , (2.2)
where y(c) is a subset of the entire set of output labels (i.e.{y1, . . . , yn}) indexed by a factor or a clique
c ⊆ {1, . . . , n}, φc(·, ·) are features (related to what is referred to as clique potentials in Markov random
field literature) on the factor c, which can be defined explicitly by enumerating over all possible values y(c)
can take, and C is a set of all such factors. Notably φc do not have to be scalars — they can be vector of
features as well that can be expressed by enumerating y(c). Markov random fields and factor graphs carry
a probabilistic connotation with them (as the are both forms of Probabilistic Graphical Models), in this
thesis, our models may or may not have a probabilistic interpretation.
Most applications, however, define φ in very simple ways, most common being the following two:
10
• Singleton features: In this case, φ decomposes over individual yi:
φ(x,y) = {φi(yi,x)}ni=1 ,
where each φi can either be scalar valued score or a vector of features. These features capture the
interaction between x and individual yi. However, they do not couple multiple output variables and
hence are not really “structured”. The structure in such cases is introduced solely via the constraints
specifying Y(x) which are discussed below in Section 2.1.2.
• Pairwise features: In this case, the feature φ capture the interaction between the input x and
individual output variables yi as well as interaction between pairs of output variables yi and yk. In
particular, with a given set of n output variables, φ are are defined over a graph with n nodes and a
set of edges E. The edges in E capture pairwise interactions between items. Now, φ is a collection of
individual and pairwise feature functions corresponding to nodes and edges of this graph, respectively:
φ(x,y) = {φi(yi,x)}ni=1 ∪ {φij(yi, yj ,x)}(i,j)∈E .
Again φi and φij can either be scalars or vectors. The pairwise features, φij , allow one to capture local
pairwise relationships between output labels. Models that use such pairwise features are often referred
to as Pairwise Markov Networks [Taskar et al., 2004].
In Section 2.2 we will shed further light on prediction with these features.
2.1.2 Constraints
The output variables in structured prediction are often constrained to create coherent structures and rule
out certain spurious structures. Such constraints are often inherent to the problem definition e.g. when
categorical variables with small label sets are replaced by a collection of binary variables (as mentioned
above), these variables are constrained to sum to one (as one can pick only one label). Another example
is that the variables in coreference clustering must obey the transitivity property by the very definition:
(yij = 1) ∧ (yjk = 1) → (yik = 1). However, in some cases constraints are declaratively added based on
domain knowledge to improve the accuracy [Roth and Yih, 2007]. A simplistic example of these kind of
constraints would be adding a constraint during Part-of-Speech tagging that asserts that each ‘sentence
must have at least one verb’. Few other examples, also presented in Chapter 1, include global constraints
on information extraction of information fields [Chang et al., 2007], type constraints between relations
11
and entities [Roth and Yih, 2004], sentential and modifier constraints during sentence compression [Clarke
and Lapata, 2006], and agreement constraints between word-alignment directions [Ganchev et al., 2008a] or
various parsing models [Koo et al., 2010]. The use of constraints has been a boon to several natural language
applications [Roth and Yih, 2005, Clarke and Lapata, 2006, Ganchev et al., 2008a, Koo et al., 2010].
While such constraints are most intuitively understood as first order logic constraints, in most cases it is
possible to propositionalize them [Roth and Yih, 2007, Chang, 2011]. The reader may follow [Rizzolo and
Roth, 2007] for techniques of propositionalizing. Furthermore, it has been shown [Roth and Yih, 2007] that
many interesting constraints can be converted into linear constraints on y. Thus, this thesis assumes that
the constraints are linear in terms of y and are expressed as
U(x)y ≤ b , (2.3)
where U(x) is a matrix created using x and is allowed to be non-linear in terms of x. In particular, the
matrix U encodes r linear constraints. So we have UT (x) =
[
u1
T (x) . . . ur
T (x)
]
and a vector b as
bT = [b1, . . . , br].
The output space, Y(x) is thus specified by these constraints: Y(x) = {y ∈ {0, 1}n|U(x)y ≤ b}. Note
that this set is a finite set of discrete variables not to be confused with a polytope. Polytopes are also
specified as {z|Az ≤ d} but are over real variables whereas y is discrete.
2.1.3 Evaluation and Loss Functions
In order to judge the quality of predictions made by a prediction algorithm, we must define an evaluation
measure. We follow the common practice of defining a loss function ∆ which can measure the “distance”
of a predicted output y′ from a true/gold output ygold. In particular ∆ is a non-negative function defined
as ∆ : {0, 1}n × {0, 1}n → R≥0, satisfying ∆(y,y) = 0, ∀y ∈ Y. Some popular examples of loss function
include zero-one loss: ∆0/1(y,y
′) = Iy=y′ and Hamming loss: ∆H(y,y′) =
∑
i Iyi=y′i , where Ib is an indicator
function which is 1 if the boolean assertion b is true and 0 otherwise.
The most straightforward understanding of ∆ — and this is indeed the case for a large portion of this
thesis — is that ∆ is defined on a per-instance basis and when given a collection of test instances, the total
loss is simple a sum of the losses over each instance. However, in some cases, one needs to define a loss
function (or a measure of accuracy) on the entire test set as e.g. when computing F1 scores or Area-Under-
Curve (AUC), one must look at the predictions on the entire test set as such measures are not decomposable
over individual test instances. In such cases, we can extend ∆ to be defined over the entire test set (and not
12
one test instance) treating the entire test set prediction as one y as is done by Joachims [2005].
2.2 Inference for Structured Prediction
Inference constitutes predicting the “best” structured y for an input x, given a model. Note that this is
in contrast with definition of inference used in Statistics literature where inference constitutes estimating
the model parameters using sample observations. Furthermore, note that here we are defining inference as
obtaining the best output which is the same as MAP inference for probabilistic model for selecting the most
probable output. In probabilistic graphical models literature, inference is a broader term that includes MAP
inference as well as marginal inference over any subset of output variables. In this thesis, however, we are
mostly concerned with MAP inference on all the output variables. Inference in structured prediction involves
taking into account all the dependencies between the variables, which is the reason why the “structure” is
introduced in the model in the first place. Thus, the idea of inference is closely tied to the very notion of
structured prediction.
In this section, we will study the inference problem and various techniques for solving the inference
problem. We will not delve into great details of inference, as learning, not inference, is the focus of this
thesis.
In general, inference is expressed using a scoring function f(x,y) that provides the score of an output
y ∈ Y(x) for a given input x. The task of inference then is to compute the output labeling y with the
highest score:
arg max
y∈Y(x)
f(x,y) . (2.4)
If we have a conditional (or joint) probability distribution Pw(y|x) over y given x parameterized by pa-
rameters (usually learned) w, then the scoring function is simply the log conditional probability of the
output:
f(x,y; w) = logPw(y|x) or logPw(y,x) , (2.5)
where it is equivalent to consider joint probability distribution (more common for unsupervised prediction)
as during inference we do not care to model the probability of x.
For discriminative modeling, the scoring function is expressed as the dot product between the input-
output features φ(x,y) (discussed in Section 2.1.1) that are typically user-defined and a weight or parameter
vector w that is usually learned. Thus we write the scoring function as f(x,y; w) to express this parame-
13
terization:
f(x,y; w) = w · φ(x,y) . (2.6)
It is easy to see that the features φ and the possible constraints encoded in Y(x) are key to express the
“structure” over y. The common inference settings, based on Sections 2.1.1 and 2.1.2, is with singleton
features with constraints and pairwise Markov network based features. We discuss these below.
When the features φ are singleton, then w is really just a concatenation of the weight vectors for each
individual singleton feature. Assuming, Y(x) is expressed using linear constraints U(x)y ≤ b, the inference
problem is
arg max
n∑
i=1
wi · φ(yi,x) = arg max
n∑
i=1
(yiwi · φ(1,x) + (1− yi)wi · φ(0,x))
s.t. U(x)y ≤ b, and yi ∈ {0, 1}, ∀i = 1, . . . , n ,
(2.7)
where wi is the weight corresponding to yi.
In case of pairwise Markov networks (PMN), the inference can be written as
max
y∈{0,1}n
n∑
i=1
wi · φi(yi,x) +
∑
(i,j)∈E
wij · φij(yi, yj ,x) , (2.8)
where wi is the weight corresponding to the i
th vertex, wij is the weight for edge feature φij (both derived
from the weight vector w.) We can also introduce constraints in the PMN setting as shown in example
below.
Illustrative Example 1. Consider a problem from Section 1.1.1 on labeling text segments from advertise-
ments as information fields. In particular, let x1, x2, . . . , xn be the words from an advertisement text. Our
goal is to label the tokens in this sequence with relevant information fields y1, y2, . . . , yn where each yi is a
label chosen from a small set of possible labels, say, {size, feat, nbrhd, rent}. In this case, for instance, we
can define features between the ith token xi and the corresponding label yi and between adjacent labels in
the text yi, yi+1. Thus φ(x,y) is given by
φ(x,y) = (xi ∧ yi|i = 1, . . . , n) ∪ (yi ∧ yi+1|i = 1, . . . , n− 1) .
As such, the feature vector φ(x,y) resides in a high dimensional space with the number of dimensions equal
to size-of -vocabulary × number-of -labels + (n − 1) × (number-of -labels)2. However, only a few — more
precisely, 2n−1 — features are active for any given φ(x,y). Lets assume that our model is a hidden markov
14
model (HMM) such that we have a weight we[j, k] for the feature associated with the jth label in our label
set (e.g. feat) and the kth word in vocabulary (akin to log emission probabilities) and the weight wt[j, j′]
for the feature associated with adjacent labels (in order) being the jth and j′th label from the label set (akin
to log transition probabilities.) Then the score of a sequence y is given by
f(y,x; we,wt) =
n∑
i=1
we[yi, xi] +
n−1∑
i=1
wt[yi, yi+1] .
Furthermore, we can introduce some constraints in this problem. For example, we can introduce a simple
constraint: at least one token must be labeled ‘rent’. This constraint can be expressed as a boolean constraint
(y1 = rent) ∨ (y2 = rent) ∨ . . . ∧ (yn = rent).
Thus, the inference problem can be written as
arg maxy
∑n
i=1 w
e[yi, xi] +
∑n−1
i=1 w
t[yi, yi+1]
s.t. (y1 = rent) ∨ (y2 = rent) ∨ . . . ∧ (yn = rent) .
(2.9)
In the absence of any constraint (e.g. the rent constraint we have introduced), the above HMM inference prob-
lem can be solved using a famous dynamic programming algorithm known as the Viterbi algorithm [Viterbi,
1967]. In general, the above problem can be solved as an integer linear program (ILP.) We will present
the details of converting this problem into an ILP in Section 2.2.1. For more details of expressing inference
problems as an ILP, see Roth and Yih [2005, 2007].
Now, we discuss some algorithmic techniques for performing arg max or MAP inference. We will divide
the discussion into exact and approximate inference techniques. The exact inference techniques return a valid
output which is a global maximum of f(x,y) as expressed so far in this section. The approximate inference
techniques, introduced due to computational reasons, will return an approximately optimum output but will
likely be much faster.
2.2.1 Exact Inference Techniques
In this section, we study techniques for solving exact inference for finding the globally optimal output
assignment.
Dynamic Programming and Combinatorial Algorithmic Techniques:
Many inference problems can be efficiently solved using well-known combinatorial algorithms. For instance,
inference in linear sequential models (e.g. HMM) can be performed using dynamic programming via the
15
Viterbi algorithm. Dynamic programming for efficient inference is more generally applicable to tree struc-
tured [Chow and Liu, 1968] graphs or pairwise Markov networks. Another prominent example of using
dynamic programming for inference in structured prediction is the Cocke-Kasami-Younger (CKY) algorithm
for context-free parsing of natural language sentences. Other examples of tractable combinatorial algorithms
used for structured prediction include maximum spanning tree algorithm for non-projective dependency pars-
ing [Kubler et al., 2009] and graph cuts for image restoration and image segmentation [Greig et al., 1989,
Boykov et al., 2001]. While such combinatorial techniques are largely very efficient, they are only applicable
in very narrow settings (e.g. dynamic programming applies to problems with optimal sub-structure [Cormen
et al., 2001]). Thus, for arbitrary structured prediction problem, we need to look at other more expressive
techniques.
Integer Linear Programming Techniques
Integer linear programming (ILP) techniques are a powerful tool for solving arbitrary inference problems.
The general form of an integer linear program over an n-dimensional vector of binary variables y is given by
max cty
s.t. Uy ≤ b
and yi ∈ {0, 1} ∀i = 1, . . . , n ,
(2.10)
where c is called the cost vector, and Uy ≤ b are linear constraints (we have expressed U(x) as U for
generality.) A large variety of practical inference problems can be expressed as an Integer Linear Program
over discrete binary variables [Roth and Yih, 2005, Clarke and Lapata, 2006, Barzilay and Lapata, 2006,
Roth and Yih, 2007, Clarke and Lapata, 2008, Punyakanok et al., 2008, Choi and Cardie, 2009]. Notice
that both the objective function and the constraints are linear in the variables. Such programs can then
be solved using softwares known as ILP solvers. Below, we present an example of converting the inference
problem from Example 1 into an ILP.
Illustrative Example 2. Consider the inference problem expressed in Eq. (2.9). The labels yi in the
problem are categorical variables taking value from a given set of L possible labels, e.g. { size, feat, nbrhd,
rent }. We can “binarize” the problem by introducing one binary variable corresponding to each token-label
pair. In particular, let yli be a binary variable which is 1 iff yi, the output variable corresponding to the
ith token xi, is equal to the l
th label from the set of all L possible labels. Naturally, the variables thus
introduced have an obvious constraint that for all i, exactly one variable out of y1i , y
2
i , . . . , y
l
i should be one
as yi can take only one label out of the set of all labels. We can express this as the following set of linear
16
constraints:
L∑
l=1
yli = 1, ∀i = 1, . . . , n
Furthermore, we can also express the constraints from Eq. (2.9) as a linear constraint over our binary
variables. Let ‘rent’ be the rth label in the set of all labels. Then the constraint that at least one token
should be labeled with ‘rent’ can be written as
n∑
i=1
yri ≥ 1 .
Thus now, we have replaced all the categorical variables in the original inference problem (Eq. (2.9)) by
binary variables as expressed below:
max
∑n
i=1
∑L
l=1 w
e[l, xi]y
l
i +
∑n−1
i=1
∑L
l=1
∑L
l′=1 w
t[l, l′]yliy
l′
i+1
s.t.
∑L
l=1 y
l
i = 1, ∀i = 1, . . . , n∑n
i=1 y
r
i ≥ 1
yli ∈ {0, 1},∀i = 1, . . . , n, ∀l = 1, . . . , L .
(2.11)
The job, however, is still not complete. An ILP has a linear objective function whereas the objective function
above is quadratic. In order to get around this problem, one can use a simple trick of introducing auxiliary
binary variables. In particular, we introduce binary variables zll
′
i = y
l
iy
l′
i+1. While this equality is still not
linear, it can be equivalently expressed using the following three linear constraints:
zll
′
i ≤ yli and zll
′
i ≤ yl
′
i and z
ll′
i ≥ yl
′
i + y
l
i − 1 .
One can verify that indeed zll
′
i = y
l
iy
l′
i+1 is a unique binary variable to satisfy the above three constraints for
any given values of yl
′
i and y
l
i. Thus, now we can re-write the quadratic binary program in Eq. (2.12) as
max
∑n
i=1
∑L
l=1 w
e[l, xi]y
l
i +
∑n−1
i=1
∑L
l=1
∑L
l′=1 w
t[l, l′]zll
′
i
s.t.
∑L
l=1 y
l
i = 1, ∀i = 1, . . . , n
zll
′
i ≤ yli, zll
′
i ≤ yl
′
i , z
ll′
i ≥ yl
′
i + y
l
i − 1, ∀i = 1, . . . , n, ∀l, l′ = 1, . . . , L∑n
i=1 y
r
i ≥ 1
yli ∈ {0, 1}, zll
′
i ∈ {0, 1} ∀i = 1, . . . , n, ∀l, l′ = 1, . . . , L .
(2.12)
Now, the above ILP can be solved by using an ILP solver.
ILP is a very powerful tool that can express a variety of different inference problems. However, this
17
strength comes at a cost: it is known that integer linear programming is NP Complete. Consequently,
many different ILP problems can be computationally formidable. To alleviate this issue many approximate
inference techniques have been proposed which we discuss next. We end this discussion with the note that
for a large number of practical problems, commercial ILP solvers like Gurobi [Gurobi Optimization, 2013]
are very fast despite the theoretical computational hardness of ILP.
2.2.2 Approximate Inference Techniques
In many cases, finding the globally optimal to the inference problem (Equations (2.4) and (2.6)) is computa-
tionally intractable. Consequently, much work has been done developing approximate inference techniques
that attempt at finding solutions that are not guaranteed to be optimal at lower computational costs. This
section assays a few such techniques, albeit not in great details as learning, and not inference, is the focus
of this thesis.
Linear Programming
Since ILP techniques are NP Hard, researchers often relax ILP to Linear Programming (LP) for which many
polynomial time algorithms, that are also very fast in practice, are known [Schrijver, 1986]. In particular, we
can take the canonical ILP problem from Eq. (2.10) and relax the integrality constraint to get the following
LP
max cty
s.t. Uy ≤ b
and yi ∈ [0, 1] ∀i = 1, . . . , n .
(2.13)
Notably each variable yi is relaxed from being in {0, 1} to [0, 1]. The given program can be efficiently solved
in polynomial time. This technique has been used to solve entity and relation extraction [Roth and Yih,
2004], dependency parsing [Martins et al., 2009], protein folding [Sontag, 2010], and stereo vision [Weiss
et al., 2011] amongst other things.
The reader should note two salient aspects of LP relaxation. First, since the variables in LP (Eq. (2.13))
are less constrained than the variables in ILP (Eq. (2.10)), the maximum value obtained from solving the
LP is an upper bound on the solution obtained by ILP. Second, when the constraint matrix U is totally
unimodular, then the LP relaxation is tight i.e. the above LP returns binary solutions which are also the
solutions for the original ILP [Schrijver, 1986, Roth and Yih, 2005]. In some practical situations, even
without total unimodularity, (e.g. in Roth and Yih [2004]), LP solvers are known to return binary solutions.
18
Algorithm 1 Algorithmic sketch for Lagrange relaxation for approximately solving the ILP in Eq. (2.10)
with a fixed gradient descent rate η.
λ← 0
y← H(c)
for t = 1 to T or until y satisfies Uy ≤ b do
λ← max(λ + η(Uy − b), 0)
y← H(c− λTU)
end for
Lagrange Relaxation
While LP relaxation achieves tractability by relaxing the integrality constraint while satisfying all the linear
constraints, Lagrange relaxation achieves tractability by allowing for violation of the linear constraints while
keeping the solutions integral. Lagrange relaxation is an iterative procedure that converts a given ILP into
a simpler problem, which can be solved efficiently. If the solution obtained for this problem does not satisfy
the constraints, then the solution is recomputed but with additional penalties that encourage the solution
to satisfy the constraints. If, however, the solution satisfies all the constraints, then we are guaranteed to
have arrived at the exact ILP solution.
Lets consider a simple example of Lagrange relaxation for our canonical ILP in Eq. (2.10). Let the number
of linear constraints be m. Then we introduce m dual variables as a vector λ, where the ith dual variable λi
can be interpreted as the penalty for violating the ith constraint. These dual variables are restricted to be
positive. We replace the ILP in Eq. (2.10) by the following equation:
max cTy − λT (Uy − b)
yi ∈ 0, 1 ∀i = 1, . . . , n .
(2.14)
In the absence of any constraints and for a fixed value of lambda, the above equation can be easily solved
for y as y = H(c − λTU) where H is the Heaviside function that is 1 for non-negative arguments and 0
for negative, and it is applied element wise to the vector. We then measure how much the y thus obtained
violates the given constraints. Now, for each constraint, the dual variable or the penalty of violating a
constraint is then increased in proportion to how much that constraint is violated. The Lagrange relaxation
algorithm for approximately solving the ILP is given in Algorithm 1.
One should immediately note that for λ ≥ 0, the value of solution for the objective function for Eq. (2.14)
gives an upper bound on the value of the solution for Eq. (2.10) as
cTy − λT (Uy − b) ≥ cTy
19
for λ ≥ 0 and any y that satisfies the constraints of the ILP (Uy ≤ b.) Consequently, if the Lagrange
relaxation algorithm obtains a solution y that satisfies all the constraints, then we are guaranteed that
y is also the optimal solution for the original ILP. Thus, Lagrange relaxation comes with a certificate of
optimality. While the given algorithm presents a relatively straightforward Lagrange relaxation scheme, it is
possible to extend it to more complex problems with maximizations over combinatorial structures coupled via
constraints. In particular, Lagrange relaxation can be used to solve an intractable optimization problem by
breaking it down into simpler sub-problems that are constrained to agree with each other on the overlapping
variable assignments. In this setting, Lagrange relaxation is also referred to as Dual Decomposition and
has been applied to difficult problems like MAP inference on graphical models [Komodakis et al., 2007] and
dependency parsing of natural language sentences [Koo et al., 2010, Rush and Collins, 2011]. We discuss
this in detail below.
Consider a very general formulation of the inference problem given by
arg max
y
w · φ(x,y) s.t.
U(x)y ≤ b .
(2.15)
Decomposing the scoring function: Lets assume that the scoring function decomposes into l different
components or factors as
w · φ(x,y) =
l∑
k=1
wk · φ(x,y[k]) ,
where y[k] ∈ {0, 1}nk represents the subset of nk ≤ n output variables that correspond to the kth factor,
φ(x,y[k]) represents the features for this factor, and wk are weights for this factor. Furthermore, assume
that these factors are such that they admit efficient inference when augmented with a linear term over y[k].
That is the following inference is efficient for all k = 1, . . . , l and for all vk ∈ {0, 1}nk
arg max
y[k]∈{0,1}nk
wk · φ(x,y[k]) + vk · y[k] . (2.16)
Most structured prediction problems can be decomposed into components that admit efficient inference.
For example, [Komodakis et al., 2007] consider decomposing a Pairwise Markov Networks into factors over
individual edges of the underlying graph each of which trivially admit efficient inference. Koo et al. [2010]
decompose two different parsing models, each of which admits efficient inference, that are constrained to
agree into individual parsing models.
Furthermore, it is easy to see that we can related y[k] to y linearly via a simple nk × n binary matrix
20
Algorithm 2 Algorithmic sketch for Lagrange relaxation for approximately solving the inference in Equa-
tion (2.15) with a fixed gradient descent rate η.
λi,λ
1
e, . . . ,λ
l
e ← 0
yk ← arg maxy1∈{0,1}nk wk · φ(x,yk), ∀k = 1, . . . , l
for t = 1 to T or until the constraints in (2.18) and (2.19) are satisfied do
y← H(−λTU(x)−
∑l
k=1(µk)
TAk)
λ← max(λ + η(Uy − b), 0)
µk ← µk + η(Aky − yk), ∀k = 1, . . . , l
yk ← arg maxyk∈{0,1}nk wk · φ(x,yk)− µk · yk, ∀k = 1, . . . , l
end for
Ak as y[k] = Aky. Combining all of these implies that the inference in Equation 2.15 can be rewritten as
arg max
y1∈{0,1}n1 ,...,yl∈{0,1}nl , and y∈{0,1}n
∑l
k=1 wk · φ(x,yk) s.t. (2.17)
U(x)y ≤ b (2.18)
yk = Aky ∀k = 1, . . . , l . (2.19)
Note that the scoring function (2.17) above does not include y. y plays a role via agreement constraints 2.19
which force each component y1, . . . ,yl to agree with y thereby forming a coherent structure.
Now we can use the Lagrange relaxation technique for approximate inference. We use dual variables λ
for the inequality constraints in Equation 2.18, and dual variables µk for the k
th agreement constraint in
Equation 2.19. We can thus write down the Lagrangian as
L(λi,λ
1
e, . . . ,λ
l
e,y1, . . . ,yl,y) =
l∑
k=1
wk · φ(x,yl)− λ · (U(x)y − b)−
l∑
k=1
µk · (Aky − yk) , (2.20)
and the resulting optimization problem is
min
λ0,µ1,...,µl
arg max
y1∈{0,1}n1 ,...,yl∈{0,1}nl , and y∈{0,1}n
L(λ,µ1, . . . ,µl,y1, . . . ,yl,y) . (2.21)
In order to solve the above optimization scheme we can again use a scheme similar to Algorithm 1 where we
iteratively perform gradient descent to dual variables and re-estimate primal variables. The result Lagrange
relaxation scheme is presented in Algorithm 2. Note that due to our assumption that the inference in
Equation (2.16) is efficient, the estimation of yk in the algorithm is efficient.
Lagrange relaxation technique is largely borrowed from the convex optimization literature [Bertsekas,
1999]. Later in this thesis (Chapter 4) we will present a generalized framework that will smoothly connect
Lagrange relaxation for ILP problems to its convex optimization counterparts.
21
Message Passing and Belief Propagation
Message passing refers to a general iterative algorithmic scheme for marginal or MAP inference, in which
different (overlapping) components of a structured prediction model communicate with each other via mes-
sages (that are essentially information bits) to converge to the desired value. Belief propagation (BP) is one
such message passing scheme that was originally proposed by Pearl [1988] to do exact probabilistic inference
on singly-linked graphical models. However, for loopy graphs (i.e. undirected graphs with cycles), BP no
longer is guaranteed to converge to exact marginals or MAP assignment. Nonetheless, loopy BP has been
used in practice and further understanding has been developed [Wainwright et al., 2004, Yedidia et al., 2005].
He we discuss a basic variant of BP for pairwise Markov networks. Recall that in pairwise Markov
networks (PMN), each variable is a node in a given graph G = ((1, . . . , n), E) and the features are defined
on nodes and edges of this graph. The inference for PMNs is presented in Equation (2.8), which we re-write
as
arg max
y∈{0,1}n
n∑
i=1
ψi(yi) +
∑
(i,j)∈E
ψij(yi, yj) , (2.22)
where ψ are what are called potential functions created from the features φ and their corresponding weights
w as ψi = wi · φi(·,x) and ψij = wij · φij(·, ·,x).
In BP, each node i sends messages to all the nodes in its neighborhood (i.e. all the nodes that are
connected to it) in graph G, which we denote by Ni. A message, mij : {0, 1} → R+ sent by node i to its
neighboring node j, can be roughly thought of as the belief of node i that node j takes a particular label
in the maximizing assignment. In iteration t+ 1, the message mt+1ij are updated based on the messages for
iteration t as
mt+1ij (yj)← αj max
yi∈{0,1}
exp(ψij(yi, yj)) exp(ψi(yi))
∏
k∈Ni\j
mtki(yi) , (2.23)
where αj is a normalizing constant to ensure that all messages coming into node j sum to one. Using these
messages, the MAP assignment to node i is given by
arg max
yi∈{0,1}
exp(ψi(yi))
∏
j∈Ni
mji(yi) . (2.24)
The above form of BP is called max-product BP which is different from sum-product BP that was proposed
by Pearl for marginal probability calculations.
Simple max-product BP is known to suffer from many drawbacks beyond being only an approximate
inference technique for loopy graphs. In particular, it is known the BP can have many different fixed
points. Consequently many techniques for “convexifying” BP have been proposed [Wainwright et al., 2002,
22
Kolmogorov, 2006] that provide tighter bounds to the MAP approximation and have better convergence
guarantees. Martins et al. [2010] have proposed techniques to include hard constraints in the belief propa-
gation framework.
In general, message passing is a very broad framework and has many desirable properties — it is efficient,
can be easily parallelized, and can be suitably tailored to a particular inference problem. Consequently, it
is desirable to solve inference problems for a structured prediction model using message passing.
Fortunately, it has been shown that message passing has very strong ties with other approximate MAP
inference techniques discussed above namely linear programming relaxation and dual decomposition tech-
niques. It is shown that linear programming inference for pairwise Markov networks can be performed using
message passing [Weiss et al., 2011] and a variety of message passing schemes have been proposed to this
end [Werner, 2007, Globerson and Jaakkola, 2007, Meltzer et al., 2009]. The reader can refer to [Weiss et al.,
2011] for more details. Similarly, Sontag et al. [2011] show that dual decomposition for approximate MAP
inference over graphical models can be achieved via a message passing scheme. Since inference is not the
focus of this thesis, we do not go into further details of these techniques.
2.3 Supervised Structural Learning
Supervised structural learning focuses on learning the weight w given a set of labeled training instances
D = (x1,y1), . . . , (xm,ym). In its most basic form, learning can be specified as obtaining a weight vector
w, that satisfies:
w · φ(xj,yj) ≥ w · φ(xj,y), ∀y ∈ Y(xj), and, ∀j = 1, . . . ,m . (2.25)
In other words, we would want a w that separates the ground truth yj from all other competing assignments
y. While this is certaintly a desirable property — and we will present theoretical results based on this
property in Chapter 3 — this in itself is not sufficient to find a single good w for two reasons. One, it
is possible that the data may not be separable and in that case, forcing the above requirement may yield
nothing. Second, if the data is indeed separable, most likely there will be not just one but a set of separating
weight vectors and thus one needs regularization to pick a good w out of the set of separating weights.
Thus most commonly, w is learned by minimizing regularized empirical loss over the training data:
Γ(w) =
β
2
‖w‖2 + 1
m
m∑
j=1
`(xj,yj; w) , (2.26)
where `(xj,yj; w) is a loss function, and β is a constant typically tuned using a validation set. With a convex
23
loss function ` and for β > 0, the above objective function is strictly convex and hence admits a unique
minima.
Surrogate loss during learning: As the loss function(s), ∆, used for evaluation like zero-one loss or
Hamming loss are often intractable to minimize due to their non-continuous (and non-convex) nature, it is
common in machine learning to use surrogate — often convex — loss functions that are more amenable to
optimization. Examples of such loss functions for binary classification are hinge-loss (used in support vector
machines), squared-loss (used in least squares regression), and log loss (used for logistic regression.) Different
choices of the loss function lead to different learning algorithms. We discuss two popular techniques below
— Conditional Random Fields and Structural Support Vector Machines — although our focus will be on
the latter.
Conditional Random Fields: In conditional random fields (CRF), Lafferty et al. [2001], the conditional
probability of an output variable y, given the input features x, is given by
Pr(y|x; w) = exp(w · φ(x,y))∑
y′∈Y(x) exp(w·φ(x,y′))
. (2.27)
For learning with CRFs they minimize a regularized version of the negative conditional log-likelihood of the
ground truth labels given by
β
2
‖w‖2 + 1
m
m∑
j=1
log
 ∑
y∈Y(x)
exp
(
w · φ(y,xj)
)−w · φ(y,xj)
 . (2.28)
Structural Support Vector Machines (structural SVM) Most parts of this thesis will primarily focus
on the structural SVM algorithm [Taskar et al., 2004, Tsochantaridis et al., 2004] that uses a margin-based
structured hinge loss. Structural SVMs learn w by minimizing
GL(w) =
β
2
‖w‖2 + 1
m
m∑
j=1
max
y∈Y
(
w · φ(xj,y) + ∆(yj,y)−w · φ(xj,yj)
)
, (2.29)
where ∆ is the target loss function we wish to minimize. The structured hinge loss, maxy∈Y(w · φ(xj,y)
+∆(yj,y) −w · φ(xj,yj)) is a generalization of the binary hinge-loss and a tight and convex upper bound
on the target loss function given by
1
m
m∑
i=1
∆(yj, arg max
y∈Y(xj)
w · φ(xj,y)) .
24
To see this, let ŷ = arg maxy∈Y(xj) w · φ(xj,y), then we have
max
y∈Y
(
w · φ(xj,y) + ∆(yj,y)−w · φ(xj,yj)
)
≥ w · φ(xj, ŷ) + ∆(yj, ŷ)−w · φ(xj,yj) ≥ ∆(yj, ŷ) .
Structural SVMs are very closely tied to original separation condition stated in Eq. (2.25), as the optimization
problem for structural SVMS can be re-written as
arg min
w
β
2
‖w‖2 + 1
m
m∑
j=1
ξj s.t. (2.30)
w · φ(xj,yj) ≥ w · φ(xj,y) + ∆(y,yj)− ξj ∀y ∈ Y(xj), and, ∀j = 1, . . . ,m . (2.31)
In other words, structural SVMs try to learn w that achieves margin-based separability while allowing
for some slack and regularizing w. Based on the above formulation of structural SVMs, it is easy to see
that minimizing GL(w) to learn w is a Quadratic Programming (QP) problem with exponentially many
constraints as in Eq. (2.31).
In the rest of this section, we will largely focus on algorithms for learning with structural SVMs. We
will ocassionally discuss conditional random fields learning with probabilistic models, but that will largely
be for the ease of exposition.
2.3.1 Global Learning of Structural SVMs
In order to minimize GL(w), one can take a variety of different approaches. It cannot directly be solved
as QP because of an exponentially large number of constraints. Originally, Tsochantaridis et al. [2004]
proposed a cutting plane approach to solve this. We do not discuss this approach in detail. We present a
more commonly used stochastic gradient-based technique [Shalev-Shwartz et al., 2011].
Stochastic Gradient Descent for SVMs
Stochastic gradient descent (SGD) is a very popular technique in Machine Learning [Lecun et al., 1998,
Zhang, 2004, Shalev-Shwartz et al., 2011], primarily due to its simpler form and ease of implementation.
SGD is commonly applied to minimize functions f(w) that can be expressed as a sum of simpler functions:
f(w) =
m∑
j=1
fj(w) .
If one wishes to minimize f(w), one approach could be to use gradient descent. Gradient descent iteratively
obtains updated values of w: w1,w2, . . ., which converge toward a minima of function f . The values are
25
updated as
wk+1 ← wk − ηk∂f(wk) , (2.32)
where ∂f(wk) is the derivative of function f at w = wk and ηk is a step-size that can obtained using line
search. While gradient descent is a very useful technique, in this case, it requires us to go over all fj to
compute the gradient.
SGD, on the other hand, makes updates with a “noisy” or stochastic gradient ˜∂f(w) which is required to
satisfy E[ ˜∂f(w)] = ∂f(wk). In particular, SGD, can take advantage of the decomposed nature of function
f , and can use a stochastic gradient ∂fj(wk) instead of full-gradient ∂f(wk) in Equation 2.32, where j is
selected uniformly at random from {1, . . . ,m}. In particular, since our target function GL(w) can be shown
to decompose over individual training examples, SGD can be easily used where stochastic gradients are
computed on a randomly picked training example or a block of training examples. In the former case, when
the randomly picked example is j, the stochastic gradient for GL(w) is given by
βw + φ(xj, ŷ)− φ(xj,yj), where ŷ = arg max
y∈Y(xj)
(w · φ(xj,y) + ∆(y,yj)) .
Algorithm 3 presents a scheme of learning with SGD. The optional step of reducing the norm of w was
presented by Shalev-Shwartz et al. [2007], but in a later publication [Shalev-Shwartz et al., 2011], they
showed that this step does not significantly affect the rate of convergence. The step sizes ηt must obey certain
conditions to guarantee convergence. In particular, SGD converges to the right opitmum in expectation [Boyd
and Mutapcic, 2007], provided ηt satisfy
ηt ≥ 0,
∞∑
t=1
η2t <∞, and
∞∑
t=1
ηt =∞ .
A popular choice of SGD step size [Shalev-Shwartz et al., 2011] is ηt ∝ 1t , which satisfies all of the above
conditions.
Discussion on SGD and Averaging SGD is a very popular and easy to implement techniques and enjoy
good convergence guarantees. Shalev-Shwartz et al. [2011] show that after T iterations, SGD for SVMs (or for
any convex, possibly non-smooth function) converges to within O(log(T )/T ) of the optimal value attainable,
in expectation. However, in general, it is hard to tell if the procedure has converged which is one of the
drawbacks of SGD. In fact, the objective function value for SGD may even increase after a stochastic gradient
update. Another shortcoming of SGD is that it may not be very stable and its performance can fluctuate
from iteration to iteration. In order to stabilize SGD, it is common to use the averaging trick where the
26
Algorithm 3 Algorithm for learning structural SVMs with stochastic sub-gradient descent.
1: Input: Training data, D = {(xj,yj)}mj=1, step sizes ηt, number of iteration T , and regularization penalty
β.
2: w1 ← 0
3: for t = 1 . . . T do
4: j ← Uniform({1, . . . ,m})
5: ŷ← arg maxy∈Y(xj)(w · φ(xj,y) + ∆(y,yj))
6: sg ← βw + φ(xj, ŷ)− φ(xj,yj)
7: wt+1 ← wt − ηtsg
8: Optional: wt+1 ← min(1, 1√
β‖wt+1‖ )w
t+1
9: update ηt to get ηt+1
10: end for
output weight vector is an average of weights from all the iterations: woutput =
1
T+1
(∑T+1
i=1 wi
)
. In addition
to this näıve averaging scheme, recently two better averaging schemes have been proposed independently
by Lacoste-Julien et al. [2012] and Shamir and Zhang [2013] that both achieve O(1/T ) convergence rate for
convex non-smooth functions. In the technique by Lacoste-Julien et al. [2012], the weights are averaged by
the iteration that is the output is
woutput =
2
(T + 1)(T + 2)
T+1∑
t=1
twt .
Furthermore, a dual coordinate ascent technique proposed by Lacoste-Julien et al. [2013] based on Frank-
Wolfe optimization, operates much in the same way as SGD, obtains O(1/T ) convergence, and, unlike SGD,
provides the duality gap which can be used to test for convergence.
Loss-Augmented Inference Notice that on line 5 of the learning algorithm, we are doing loss-augmented
inference which is related yet different from the task of pure inference as expressed on Equations (2.4)
and (2.6). In some cases, if ∆ decomposes in the same way over individual components of y as φ, then
loss-augmented inference can be solved using the same machinery as standard inference. For example, when
the scoring function is expressed as a pairwise Markov network as in Equation (2.8) and ∆ is the Hamming
27
loss function (defined in Section 2.1.3), then the loss-augmented inference can be expressed as
arg max
y∈Y(xj)
(
w · φ(xj,y) + ∆(y,yj)
)
= arg max
y∈Y(xj)
(∑
i
wi · φi(yi,x) +
∑
(i,j)∈E
wij · φij(yi, yj ,x) +
∑
i
Iyi=yji
)
= arg max
y∈Y(xj)
(∑
i
(
wi · φi(yi,x) + yi + yji − 2yiy
j
i
)
+
∑
(i,j)∈E
wij · φij(yi, yj ,x)
)
= arg max
y∈Y(xj)
(∑
i
w′i · φ′i(yi,x) +
∑
(i,j)∈E
wijφij(yi, yj ,x)
)
,
where the penultimate step results from the fact that Iyi=yji = yi + y
j
i − 2yiy
j
i for binary yi, y
j
i , φ
′
i and
w′i are the modified feature function and modified weights for each vertex i with the linear loss term
(yi−2yiyji ) folded inside. Thus maximizing the loss-augmented function in this case can be performed using
the algorithmic machinery developed for inference.
However, in general, loss-augmented inference can be more difficult to solve if the loss function ∆ does
not decompose as φ. In many cases this is indeed the case and there is limited work (e.q. Joachims [2005]
solves it for variour performance measures for binary classification problems) on loss-augmented inference
for difficult loss functions. In general, practitioners use simple Hamming loss during training for tractability.
For the rest of this paper, unless otherwise stated, we will assume that loss-augmented inference has the
same set of algorithmic properties as standard inference.
Global Inference and the Complexity of Learning In general, the complexity of learning is domi-
nated by the complexity of the loss-augmented inference step. The assumption so far is that the inference is
performed in an exact fashion (using exact inference techniques discussed in Section 2.2.1) — an assumption
that we will break later on in this chapter. Exact inference, as discussed in Section 2.2, can be computa-
tionally expensive, which in turn implies that learning with exact inference can be slow as well. One of the
reasons why learning with exact inference can be slow that it performs a global inference considering all the
variables together as an intermediate step. We will use this characteristic as a defining characteristic of a
certain class of learning algorithms, which we call the Global Learning (GL) algorithms.
Definition 1. Global learning refers to the family of supervised structured prediction algorithms which use
exact global inference (i.e. MAP or arg max inference) as an intermediate step.
In the next subsection, we present some other examples of GL algorithms. Later, chapter 3 will present
an algorithm that achieves efficient learning by reducing the inference-during-learning step to a small subset
of variables.
28
2.3.2 Other Examples of Global Learning
The stochastic gradient descent algorithm for structural SVMs presented in the last section required global
inference as an intermediate step and hence was a global learning algorithm. The same holds true for all
variants of optimization algorithms for structural SVMS — the cutting plane method [Tsochantaridis et al.,
2004] requires global inference to generate cutting plane constraints and the stochastic dual coordinate ascent
method of Lacoste-Julien et al. [2013] requires the same global inference to generate the gradient with respect
to dual variables.
There are supervised structural learning algorithms, other than structural SVMs, that also require global
inference. The structured perceptron algorithm by Collins [2002] is very similar to the stochastic gradient
descent algorithm we present (Algorithm 3). In fact by setting β = 0 (no regularization — structured
perceptron is a purely online learning algorithm), and fixing the step size to a constant value, will yield
the structured perceptron algorithm. In practice, [Collins, 2002] also suggests using the averaging trick
(resulting in averaged structured perceptron) to obtain better results. Another commonly used structural
learning algorithm is Margin Infused Relaxed Algorithm (MIRA) which belongs to the class of online passive
aggressive algorithms [Crammer et al., 2006]. MIRA also requires global inference as intermediate step (some
versions of MIRA require k-best outputs that is not just 1 but k highest scoring items.) For all of these
algorithms, we get the following observation.
Observation 1. Structural SVM, Structured Perceptron, and MIRA, as proposed in their original form are
Global Learning algorithms.
Note that CRFs [Lafferty et al., 2001] also require considering all the output variables together. However,
they perform marginal inference that involves summing over all the variables and not performing a max.
However, CRF like algorithms are not the focus of this thesis in terms of supervised structural learning
— we focus on MAP inference based algorithms. In general though, one is not necessarily better off with
CRFs as marginalizing over graphical models is harder than performing MAP inference as the former is
#P-Complete [Roth, 1996], while the latter is NP complete.
Since learning with exact global inference can be slow for expressive models, several approximate learning
techniques have been introduced in the literature which we discuss in the next section.
2.3.3 Approximate Supervised Structural Learning
In this section, we discuss various techniques to perform efficient but approximate learning. We will discuss
techniques that achieve tractability by ignore certain parts of the structure, use approximate inference, or
29
performing inference on smaller subsets of variables.
Local Learning
We use the term Local learning (LL) to refer to those approximate learning techniques that ignore certain
structural (usually global) interactions such that the rest of the structure is more local or easier to learn.
In particular LL is applicable for those cases where the scoring function itself is benign and admits efficient
inference but inference has been rendered difficult due to introduction of highly expressive constraints. In
such cases, LL paradigm suggests that the constraints should be dropped, learning the weight vector w only
w.r.t. the scoring function which is easier to learn.
For example, consider the setting where inference involves maximizing a singleton scoring function subject
to linear constraints — a setting quite common in many NLP applications [Clarke and Lapata, 2006, Barzilay
and Lapata, 2006, Roth and Yih, 2007, Clarke and Lapata, 2008, Choi and Cardie, 2009]. The inference
for this case is presented in Eq. (2.7). With arbitrary constraints on the output variables, inference can
be an arbitrarily hard ILP problem (ILP is NP Complete.) However, if drop the constraints, then the
corresponding structural SVM objective function, with ∆ being the Hamming loss, becomes
β
2
‖w‖2 + 1
m
m∑
j=1
max
y∈{0,1}n
(
n∑
i=1
wi · (φi(1,x)− φi(0,x)) yi −
n∑
i=1
wi · (φi(1,x)− φi(0,x)) yji +
n∑
i=1
Iyi=yji
)
=
β
2
‖w‖2 + 1
m
m∑
j=1
n∑
i=1
max
yi∈{0,1}
(
wi · δφi(x)yi −wi · δφi(x)yji + Iyi=yji
)
=
β
2
n∑
i=1
‖wi‖2 +
1
m
m∑
j=1
n∑
i=1
max
yi∈{0,1}
(
wi · δφi(x)yi −wi · δφi(x)yji + Iyi=yji
)
=
n∑
i=1
(β
2
‖wi‖2 +
1
m
m∑
j=1
max
yi∈{0,1}
(
wi · δφi(x)yi −wi · δφi(x)yji + Iyi=yji
))
, (2.33)
where δφi(x) = φi(1,x)−φi(0,x), and the penultimate step follows from the fact that w is a concatenation
of w1, . . . ,wn. Note that the learning problem expressed by the minimization of Eq. (2.33) is equivalent to
learning n independent binary SVMs for y1, . . . , yn, which can be performed efficiently. This simplification
happens because after removing the constraints, the variables in y get decoupled.
In most LL scenarios, the ignored constraints can be injected back during inference, as these constraints
are hard constraints and we do not need to estimate any associated parameters1. We call the technique,
when constrained inference is performed only during testing time, LL+I. The LL+I framework is very
popular in NLP applications of structured prediction [Barzilay and Lapata, 2006, Roth and Yih, 2005].
1 Chang et al. [2007] present some heuristics for estimating the weights of soft constraints ignored during inference.
30
Refer to Punyakanok et al. [2005] for a detailed analysis and comparison of GL and LL for singleton scoring
functions with constraints.
Similarly to singleton functions, the LL+I idea can be applied to efficient discriminative learning of HMM
parameters with constraints [Chang et al., 2007] (e.g. the problem presented in Eq. (2.12)), of sequential
CRFs [Roth and Yih, 2005], and in general problems with efficient combinatorial inference that is rendered
difficult by certain constraints e.g. dependency parsing [Koo et al., 2010]. For instance, when learning
HMM models (like in the information extraction example we discussed in Example 2), we can ignore the
constraints, perform inference-based learning as in Algorithm 3 using efficient Viterbi inference, and put the
constraints back during decision time inference.
Local learning has an obvious advantage over GL in terms of training speed as it does not explore the
possibly exponential output space during inference. However, LL fails to take advantage of the structure
of Y(x). While LL+I tries to alleviate this problem by imposing constraints during testing, the parameters
learned by LL may still exhibit problems of inconsistency as they are agnostic to the presence of constraints.
We present an example in Section 3.1 to demonstrate this point. However, still such techniques are popular
in practice due to the simplicity of training and good empirical performance in practice.
Learning with Blackbox Approximate Inference Techniques: Belief Propagation and Linear
Programming
In this section, we will survey the effects of replacing exact inference during learning by approximate inference
techniques discussed in Section 2.2.2. In particular, we will survey works [Kulesza and Pereira, 2008, Finley
and Joachims, 2008] that use black box approximate inference techniques like LP relaxations and Belief
Propagation.
The exact inference techniques return the optimal y from the set Y(x). The approximate inference
techniques can be seen as returning an optimal y from an output set that is different from Y(x). We
characterize the nature of approximate inference based on the modified set of outputs following Finley and
Joachims [2008] in two ways:
• Undergenerating approximations: In this scenario, the approximate inference routine returns the
optimal output, arg maxy∈Y(x) w · φ(x,y), from set Y(x) which is a subset of the entire output space
Y(x) i.e. the obtained output can have a lower score than the globally optimal output. Many inference
algorithms fall into this framework, for example belief propagation or greedy maximization of one
output variable at a time.
• Overgenerating approximations: In this scenario, the approximate inference routine returns opti-
31
mal output from a set Y(x) which is a superset of Y(x). Examples of this style of inference-during-
learning include the local learning paradigm which we discussed in the last section (as it ignores the
constraints specifying Y(x)) and linear programming (LP) relaxation which relaxes the outputs from
being {0, 1} to [0, 1] (Equation (2.13)). Note that for LP relaxation, we are not assuming that the
outputs are rounded to nearest binary values. Instead, we just use the fractional variables as is during
the gradient update for learning.
Below, we discuss some salient aspects of these two styles of learning. We base our discussion on Pun-
yakanok et al. [2005], Kulesza and Pereira [2008], and Finley and Joachims [2008].
Learning with undergenerating approximations: Finley and Joachims [2008] present results bound-
ing the number of iterations to converge as well as empirical training error for undergenerating approxima-
tions which obtain a constant factor approximation to the globally optimal solution. In general, however,
such approximation guarantees are hard to come by for approximate inference algorithms like belief prop-
agation2. Kulesza and Pereira [2008] point out a serious problem with belief propagation based inference,
wherein as the number of iterations grows, the learning process can diverge to an estimator that is the inverse
of the true estimator. Intuitively, this happens because the learning process is misled into comparing against
the wrong output, which can drive the learning away from the true estimator. Finley and Joachims [2008]
further drive this point home and report that experimentally, belief propagation based learning performs
significantly worse than global learning because the learning process is misled into stopping early as the
MAP outputs are sometimes missed.
Learning with overgenerating approximations: Overgenerating approximations tend to be more con-
servative than exact inference based global learning as they search for competing label assignments over a
larger output space. Kulesza and Pereira [2008] present a negative side to overgenerating approximations and
show that LP relaxation-based learning may fail to find a separating hyperplane for the given training data,
even though the data may be separable. Similarly Punyakanok et al. [2005] show that LL approaches for
singleton functions with constraints tend to be more conservative than GL. However, there is some significant
evidence in the favor of overgenerating approximations against undergenerating approximations. Punyakanok
et al. [2005] present conditions under which LL techniques may even outperform GL in terms of generaliza-
tion error. Kulesza and Pereira [2008] present generalization bound for LP inference based learning, when
also using LP inference during testing. Finley and Joachims [2008] present empirical results show that linear
2One exception is the LP rounding based scheme of Chekuri et al. [2001] that guarantees a constant approximation to PMN
inference.
32
programming based learning performs close to global learning and far better than belief propagation.
More notes on learning with approximate inference: In general, using black box approximate in-
ference introduces bias in learning. The kind of approximation scheme used during learning is not only
critical to the learning process, it also affects the inference used during testing or decision time. For in-
stance, [Wainwright, 2006] show that when using a specific approximate variational inference during learn-
ing, which introduces bias in parameter estimation, it is advantageous to use the same kind of approximate
inference (instead of exact inference) during testing as well. Finley and Joachims [2008] empirically discuss
the relationship between approximation during learning and approximation during inference. An interested
reader should also see Kulesza [2009] for a detailed analysis of approximate inference based learning.
Pseudolikelihood-style Learning
This section will survey some techniques that are borrowed from literature on efficient and consistent learning
of probabilistic graphical models. The main theme of these techniques is that inference during learning is
performed on small subsets of output variables while conditioning on the remaining variables.
We will first focus on conditional likelihood learning for CRFs, and then discuss the max-margin setting.
This line of work started with the pioneering work of Besag [1974] who proposed Pseudolikelihood as a
computationally efficient alternative to maximum likelihood. Given a conditional probability distribution
over y given x: P (y|x; w) ∝ exp(w · φ(x,y)), we can write the pseudolikelihood for an observed training
instance (xj,yj) as
PL(yj,xj; w) =
n∏
i=1
P (yji |y
j
−i,x
j; w) =
n∏
i=1
exp(w · φ(xj,yj))∑
y′∈{0,1} exp
(
w · φ
(
xj, (y′,yj−i)
)) , (2.34)
where yji is the i
th output variables in yj, yj−i represents all the output variables in y
j except yji , (y
′,yj−i)
represents the output formed by replacing yji by y
′ in yj, and we have assumed that the variables are not
constrained. Notice that likelihood computation (Equation 2.27) can be computationally expensive because
the partition function or the denominator requires summing over an exponentially large number of outputs
(sometimes it is feasible for tree-structured graphical models). However, Psuedolikelihood is computationally
tractable as we are only summing over the number of possible labels for each individual output variable (only
2 possibilities for the binary case.) The tractability has been achieved by conditioning on the ground truth-
values of the remaining variables.
The idea of Pseudolikelihood is generalized by composite likelihood [Lindsay, 1988], where instead of
considering one variable at-a-time, we consider subsets of variables. In particular, given different subsets of
33
variables s1, . . . , sl ⊆ {1, . . . , n} such that
⋃l
k=1 sk = {1, . . . , n}, the composite likelihood3 is defined as
CL(yj,xj; w) =
l∏
k=1
P (yjsk |y
j
−sk ,x
j; w) =
l∏
k=1
exp(w · φ(xj,yj))∑
y′∈{0,1}|sk| exp
(
w · φ
(
xj, (y′,yj−sk)
)) , (2.35)
where yjsk is assignment to the output variables in y
j indexed by the set sk, y
j
−sk represents all the output
variables in yj except in sk, and (y
′,yj−sk) represents the output formed by replacing the variables in y
j
sk
by y′ in yj. Again, computing composite likelihood is cheap if the sizes of the sets s1, . . . , sl is small.
We can apply the above ideas to idea of Conditional Random Field learning (Equation 2.28) by replacing
(exact) likelihood by composite likelihood. This yields the following objective function
β
2
‖w‖2 + 1
m
m∑
j=1
l∑
k=1
log
 ∑
y′∈{0,1}|sk|
exp
(
w · φ
(
xj, (y′,yj−sk)
))−w · φ(y,xj)
 . (2.36)
The gradient computation, and hence learning, for composite likelihood learning is computationally easy if
each subset sk is small.
Application of Pseudolikelihood to max-margin setting: Pseudomax [Sontag et al., 2010]:
Sontag et al. [2010] transfer the idea of Pseudolikelihood based learning from the probabilistic setting to
the max-margin setting — the setting that is the focus of this thesis. In this setting, instead of expressing
the loss based on the probability of one output variable conditioned on the rest, one compares with the
maximum margin assignment to one variable, while fixing the remaining variables. Pseudomax modifies the
structural SVM objective function GL(w) (Equation 2.29) and minimizes the following objective function:
β
2
‖w‖2 + 1
m
m∑
j=1
n∑
i=1
max
y′∈{0,1}
(
w · φ
(
xj, (y′,yj−i)
)
+ ∆(yj, (y′,yj−i))−w · φ(xj,yj)
)
, (2.37)
that is the maximization is carried out over one output variable at a time. Sontag et al. [2010] considered the
case when the scoring function is based on a PMN and there are no constraints. The stochastic subgradient
for the above objective function for any given training instance (xj,yj) is given by
βw +
n∑
i=1
φ
(
xj, (y∗i ,y
j
−i)
)
− φ(xj,yj), where y∗i = max
y′∈{0,1}
(
w · φ
(
xj, (y′,yj−i)
)
+ ∆(yj, (y′,yj−i))
)
.
The gradient thus can be computed efficiently.
3We have made a minor simplification in the definition of composite likelihood. In the general case, the set of conditioning
variables is also allowed to be varied.
34
Advantages: The important theoretical advantages of using pseudolikelihood-inspired learning techniques
is that they are consistent i.e. as the number of training examples approach infinity (ignoring regularization),
the pseudolikelihood, the composite likelihood, and the pseudomax4 estimator approaches the true estimator.
The same cannot be said for the approximate inference techniques we have discussed that introduce bias in
learning. Additionally, these techniques perform learning without inferring the output variables — inference
is really performed on small subsets of variables that make these techniques computationally efficient. There
are techniques in the literature [Sutton and McCallum, 2007] that make learning with pseudolikelihood like
estimators even more efficient at the cost of introducing some bias during learning.
In Chapter 3, we will present a new technique, Decomposed Learning, that will generalize pseudomax in a
non-trivial way to consider larger sets of variables and incorporate domain specific constraints. Furthermore,
we will lift the restriction in composite likelihood [Lindsay, 1988] that a fixed subsets of variables s1, . . . , sl
have to be used for all training examples.
2.4 Unsupervised and Semi-supervised Learning with EM and
its Variations
In this section, we focus on unsupervised and semi-supervised structural learning with the Expectation
Maximization (EM) algorithm [Dempster et al., 1977] and its several variants. We also consider an additional
dimension of adding prior-knowledge based constraints into EM, which then results in a set of different EM
algorithms.
2.4.1 Preliminaries
For unsupervised learning, the goal is to learn the parameters w, only given the input x and not the output
labels. Unlike the discriminative supervised case, here we will work in a probabilistic setting which is
essential to model the probability of generation of the input. Let Pw(x,y) be a joint probability distribution
over (x,y) parameterized by the parameter w. Let Pw(y|x) refer to the conditional probability of y given
x. For instance, in part-of-speech tagging, x is a sentence, y is the corresponding POS tags, and w could
be generative probabilistic model e.g. Hidden Markov Model. In word-alignment for machine translation
(where given two sentences that are known to be translations of each other, the task is to align which English
words correspond to which French words and vice versa), x can be an English-French sentence pair, y the
word alignment between the sentences, and w can be the probabilistic alignment model. Note that in the
4Some strong conditions are needed for pseudomax [Sontag et al., 2010]
35
previous sections, we were using xj to refer to the jth training example. We will continue to use this notation
when dealing with labeled data in the semi-supervised setting. However, for unlabeled data, we use x to
refer to all the observed input data for simplicity and because we do not need to refer to individual observed
instances.
2.4.2 The Standard Expectation Maximization Algorithm
To obtain the parameter w in an unsupervised way, one maximizes log-likelihood of the observed (unlabeled)
data:
L(w) = logPw(x) = log
∑
y∈Y(x)
Pw(x,y) . (2.38)
For almost all interesting cases (e.g. when Pw is an exponential family distribution), L(w) is non-concave
and in general, it is intractable to maximize it. Thus there is a need for optimization techniques that can
optimize L in at least an approximate sense.
Expectation Maximization (EM) [Dempster et al., 1977] is the most common such technique for maxi-
mizing L(w). EM can be viewed as a variational algorithm that maximizes a tight lower bound on L(w).
In particular, we can introduce a variational distribution q(y) and establish a lower bound on L(w) (this
derivation is used in Neal and Hinton [1998]) as follows:
L(w) = log
∑
y
Pw(x,y) = log
∑
y
Pw(x,y)q(y)
q(y)
≥
∑
y
q(y) log
Pw(x,y)
q(y)
= F (w, q) ,
where the penultimate step follows from Jensen’s inequality. The variational distribution q(y) is defined
over Y(x). q is also called the posterior distribution for reasons which will become clear soon. Using some
algebraic manipulations, we can write F (w, q) as
F (w, q) =
(∑
y
q(y) logPw(x,y)
)
−H(q) (2.39)
= L(w)−KL(q, Pw(y|x)), (2.40)
where H(q) is the entropy of distribution q, and KL(p1, p2) is the KL divergence between two distributions
p1 and p2. Given this formulation, EM can be shown to maximize F via block coordinate ascent alternately
considering q (E-step) and w (M-step) [Neal and Hinton, 1998]. The scheme is discussed in Figure 2.3. EM
is guaranteed to reach a local minima of the function F (w, q) (and also L(w)) under certain conditions [Wu,
1983].
36
Initialize w0
for t = 1, . . . , T or until convergence do:
• E-step: Estimate the distribution q by maximizing the expression in Eq. 2.40 as
qt+1 = arg min
q′∈Q
KL(q′, Pwt(y|x)) , (2.41)
where Q is the space of all distributions over Y(x) (this space will be constrained later in this
section.) It has been shown [Neal and Hinton, 1998] that if Q is unconstrained, then the above step
is optimized by setting q(y) = Pwt(y|x).
• M-step: Estimate the parameters w w.r.t. the distribution q by maximizing the expression in
Eq. (2.39) as
wt+1 = arg max
w′
Eqt+1 log(Pw′(y,x)) . (2.42)
For exponential family distributions, this step is convex and hence can be tractably minimized to a
global minimum.
Figure 2.3: The EM algorithm.
2.4.3 Hard EM
Hard EM is a popular variation of EM is used in several cases in place of EM for multiple reasons. Hard EM
differs from EM only in the E-step: while EM produces a distribution in the E-step, hard EM is thought
of as producing a single output given by y∗ = arg maxy∈Y(x) Pw(y|x). Another way to view the E-step of
hard EM is that it predicts a Kronecker delta function that puts all the probability mass y∗:
q(y) = Iy=y∗ , where y∗ = arg max
y∈Y(x)
Pw(y|x) , (2.43)
where I is an indicator function. In other words, hard EM can also be viewed as a variational approximation
to likelihood maximization except that hard EM restricts itself to the class of Kronecker delta distributions.
The M-step of hard EM is the same as the E-step.
2.4.4 Constraints in EM
As discussed before in Sections 2.1.2 and 2.2, it has become a common practice, especially in the NLP
community, to use constraints on output variables to guide inference. These constraints were discussed and
formalized in Section 2.1.2. As mentioned in Section 2.1.2, we focus on linear constraints over y (potentially
non-linear over x) expressed as
U(x)y ≤ b ,
37
where we have a total of r linear constraints. EM algorithms can benefit to a great extent by the use of
these constraints. In this section, we focus on techniques that impose these constraints on the posterior
probabilities, q, to guide the learning procedure [Chang et al., 2007, Ganchev et al., 2010].
Constraint-Driven Learning (CoDL) [Chang et al., 2007]: CoDL is a constrained counterpart of
hard EM augmenting the hard inference-based E-step with the constraints. In particular, CoDL changes the
E-step of hard EM in Equation 2.43, to
q(y) = Iy=y∗ , where y∗ = arg max
y:U(x)y≤b
Pw(y|x) . (2.44)
Posterior Regularization (PR) [Ganchev et al., 2010]: Constraints on structural variables y can be
relaxed to expectation constraints by requiring the distribution q to satisfy them only in expectation. In
the expectation constraints setting, the constraints in Equation (2.3) can be converted to constraints on q,
which is then required to satisfy:
Eq[Uy] =
∑
y∈Y(x)
q(y)U(x)y ≤ b . (2.45)
Notably above is a relaxation of the original constraint setting (2.3) as U(x)y ≤ b implies the above, but
the same is not true the other way around. With the constraints above, the space of valid distributions Q
can be modified as:
Q = {q | q(y) ≥ 0,
∑
y∈Y(x)
q(y)U(x)y ≤ b,
∑
y∈Y(x)
q(y) = 1}. (2.46)
Notably, Q is a polytope as it is specified as an intersection of a finite number of hyperplanes.
Augmenting these constraints into the E-step of EM gives the Posterior Regularization (PR) frame-
work [Ganchev et al., 2010]. Specifically, PR changes the E-step of EM in Equation (2.41) to
arg min
q′
KL(q′, Pwt(y|x)), s.t. q(y) ≥ 0,
∑
y∈Y(x)
q(y)U(x)y ≤ b,
∑
y∈Y(x)
q(y) = 1. (2.47)
Later in Chapter 4, we will show EM and hard EM as well CoDL and PR can be viewed under a unifying
framework.
38
2.4.5 Discriminative Semi-Supervised Learning with EM
EM-like algorithms can also be used in discriminative semi-supervised learning (SSL) [Bellare et al., 2009,
Ganchev et al., 2010], and is related to self-training. Given some labeled data D = {xj,yj}mj=1 and and
unlabeled data — lets refer to it using only x — such algorithms maximize a modified F (w, q) that combines
regularized conditional likelihood of the labeled data with the unlabeled data as
F (w, q) =
1
m
m∑
j=1
logPw(y
j|xj)− β
2
‖w‖2 − β′KL(q, Pw(y|x)) , (2.48)
where, q, as before, is a variational probability distribution over Y(x) and β and β′ are constants specified
by the user. β is the regularization penalty. The parameter β′ weighs the importance of unlabeled data
w.r.t. labeled data. Note that the KL divergence is measured only over the unlabeled data.
In order to maximize the above objective function, one can again take an EM-like block coordinate ascent
approach:
• E-step: Estimate the distribution q over only the unlabeled data either using hard EM as in Equa-
tion (2.43) or EM as in Equation (2.41). In the presence of constraints, q is estimated as in CoDL
(Equation (2.44)) or as in PR (Equation (2.47)). As such the E-step for semi-supervised EM is really
the same as its unsupervised counterparts.
• M-step: While estimating the parameters w, we now perform the following optimization
wt+1 = arg max
w
1
m
m∑
j=1
logPw(y
j|xj) + β′
∑
y∈Y(x)
q(y) logPw(y|x)−
β
2
‖w‖2 . (2.49)
The M-step above is markedly different from the M-step for unsupervised EM (Equation (2.42)).
For the latter, the M-step involved maximization over the joint distribution over y and x. On the
other hand, the step above amounts to regularized conditional likelihood maximization as is done for
supervised conditional models with the only difference being that we use “soft” pseudo-labels based q
for unlabeled data. Again, for exponential family distributions, this step is convex.
Notably the hard EM version for semi-supervised learning is also known as self-training. In self-training, the
unlabeled data is repeatedly labeled with the learned parameter, which in turn is repeatedly learned using
the assigned labels and the ground truth labels.
39
2.5 Discriminative Latent Variable Structured Prediction
Models
In many structured prediction applications, the input x and the output y are not sufficient to express all
the modeling information. In the machine translation example presented in the previous section, for a given
sentence in English, we are provided its translation in French (and translation is what we really care about),
but we are not provided alignments of words, which is crucial to the model. Lets refer to the missing or
latent variables as h. We never get to observe h during training or testing. Nonetheless, h are crucial to
our model and thus our features are generalized to be defined on all x,y, and h, φ(x,y,h) — something we
alluded to in Section 2.1.1. Also, let H(x) be the space of all latent variables for a given x.
In this section, we will focus on the supervised latent variable setting where we will have training data
for x and y but not for h, and the task will be to learn the weights w for the features. However, first we
briefly describe the motivation and inference for this case.
2.5.1 Motivation and Inference
The relationship between the input variables x and the output variables y may not always be straightforward
enough to be captured as a linear function of a simple set of features φ(x,y). This observation has been
utilized by the neural network community for more than four decades where the assumption is that inputs
and outputs are connected by hidden variables which allow neural networks to be universal approximators
of arbitary prediction functions [Hornik et al., 1989]. The use of hidden variables is however popular even
outside the neural network framework because hidden variables allow for the creation of a more expressive
model. Furthermore, with a small number of hidden variables, different output variables can share critical
information in a tractable fashion. Finally, in many cases, surely for the cases that are of interest to this
thesis, the hidden variables provide an intuitive (sometimes even semantic) interpretation and allow the
model to be explained in a more meaningful way. Some examples of such hidden variables scenarios are
described below.
• Yu and Joachims [2009] model coreference clustering as a latent variable problem in which the link
structure between items remains latent and only the resulting clustering is observed (which is obtained
by taking transitive closure of the latent link structure.) We present a novel model for supervised
clustering in Chapter 5 that takes advantage of this insight.
• Quattoni et al. [2004] focus on object recognition while the number and location of different “parts”
40
in which the items of interest may lie is latent. Kumar et al. [2010] apply a similar idea to object
localization where a “bounding box” in which the object of interest lies, remains latent.
• Petrov and Klein [2008] model supervised constituency parsing of natural language sentences using
missing annotations of internal nodes.
Inference
The task of inference again is to estimate y given x — the latent variables are not of interest in the end.
Inference in such cases has been approached from two directions: marginalizing latent variables or selecting
the most likely latent variables. We give a brief description below. More details are not presented as inference
is not the focus of this thesis and is highly task specific.
Marginalize latent variables This is a more common approach to latent variable modeling in a proba-
bilistic setting [Quattoni et al., 2004, Petrov and Klein, 2008], where in the conditional probability of y and
h, given x, and the conditional probability of y given x are expressed as
Pr(y,h|x; w) = exp(w · φ(x,y,h))∑
h∈H(x),y∈Y(x)
exp(w · φ(x,y,h))
and Pr(y|x; w) =
∑
h∈H(x)
exp(w · φ(x,y,h)))∑
h∈H(x),y∈Y(x)
exp(w · φ(x,y,h))
(2.50)
Given the above expression, y is predicted by marginalizing out the latent variables as
arg max
y∈Y(x)
P (y|x) = arg max
y∈Y(x)
∑
h∈H(x)
exp(w · φ(x,y,h)) . (2.51)
MAP inference over latent variables In this case, both the output and the hidden variable are obtained
by maximizing the scoring function [Yu and Joachims, 2009, Kumar et al., 2010]. That is the score of each
output variable y is based on the highest scoring latent variable associated with y and inference is performed
as
arg max
y∈Y(x)
max
h∈H(x)
w · φ(x,y,h) . (2.52)
In many cases, performing maximization is easier that marginalization in which case this style of inference is
more tractable than marginal inference. In Chapter 5, we will present a model that will unify both of these
styles of inference.
41
2.5.2 Learning in Discriminative Latent Variable Setting
In this section, we formulate learning as an optimization problem and then present techniques for optimizing
the obtained objective function.
Learning Formulation
The two styles of inference in Equations (2.51) and (2.52) lead to two different styles of learning which we
discuss in this section. The first approach is a maximum likelihood technique called Hidden Conditional
Random Fields [Quattoni et al., 2004, 2007] and the second is a maximum margin technique called Latent
Structural SVMs [Yu and Joachims, 2009]. Recall that we are in a supervised discriminative learning setting
and we are given training data {xj,yj}mj=1.
Hidden Conditional Random Fields [Quattoni et al., 2007] (HCRF): In HCRF learning, we max-
imize the sum of log-likelihoods of the training instances assuming the instances are drawn i.i.d. Combining
Equation (2.50) with regularization, we get that HCRFs minimize
β
2
‖w‖2 − 1
m
m∑
j=1
logPr(yj|xj; w)
=
β
2
‖w‖2 + 1
m
m∑
j=1
log
 ∑
h∈H(x),y∈Y(x)
exp(w · φ(x,y,h))
− log
 ∑
h∈H(x)
exp(w · φ(x,yj,h))
 .
(2.53)
Latent Structural Support Vector Machines [Yu and Joachims, 2009] (LSSVM): In LSSVM
learning, we treat maxh∈H(x) w · φ(x,y,h) in Equation (2.52) as the scoring function of y and use the
loss-augmented margin based learning we have been focusing on in this thesis (see Equation (2.29).) In
particular, LSSVMs maximize the following objective function
β
2
‖w‖2 + 1
m
m∑
j=1
(
max
h∈H(x),y∈Y(x)
(
w · φ(x,y,h) + ∆(y,h,yj)
)
− max
h∈H(x)
w · φ(x,yj,h)
)
, (2.54)
where notice that we allow the loss function in the margin ∆(y,h,yj) to depend on both y and h, but
independent of the latent variable corresponding to yj.
Optimization Algorithm
The objective function for all the learning formulations (Equations (2.53), (2.54), and (4.8)) is non-convex.
Thus, in general it is intractable to find global minima of these problems. Quattoni et al. [2007] use a
42
Algorithm 4 Concave Convex Procedure (CCCP) for solving difference of convex functions
1: Input: A function g(w) expressed as g1(w)− g2(w).
2: Output: A local minima of g(w)
3: Initialize: t← 0, w0 ← 0 (or any other way of initializing)
4: repeat
5: g̃2 ← ∂g2(w) |w=wt
6: obtain wt+1 ← arg minw g1(w)− g̃2 ·w
7: t← t+ 1
8: until (g1(w
t)− g2(wt))−
(
g1(w
t+1)− g2(wt+1)
)
<  (desired accuracy)
9: return wt+1
straightforward gradient descent technique for optimization, which does not have convergence guarantees
but performs well in practice. We present below a different technique used for LSSVM optimization by Yu
and Joachims [2009] called the Concave Convex Procedure (CCCP) [Yuille and Rangarajan, 2003] which has
convergence guarantees. We first discuss CCCP as a general optimization technique and then discuss how
it can be applied to latent variable learning.
Concave Convex Programming (CCCP) [Yuille and Rangarajan, 2003] Concave Convex Pro-
gramming is a technique for minimizing difference of convex functions i.e. functions g(w) that can be
expressed as g1(w)− g2(w) where both g1 and g2 are convex functions.
arg min
w
g1(w)− g2(w) (2.55)
The technique proceeds by iteratively replacing g2(w) by a hyper-plane g̃2 ·w that lower bounds g2 and
is equal to g2 at the current value of w. A natural candidate for such a hyper-plane is the gradient (or a
sub-gradient if g2 is non-differentiable) of g2 at the current value of w. Then the following optimization is
solved:
arg min
w
g1(w)− g̃2 ·w , (2.56)
which can be solved exactly and tractably as it is convex (g1 is convex and linear functions are convex.) After
solving this, the next value of w is obtained where the same procedure is repeated. Algorithm 4 shows the
CCCP scheme. CCCP is guaranteed to converge to a local minimum under certain conditions [Sriperumbudur
and Lanckriet, 2009].
CCCP for Latent Variable Learning Note that the latent variable objective functions in Equa-
tions (2.53), (2.54), and (4.8) can all be expressed as difference of two convex functions. Thus we can
apply CCCP to these functions. Consider the optimization problem for HRCRF in Equation (2.53). The
43
gradient of the negative convex term (computed in line 5 of the algorithm) is given by
m∑
j=1
∑
h∈H(x)
Pr(y,h|x; w)φ(x,yj,h) =
m∑
j=1
Ehφ(x,y
j,h) .
The above expectation can be computed using standard combinatorial algorithms. Substituting the above
in the original HCRF learning objective (2.53), we get that the convex problem in line 6 becomes
β
2
‖w‖2 + 1
m
m∑
j=1
 1
β
log
 ∑
h∈H(x),y∈Y(x)
exp
(
β
(
w · φ(x,y,h) + ∆(y,yj,h)
))− (Ehφ(x,yj,h)) ·w
 ,
which is now a convex optimization problem and can be efficiently solved using techniques like L-BFGS.
For the Latent Structural SVM optimization problem (2.54), the gradient of the negative convex term
turns out to be
m∑
j=1
φ(x,yj,hj), where hj = arg max
h∈H(x)
w · φ(x,yj,h) .
Substituting this in the LSSCM objective (2.54), we get
β
2
‖w‖2 + 1
m
m∑
j=1
(
max
h∈H(x),y∈Y(x)
(
w · φ(x,y,h) + ∆(y,h,yj)
))
−
m∑
j=1
w · φ(x,yj,hj) ,
which is also a convex optimization problem. In fact this problem is the same as the structural SVM problem
discussed in Section 2.3.1 if we treat both y and h together as output variables and treat hj as ground truth
(with a minor exception that ∆ is only a function of y,h, and yj which is necessary for maintaining the
property of hinge loss that it is an upper bound on the actual loss [Yu and Joachims, 2009].) Thus, this
optimization problem can be solved using stochastic gradient descent as discussed before in Section 2.3.1.
Overall, CCCP for LSSVMs requires one to perform MAP inference over the latent variables, whereas for
HCRF it requires marginal inference. This aligns with the EM algorithm and its variants we have studied
in Section 2.4. In particular, HCRFs are similar to standard EM and LSSVMs are similar to hard EM.
44
Chapter 3
Efficient Decomposed Structural
Learning
This chapter presents a technique for efficient supervised learning for structured prediction. As discussed in
Sections 2.3.1 and 2.3.2, typical discriminative global learning algorithms (e.g. Collins [2002], Tsochantaridis
et al. [2004]) perform global MAP inference over the entire output space as an intermediate step. Further-
more, global inference, and hence GL, can be slow for models with high-order, expressive relations between
the output variables. The problem lies in the fact that GL algorithms perform exact MAP inference as a
black box which may be an overkill for several problems, making learning slow.
This chapter presents a technique called Decomposed Learning (DeCL) that alleviates this issue by
restricting the MAP inference to a smaller part of the output space. DecL augments the learning process
with some additional domain information about a) the ground truth labels, b) the constraints on the output
space, and c) some prior knowledge on the underlying parameters, which we want to learn. DecL decomposes
the inference into smaller inference procedures over more tractable output spaces and consequently, is much
more efficient than GL.
This chapter will define a novel measure of theoretically judging the quality of approximate learning
algorithms and present some conditions under which DecL is guaranteed to be equivalent to GL under
this measure. Furthermore, Experiments on synthetic as well as real-world settings (where our theoretical
assumptions may not hold) show that DecL, with small-sized and problem-specific decompositions, perform
as well as GL, while being significantly faster.
The techniques we discussed in Section 2.3.3 based on using approximate inference for learning also aim to
alleviate the computational cost associated with GL. However, blackbox approximate inference procedures
suffer from problems we have discussed before (also see Nowozin [2013]) e.g. they introduce bias in the
learning, may fail to separate the data, or may provide misleading gradients. Besides, it is not clear if one
really needs to solve any kind of inference — exact or approximate — completely in order to learn. This was
exemplified by techniques similar to Pseudolikelihood discussed in Section 2.3.3. DecL further extends the
idea of Pseudolikelihood style learning and present a more general formulation in the max margin setting.
The outline of this chapter is as follows. Section 3.1 briefly recapitulates the notation, the problem we
45
are trying to solve and existing techniques. We introduce our approach in Section 3.2 and provide theoretical
results in Section 3.3. We finally present empirical results in Section 3.5.
3.1 The Problem Setting and Existing Techniques
This section briefly recapitulates the problem setting and presents two extreme learning styles for structured
prediction to establish the context for DecL.
3.1.1 Problem Setting
Consider a structured prediction setting where a d-dimensional input x is drawn from the input space X
and the output variable y is, w.l.o.g., a vector of binary labels {y1, . . . , yn} drawn from Y(x) ∈ {0, 1}n. The
reader should note that the binary label assumption is not restrictive as any structured prediction setting
with a finite label space can be reduced to a binary setting. The space Y(x) may be specified by a set of
declarative constraints which can be viewed as a form of specifying some domain knowledge over y.
Inference and the Scoring Function: The labels in y are correlated and so it is advantageous to predict
them simultaneously. As is typical, we express the prediction over all variables in y using a scoring function
f(x,y; w) = w · φ(x,y) as
arg max
y∈Y
f(x,y; w) = arg max
y∈Y
w · φ(x,y), (3.1)
where φ(x,y) ∈ Rd are feature expressed over both x and y, and w ∈ Rd are weight parameters.
We focus on two popular classes of scoring functions f(x,y; w):
• Singleton with constraints: In this case, features decompose over individual yi and thus f(x,y; w)
is a sum of linear classifiers for individual yi:
f(x,y; w) =
n∑
i=1
yiwi · x .
The variables contained in y interact solely via mutual constraints. The region of allowed outputs,
Y(x), is specified by these constraints.
• Pairwise Markov Networks: For a Pairwise Markov Network (PMN), features are defined over a
graph with n nodes and a set of edges given by E, and f is a sum of individual and pairwise potential
46
functions, φ, corresponding to nodes and edges of the graph:
f(x,y; w) =
n∑
i=1
wi · φi(yi,x) +
∑
i,k∈E
wik · φi,k(yi, yk,w) .
Training and Evaluation: The focus of this chapter is on learning the weight parameter, w, from a given
collection of labeled training instances D = (x1,y1), . . . , (xm,ym). As discussed in Chapter 2.1.3, we use a
loss function ∆ : {0, 1}n × {0, 1}n → R≥0 to measure the quality of a learned hypothesis. The is measured
using a loss function, satisfying ∆(y,y) = 0, ∀y.
3.1.2 Structured Prediction: Overview of Previous Learning Techniques
Section 2.3 presented two extreme styles of learning the parameter vector w from the training data D:
Global Learning (GL) and Local Learning (LL).
The GL framework requires global MAP inference as an intermediate step and thus can be slow. LL
ignores difficult to learn structural aspects (typically global constraints) during learning. In LL+I, we inject
the ignored constraints back during test-time inference.
As noted before, while LL has an obvious advantage over GL in terms of training speed, it fails to take
advantage of the structure and may be inconsistent. The following simple artificial example demonstrates
this point.
Illustrative Example 3. Consider a 2-dimensional feature space: (X1, X2). Let there be three binary
output labels: y1, y2, and y3 which are governed by the constraint y1 + y2 + y3 ≤ 2. The ground truth labels
(y∗1 , y
∗
2 , y
∗
3) for features (x1, x2) are generated by using a fixed singleton scoring function using the following
inference:
(y∗1 , y
∗
2 , y
∗
3) = arg max
y:y1+y2+y3≤2
(
y′1x1 + y
′
2
3x1 + 2x2
4
+ y′3
x1 + 2x2
3
)
.
The labeling thus generated for different parts of the feature space is shown in figure 3.1.
Now, under the LL technique, we will learn separate linear classifiers for y1, y2, and y3. In this example,
we ignore the margin and only consider linear separators that can separate the region of 1 from 0. Consider
the classifier learned for y1 by LL, assuming that an infinite number of training examples as well as features
from the entire space are observed. The region where y1 = 1 is denoted by B and it forms an angle of 135
◦
at the origin. Thus y1 is not locally linearly separable and a linear classification algorithm would learn a
classifier which is different from the actual f1 = x1. The same holds for y3.
In other words, LL fails to learn the correct local function even with a large amount of data as it ignores
47
D
(0,0,1)
(1,1,0)
(0,1,1)
(1,0,0)
(0,0,0)
C
BA
Figure 3.1: Labeling, (y1, y2, y3), for the x1, x2 feature space. Dashed lines separate regions with different
labelings. Significance of regions A, B, C, and D is explained in Section 3.1
the constraints i.e. it is inconsistent. Moreover, it is not guaranteed that LL+I alleviates this problem.
Indeed, running a simple simulation for the above example with x1 and x2 picked uniformly at random
from [−1, 1], 100 training instances, 100 test instances, and SVM as the learning algorithm, we obtain the
Hamming accuracies of (0.85,1.0,0.77) and (0.9,1.0,0.82) for LL and LL+I, respectively — far from being
completely accurate.
While this example may seem contrived, another simple and much more common place illustration of
this is multi-class classification where GL techniques [Har-Peled et al., 2003, Crammer and Singer, 2001]
use the constraint that only one label can be selected for an instance. Ignoring this constraint results in a
one-vs-all classifier which may not be able to obtain linear separation even if the labels are pairwise linearly
separable [Har-Peled et al., 2003]. The problem of inconsistency continues even with black box approximate
inference techniques [Wainwright, 2006, Kulesza and Pereira, 2008, Finley and Joachims, 2008]. This is
where Decomposed Learning comes in.
3.2 Decomposed Learning (DecL)
We start with analyzing the reasons for non-separability of y1 in Example 3 and Figure 3.1. In the region
denoted by C, f1 dictates y1 = 1, but the constraints force y1 = 0. In other words, the value of y1 in this
region is determined by the values of y2 and y3 and not by the value of f1. In order to respect the influence
of the constraints while still learning f1 locally, we discard the instances from the region where the value y1
is completely determined by the given y2, y3, and the constraint. This region is D. Discarding this region, we
are left with examples from the regions A and B: A for y1 = 0 and B for y1 = 1. Clearly, A and B are linearly
48
ypredicted 	

	

update(w,xj,yj,ypredicted)	

	

Global Inference 	

ypredicted  = argmaxY w · Á (xj,yj)	

 Weight: w 
Instance: xj y
predicted
	

	

update(w,xj,yj, ypredicted)	

	

Decomposed Inference	

ypredicted= argmaxnbr(yj) w · Á (xj,yj)	

	

Nbrhood of yj: nbr(yj)	

	

 Weight: w 
Instance: xj 
Info (structure, w*)	

Entire space of y: Y(xj)	

Figure 3.2: Figure highlighting the differences between typical GL and DecL. The diagrams on left and right
illustrate the general scheme for GL and DecL, respectively. We show how DecL restricts learning-time
inference by adding more information. During testing, we use exact inference.
separable by the hyperplane x1 = 0 which is exactly the same as f1. Similar analysis can be performed for
y3. Using this approach (that is, learning the fis independently, but discarding the appropriate examples) in
the same simulation setting as above, with constraints imposed during testing, gives (.98, 1.0, .98) Hamming
accuracies. This observation indicates to a more general possibility that it is possible to learn competitive
weight parameters (or recover the underlying weights in our artificial example) by doing limited inference
on a small subset of output variables as long as we condition on the ground truth values of other variables.
Decomposed Learning formalizes this idea.
3.2.1 Learning with Neighborhoods
Key idea: For a training instance (xj,yj) ∈ D, let nbr(yj) ⊆ Y(xj) be a subset of the output space
defining a “neighborhood” around yj, the ground truth. The key idea behind decomposed learning (DecL)
is to learn w by discriminating the supervised label yj from only all y′ ∈ nbr(yj) instead of all y′ ∈ Y(xj).
nbr(yj) can use additional information about the structure (Y(xj)) and parameters which we intend to learn
(w∗) such that it captures the structure of Y(xj), while being much smaller. Figure 3.2 shows the general
scheme for both GL and DecL, showing the similarities and the differences.
Formalization: Let N = {nbr(yj)|j = 1, . . . ,m} be the collection of neighborhoods for all training in-
stances. To pursue the general idea behind our approach, we use a max-margin formulation [Taskar et al.,
2004] for learning over given data D = {(xj,yj)}mj=1. Specifically we minimize a regularized structured
49
hinge-loss DecL(w;D,N) given by
DecL(w;D,N) =
β
2
‖w‖2 + 1
m
m∑
j=1
max
y∈nbr(yj)
(
w · φ(xj,y)−w · φ(xj,yj) + ∆(y,yj)
)
. (3.2)
The above objective function can be minimized the similar set of techniques we used to minimize Equa-
tion (2.29) for structural SVMs Algorithm 5 presents a stochastic subgradient scheme to this effect obtained
by modifying Algorithm 3, where the only difference is that now the maximization is carried out only over
nbr(yj).
Algorithm 5 Algorithm for learning structural SVMs with stochastic sub-gradient descent.
1: Input: Training data, D = {(xj,yj)}mj=1, step sizes ηt, number of iteration T , and regularization penalty
β.
2: w1 ← 0
3: for t = 1 . . . T do
4: j ← Uniform({1, . . . ,m})
5: ŷ ← arg maxy∈nbr(yj)(w · φ(xj,y) + ∆(y,yj))
6: sg ← βw + φ(xj, ŷ)− φ(xj,yj)
7: wt+1 ← wt − ηtsg
8: Optional: wt+1 ← min(1, 1√β‖wt+1‖ )wt+1
9: update ηt to get ηt+1
10: end for
3.2.2 Learning with Decompositions:
The idea of looking at a smaller output space is natural. The key question is how do we create these
neighborhoods so that the resulting learning algorithm is correct or at least gives a good approximation to
GL.
Generating Neighborhoods via Decompositions: To motivate our technique for generating neigh-
borhoods, we use multi-class classification with labels 1, . . . , r as an example.
Illustrative Example 4. This problem can be expressed as a structured prediction problem over r binary
variables y1, . . . , yr such that an instance with label q is represented as a binary vector y obeying the
constraint
∑
i yi = 1 and with yq = 1 i.e. the bit q of y is 1 and other bits are 0. Let such a binary vector
assignment be called y[q]. For a training instance (x,y[q]), GL aims to learn a scoring function which gives
a score less than y[q] to all other valid assignments y[q′] for q 6= q′. Since the outputs are constrained
such that any two outputs y[q] and y[q] differ on just the bit numbers q and q′, this is achieved by merely
comparing assignments to pairs of bits yq and yq′ , ∀q′ 6= q. This is exactly what techniques like multiclass
50
SVM [Crammer and Singer, 2002] and constrained classification [Har-Peled et al., 2003] do1.
Overall, while multi-class classification is indeed a simple case as the space Y(x) contains just r outputs,
we generalize the idea of creating neighborhoods over a large number of variables via smaller and more local
comparisons.
We generate nbr(yj), by fixing a subset of the output variables to their gold labels in yj, while allowing the
rest of them to vary, and repeating the same for different subsets of output variables. We formalize this idea
through what we define as decompositions (hence the term decomposed learning.) We give theoretically
desirable properties of these neighborhoods in Section 3.3.
Definition 2. Given a set of n binary output variables indexed by {1, . . . , n}, a decomposition S ⊆
P({1, . . . , n}) (P denotes the powerset) is a set containing distinct and non-inclusive (possibly overlapping)
subsets of {1, . . . , n}: S = {s1, . . . , sl| ∀i, si ⊆ {1, . . . , n};∀i, k, si 6⊆ sk}.
Before explaining learning with decompositions, we give some definitions.
Definition 3. Given two output instances y,y′ ∈ {0, 1}n, their symmetric difference set, s(y,y′) is the
set indexing the differences between y and y′ i.e. s(y,y′) = {i = 1, . . . , n|yi 6= y′i}.
Also, given a set s ⊆ {1, . . . , n}, let −s = {1, . . . , n} \ s be its compliment. For a set s, let ys ∈ {0, 1}|s|
denote an assignment to the variables indexed by s. Let (ys,y
j
−s) be the output formed by replacing variables
in yj indexed by s by corresponding variables in ys.
Learning: We associate one decomposition Sj with each training instance (xj,yj) and do inference during
learning as follows. Given a gold output variable yj pick a set s ∈ Sj , fix variables in yj−s and look at all
assignments to ys such that (ys,y
j
−s) is feasible (i.e. ∈ Y); select the highest scoring assignment over all
feasible selections of ys and over all s ∈ Sj and return the structure. Given a decomposition Sj for yj, let
the neighborhood thus generated by nbr(yj,Sj) which is given by
nbr(yj,Sj) = {y ∈ Y(xj)|∃s ∈ Sj , s(yj,y) ⊆ s} . (3.3)
Substituting the the above definition of neighborhood in the learning equation, Equation (3.2), we get the
function DecL(w;D,S(D)) given by:
β
2
‖w‖2 + 1
m
m∑
j=1
max
s∈Sj ,ys∈{0,1}|s|:(ys,yj−s)∈Y(xj)
(
w · φ(xj, (ys,yj−s))−w · φ(xj,yj) + ∆
(
(ys,y
j
−s),y
j
))
, (3.4)
1Interestingly, the one-vs-all technique ignores the given constraint (one-vs-all is a kind of LL technique) and may not be
able to obtain linear separation even if the labels are pairwise linearly separable [Har-Peled et al., 2003].
51
Algorithm 6 Subgradient-descent Alg. for DecL
1: Given: training data: D = (xj,yj)mj=1; step sizes ηt
decompositions: S = (S1, . . . ,Sm).
2: w← 0
3: for t = 0 to T do
4: j ← Uniform({1, . . . ,m})
5: ŷ← yj, maxscore← w · φ(xj,yj)
6: for s ∈ Sj do
7: ŷs ← arg maxys∈{0,1}|s|:(ys,yj−s)∈Y
(
w · φ(xj, (ys,yj−s)) + ∆
(
(ys,y
j
−s),y
j
))
8: score← w · φ(xj, (ŷs,yj−s))
9: if score > maxscore then
10: ŷ← (ŷs,yj−s), maxscore← score
11: end if
12: end for
13: sg ← βw + φ(xj, ŷ)− φ(xj,yj)
14: wt+1 ← wt − ηtsg
15: update ηt to get ηt+1
16: end for
where S(D) = (S1, . . . ,Sm) is the collection of all the decompositions for all the training instances. Algo-
rithm 5 can be extended to minimize the above objective function as presented in Algorithm 6. Again one
should note that instead of subgradient descent, one could use other techniques discussed in Chapter 2.3.1.
Enumerating the sets in the decomposition: In practice, decompositions can be guided by domain
knowledge — highly coupled output variables should be put in the same set while somewhat unrelated
variables should be kept separate. The complexity of learning is small if the sizes of the sets considered in
the decomposition are small as shown by the following theorem and as illustrated by Figure 3.3.
Theorem 3.2.1. If all sets inside a decomposition are of size at most k, then the subgradient computation
takes time O((2n)k).
Proof. The decomposition can contain at most
(
n
k
)
sets of size k so total number of sets of size at most k is∑k
l=0 n
l = O(nk). For each set, inference takes at most O(2k) time as in the worst case, we can enumerate
all possible binary outputs for the (atmost) k variables we are maximizing over. Thus the time complexity
is bounded, in a rather loose way, by O(nk × 2k) = O((2n)k).
Let DecL-k be the special case where all subsets of {1, . . . , n} of size k (k ≥ 1) are considered in the
decomposition. For multi-class classification, DecL-2 with ∆ as the Hamming loss is the same as multi-class
SVM [Crammer and Singer, 2002]. A structured perceptron version of Algorithm 6 with DecL-2, β = 0,
and ∆ = 0 (“perceptron loss”) yields the constrained classification approach of Har-Peled et al. [2003] thus
closing our loop on multi-class classification. It is easy to see that DecL-1, i.e. DecL with decomposition
containing singleton sets covering all output labels, is the same as the Pseudomax approach of Sontag et al.
52
y1 
y3 
y6 
y5 
y2 
y4 
00 
01 
10 
11 
00  01  10  11 
000 
001 
010 
011 
100 
101 
110 
111 
y1 
y3 
y6 
y5 
y2 
y4 
000000 
000001 
000010 
000011 
"
64 outputs 16 outputs 
Figure 3.3: A cartoon figure showing the difference in output space explored by GL and a version of DecL.
GL, on the left, explores the entire search space which has size 26 = 64. DecL, on the right, only considers
inference over variables in bounded boxes at a time. Thus the output space DecL explores (also shown in
the figure) is 23 + 22 + 22 = 16, which is much smaller than GL.
[2010]. Also Decl-n is the same as the standard Global Learning of structural SVMs. Section 3.3 will provide
some more examples decompositions for certain cases.
Note that, in Step 5 of Alg. 6, going over all sets in Sj to find arg max can be slow if the number of sets
inside each decomposition is large (e.g. in DecL-k for large k.) To get around this, in practice, we adopt
two ways for speeding up learning.
1. We compute max over a few sets selected uniformly at random from the decomposition. One can
also use more complicated convex optimization techniques which require evaluating the max over just
one set at a time [Gaudioso et al., 2006], but selection at random seems to work very well in the
experiments.
2. For steps 6-12 in Algorithm 6, instead of making a single gradient update after going over all sets in
Sj , we make a gradient update after the arg max computation for each s ∈ Sj . While this admittedly
changes the objective function we optimize in Equation (3.4), this converges rapidly to a good solution
in practice.
3.3 Theoretical Analysis
In this section, we present theoretical results supporting decomposed learning based on some characteriza-
tions of the decompositions. Our theoretical analysis carries a different flavor than standard generalization
bounds. We present theoretical results to show some conditions under which DecL is equivalent to GL,
assuming the data is separable. First, we define the notion of separability, then we present our desired
53
theoretical property, and finally we present theoretical results for singleton and pairwise features functions.
3.3.1 Separating Weights
We present our results assuming that the data is separable with a margin, defined below.
Definition 4 (Margin Separability). A given data D = {(xj,yj)}mj=1 is said to be margin separable if
∃w ∈ Rd, such that ∀j = 1, . . . ,m, w · φ(xj,yj) ≥ w · φ(xj,y) + ∆(yj,y), ∀y ∈ Y(xj).
Our interest is in all parameters w∗ which separate the data. Let W ∗ be the set of all such weights
formally specified as
W ∗ = {w|w · φ(xj,yj) ≥ w · φ(xj,y) + ∆(yj,y), ∀y ∈ Y(xj), ∀j = 1, . . . ,m} ⊆ Rd . (3.5)
Our assumption that the data is separable is stated below.
Assumption 1. W ∗ is non-empty.
Similarly, we can define the set of separable weights for DecL, wherein we seek to separate the ground
truth outputs from all outputs in the given neighborhood. In particular, similar to W ∗, we define the set of
separating weights for DecL, W dec as
W dec = {w|w · φ(xj,yj) ≥ w · φ(xj,y) + ∆(yj,y), ∀y ∈ nbr(yj), ∀j = 1, . . . ,m} ⊆ Rd . (3.6)
Note that both W ∗ and W dec cannot be singleton sets because is a weight w separates the data, then
so does αw for α ≥ 1. In effect, however, this point is vacuous as scaling the weights does not change the
separating hyperplanes.
Also, note that the set of constraints restricting W dec are a subset of the set of constraints restricting
W ∗. Furthermore, W dec and W ∗ are both polytopes that are specified as intersection of closed half spaces
— one for each separation constraint given by (3.5) and (3.6). Thus we have the following trivial but very
useful observations.
Observation 2 (Outer bound). For all decompositions, the set of separating weights for DecL give an
outer-bound on the set of separating weights for GL, i.e. W ∗ ⊆W dec.
Observation 3 (Closed and Convex). W ∗ is an intersection of Thus W ∗ is closed and convex. Similarly,
W dec is closed and convex.
54
3.3.2 Desired Theoretical Property: Exactness
By Observation 2, we have that the set of separating weights for DecL form an outer bound on the set of
separating weights for GL. If this bound is tight, then we have established some sort of equivalence between
DecL and GL. We make this property precise in the definition below and use this to theoretically analyze
DecL for a given set of decompositions.
Definition 5 (Exactness). DecL with a given set of decompositions is said to be exact if W dec = W ∗ for
the given data D.
Exactness is a useful property in practice. To see this, consider a simplified setting where instead
of minimizing regularized loss-based function (as in Equation (2.29) and Equation (3.2)), we minimize a
regularizer, Ω(w), subject to hard margin separation conditions (as in hard margin SVMs) as below
arg minw Ω(w)
s.t. w ∈W ∗ (or w ∈W dec) .
In this case, exactness, i.e. W dec = W ∗, implies that DecL and GL minimize the same regularization function
over two equal, closed, compact, and convex sets. If Ω is strictly convex (e.g. the l2 or l1 norm), then the
above optimization will output the same weight vector for both DecL and GL. This is because a strictly
convex function assumes a unique global minimum over a closed and convex set. Whether this equivalence
property holds for the general regularized loss (i.e. soft margin) case is an open question. Nonetheless,
exactness is a meaningful property to quantify the usefulness of decomposed learning, as our experiments in
Section 3.5 show.
Note that trivially, exactness will hold if for all j = 1, . . . ,m, nbr(yj) = Y(xj). The goal and the key
challenge is really to find small neighborhoods for DecL for which exactness holds.
Main Theorem Due to Observation 2, to show that DecL is exact for some decompositions, we need only
show that for any w′ /∈W ∗, we also have w′ /∈W dec. Here we make use of the Observation 3 — since both
W ∗ and W dec are closed and convex, we need to show this only for w′ immediately outside the boundary of
W ∗ (see the proof in the appendix.) Let B(w, ) = {w′| ‖w′−w‖ ≤ } be a closed ball of radius  centered
around w. Now, we have the following result.
Theorem 3.3.1. DecL is exact if ∀w ∈ W ∗,∃ > 0, such that ∀w′ ∈ B(w, ), ∀(xj,yj) ∈ D the following
condition holds for nbr(yj): if ∃y ∈ Y(xj) that is not separated correctly by w′ (i.e. w′ ·φ(xj,y)+∆(yj,y) >
w′ · φ(xj,yj)) then there exists y′ ∈ nbr(yj) which is also not separately correctly by w′ i.e. w′ · φ(xj,y′) +
55
w’ 
Wdec W* 
W* 
w’ 
w’ 
w’ 
w’ 
w’ 
w’ 
w’ 
w’ 
w’ 
w’ 
Wdec=W* 
 
w’ w’ 
w’ w’ 
w’ w’ w’ w’ 
w’ 
w’ 
w’ 
w’ 
w’ 
w’ 
w’ 
w’ 
Figure 3.4: A cartoon figure demonstrating the statement of Theorem 3.3.1 (on the left) as well as a intuitive
proof sketch to the right. On the left, W dec is an outerbound on W ∗ and the required condition is that any
w′ ∈ Rd not in W ∗ is also not in W dec. The right figure shows how this implies that W dec = W ∗ (the formal
proof is in the appendix.)
∆(yj,y′) > w′ · φ(xj,yj).
Figure 3.4 provides an intuitive explanation of this theorem as well as a rough graphical proof sketch. This
theorem essentially requires that a w′ which does not globally separate examples in D, also does not separate
the decomposed learning examples. We use this theorem to prove exactness for certain decompositions based
on some easy to determine characterizations of a) the structure (Y(xj)), b) the set of correct parameters
(W ∗), and c) the data D. We note that this theorem is very general and applies to any structured prediction
problem (and any ∆.) However, to present further results, we need to make an assumption on the loss
function ∆, specifying the margin. In particular, in our results, we consider a class of loss functions that are
subadditive and, in some cases concave, where subadditivity and concavity are defined below.
Definition 6 (Subadditivity). ∆(y,y′) is said to be subadditive if ∀y,y′,y1,y2 ∈ {0, 1}n, with s(y,y1)∪
s(y,y2) = s(y,y′), we have ∆(y,y′) ≤ ∆(y,y1) + ∆(y,y2).
Definition 7 (Concavity). ∆(y,y′) is said to be concave if ∀y,y′,y′′ ∈ {0, 1}n, with |s(y,y′′)| > |s(y,y′)|,
we have ∆(y,y′′) ≤ |s(y,y
′′)|
|s(y,y′)|∆(y,y
′).
Several common loss functions like Perceptron loss i.e. no margin requirement, Hamming loss, and
zero-one loss are subadditive and concave.
With this assumption, the following corollary is an immediate consequence of Theorem 3.3.1. Roughly,
this corollary requires that the difference between the score of the gold output and that of any other output
is bounded by the sum of score differences between the gold output and that of outputs in the neighborhood.
Corollary 3.3.2. DecL is exact if ∆ is subadditive and ∀w ∈ W ∗,∃ > 0 such that ∀w′ ∈ B(w, ),
∀(xj,yj) ∈ D, ∀y ∈ Y, s(y,yj) can be partitioned into sets s1, . . . , sl (i.e. ∪li=1si = s(y,yj) and si ∩ sk = ∅
56
for all i, k, i 6= k) such that ∀k ∈ {1, . . . , l}, (ysk ,y
j
−sk) ∈ nbr(y
j,Sj) (in other words, ∀sk,∃s ∈ Sj such
that sk ⊆ s) and
w′ · φ(xj,y)−w′ · φ(xj,yj) ≤
l∑
k=1
(
w′ · φ(xj, (ysk ,y
j
−sk)))−w
′ · φ(xj,yj)
)
. (3.7)
Using these general results, we now examine two different classes of scoring functions mentioned in
Sections 2.1.1 and 3.1 i.e. singleton scoring functions (with constraints) and pairwise Markov networks.
3.3.3 Exactness of DecL for Singleton Scoring Functions with Constraints
In this section, we present exactness results for DecL with singleton scoring function f(x,y; w) =
∑n
i=1 yiwi ·
x where the space of allowed outputs is specified by constraints. For instance, Y can be specified by a
collection of l logical constraints: Y = {y ∈ {0, 1}n | Ck(y) = 1, k = 1, . . . , l} where Ck is a logical function
(e.g. OR) over binary variables in y. Y can also be specified by linear constraints over y (as in Section 2.1.2)
as Y = {y ∈ {0, 1}n|U(x)y ≤ b}.
In several practical applications, the constraint structure has some symmetry to it and we can invoke
Corollary 3.3.2 to provide exactness guarantees for decompositions with set sizes independent of the number
of variables. The following corollaries apply to two such cases with set sizes only dependent on the number
of constraints.
Corollary 3.3.3. If the constrained space Y(xj) is specified by k OR constraints, then Decl-(k + 1) is exact
for subadditive ∆.
Note that we are assuming that Y(xj) are specified by k constraints for all xj — this result can be
generalized by considering appropriate value of k for each training example as we are allowed to select
instance-specific decompositions.
Illustrative Example 5. Consider a learning problem with n binary labels y = (y1, . . . , yn). Furthermore,
these variables obey certain constraints that are expressed as k Horn clauses. Specifically, a horn clause is
expressed as
z1 ∧ . . . ∧ zl → zl+1 ,
where each zi is a literal derived from the output variables in y i.e. zi is either equal to or the negation of one
of the variables in y. Horn clauses are a very intuitive way of specifying logical constraints on applications
(e.g. Srikumar and Roth [2011]). Due the Corollary 3.3.3, we get that for k horn clauses, then DecL-(k+ 1)
is exact regardless of the number of variables in each clause. This follows because a Horn clause can be
57
rewritten as an OR constraint — the Horn clause in the equation above can be equivalent expressed as
¬z1 ∨ . . . ∨ ¬zl ∨ zl+1 .
For a general set of singleton functions, we have the following straightforward result for a concave loss
function ∆.
Corollary 3.3.4. DecL is exact if ∆ is concave and the following holds for nbr(yj), ∀(xj,yj) ∈ D, and
∀y ∈ Y. Starting at yj, if we flip the labels in s(yj,y) one-by-one in any order, then we generate at least
one y′ ∈ nbr(yj).
We also note that the results in this section are based on worst-case analyses. In practice, much smaller-
sized decompositions work well for singleton functions because of relatively weaker coupling between the
variables. We show in our experiments in Section 3.5.1, that DecL-2 and DecL-3 perform very well with a
randomly generated set of constraints.
3.3.4 Exactness for Pairwise Markov Networks
While in the last section, we presented exactness results solely based on constraints, in this section, we
present decompositions for binary PMNs using some knowledge about the true parameters W ∗.
Assumption on pairwise potentials: Recall that, for PMNs, f(x,y; w) =
∑n
i=1 wi·φi(yi,x)+
∑
i,k∈E wik·
φi,k(yi, yk,x), where E is the set of edges for the underlying graph. Inference over such functions is NP
hard in general. The score associated with edge (i, j), ψi.k(yi, yk) = wik ·φi,k(yi, yk,x) is called the pairwise
potential function associated with that edge. In many applications, e.g. in computer vision, the pairwise po-
tentials are usually independent of x and plays the role of enforcing local structure between output variables.
In particular, usually the pairwise potentials encourage variables to take the same value (e.g. neighboring
pixels in image segmentation) or to take different values (e.g. sentences in a document summary). The
following definitions formalize this in the context of binary labels.
Definition 8. A pairwise potential function, ψi,k is called submodular if (ψi,k(1, 1) + ψi,k(0, 0))− (ψi,k(1, 0)
+ψi,k(0, 1)) > 0 i.e. it prefers similar labels. It is called supermodular if (ψi,k(1, 1) + ψi,k(0, 0))− (ψi,k(1, 0)
+ψi,k(0, 1)) < 0, in which case it prefers different labels.
We assume that we have some domain knowledge about W ∗. We know that for our PMN, which of the
edges are submodular and which are supermodular for the correct set of weights, stated formally below.
58
Assumption 2. Assume that ∀(i, k) ∈ E,∀xj ∈ D,∀w∗ ∈ W ∗, w∗ · φik(·, ·,xj) is either submodular or
supermodular. also, we know if any given φik is submodular or supermodular.
Such knowledge about pairwise potential functions is often available in practice, especially for submodular
potentials. For instance, in several computer vision tasks, neighboring pixels are more likely to carry the
same label [Besag, 1986, Boykov et al., 1998]; in information extraction tasks, consecutive words are likely
to belong to the same field. We can also approximately determine this information by computing mutual
information over labeled data. It is known that if all the edges have submodular potentials then for binary
PMNs, exact inference (hence GL) can be performed efficiently using graph cuts [Kolmogorov and Zabih,
2004, Szummer et al., 2008]. However, with Assumption 2, we consider a more general scenario with
supermodular potentials as well.
Obtaining Decomposition: With Assumption 2, we present a decomposition, which leads to exactness.
For each instance (x,yj = {yj1, . . . , yjn}), we modify the underlying graph to create a new set of edges,
Ej ⊆ E. Ej is created by removing all those edges (i, k) where the labels in yj “disagree” with the pairwise
potentials i.e. where w∗ ·φik is submodular but the labels yi and yk are different or where the potentials are
supermodular but the labels are the same. More formally, Ej = {(i, k) ∈ E|(ψik is submodular and yji =
yjk) or (ψik is supermodular and y
j
i 6= y
j
k)}. In the resulting graph, let c1, . . . , cl represent the (maximal)
connected components i.e. they are the sets of indices corresponding to each connected components. Let
us consider a decomposition Spair(yj) = {c1, . . . , cl}. Figure 3.5 shows a cartoon demonstrating how this
decomposition is obtained. For this style of decomposition, we have the following theoretical guarantee on
exactness.
Theorem 3.3.5. For PMNs where Assumption 2 is satisfied, DecL with Spair is exact with subadditive ∆.
Note that in this case, we obtained different decompositions for different training instances. Also, note
that with binary submodular potentials, when exact inference with graph cuts is efficient, we can use graph
cut-based inference for each component, thereby making learning even more efficient.
In practice, we find (see Section 3.5.3) that Spair works very well for non-binary PMNs in the presence
of constraints, where our assumptions and hence the theorem about do not hold.
3.4 Comparison with Pseudolikelihood-like Techniques
We discussed a few previously proposed Pseudolikelihood-inspired techniques in Section 2.3.3. Decomposed
learning, in its basic premise is also inspired by Psuedolikelihood and hence is highly related to these
59
sub(Á) sup(Á) 
1 0 
0 
0 
1 
1 
1 0 
0 
0 
1 
1 
X
X
X
) 
1 0 
0 
0 
1 
1 
) 
Figure 3.5: Figure illustrating how instance-specific decompositions that yield exactness can be obtained
for a pairwise Markov network. In the illustrated cartoon graph, it is known prior to learning that green
edges are submodular and magenta edges are supermodular (see Definition 8.) In the given ground truth
labeling (yj), the variables corresponding to red circles have value 1 and the variables with blue circles have
value 0. The middle figure shows how we cut the edges where the ground truth labels disagree with the edge
potentials. The obtained decompositions are connected components in the resulting graph as shown by the
figure on the right.
techniques. However, there are some key distinctions that we will highlight in this section.
Pseudolikelihood [Besag, 1974] is an efficient technique for parameter estimation for probabilistic graphi-
cal models and is known to be consistent (i.e. in the limit of infinite number of samples, the Pseudolikelihood
estimator converges to the true parameters). However, the picture is not so rosy when it comes to finite
sample performance. Liang and Jordan [2008] showed that the Pseudolikelihood estimator has lower sta-
tistical efficiency i.e. its asymptotic variance is higher than maximum likelihood estimator, thus implying
that Pseudolikelihood needs more samples than maximum likelihood to get close to the true estimator. The
same problem continues for Composite Likelihood [Lindsay, 1988], which generalizes Pseudolikelihood to al-
low larger sets in the decomposition but still will have lower statistical efficiency than maximum likelihood.
Stochastic Composite Likelihood [Dillon and Lebanon, 2010] further generalizes to allow for randomly picked
decompositions However, the focus of all of these techniques is on probabilistic parameter estimation with
the aim of providing consistency i.e. asymptotic convergence, whereas the focus of this chapter was on the
finite data setting.
In the max-margin (non-probabilistic) setting, Pseudomax [Sontag et al., 2010] is an extension of Pseu-
dolikelihood and is in fact exactly equivalent to DecL-1. Pseudomax also has asymptotic convergence guar-
antees, albeit under much stronger conditions. These consistency guarantees can be trivially extended to
DecL, provided each variable yi is covered by at least one set in the decomposition for each training example.
However, the finite sample performance of Pseudomax in our experiments (Section 3.5) is much worse than
competing algorithms. It is likely because just as Pseudolikelihood is statistically very inefficient [Liang and
Jordan, 2008], the outerbound (see Observation 2) psuedomax provides on GL parameters is too loose. It is
very easy to see this using a simple multi-class classification example presented before, with the multi-class
60
Criteria Max-lik Psuedo-lik Comp-lik St. Comp-lik Psuedomax DecL
Setting Probabilistic Probabilistic Probabilistic Probabilistic Max-Marg Max-Marg
Asymptotics Consistent Consistent Consistent Consistent Consistent∗ Consistent∗
Finite-Sample Efficient Inefficient Inefficient Inefficient No Guarantee Exact†
Computational Intractable Tractable Tractable‡ Tractable‡ Tractable Tractable‡
Decomposition Fixed Fixed Fixed Random Fixed Instance-based
Table 3.1: Table comparing different techniques related to DecL on various relevant criteria. Max-lik is
maximum likelihood estimation for probabilistic models like conditional random fields [Lafferty et al., 2001].
Pseudo-lik is Pseudolikelihood [Besag, 1974]; Comp-like is composite likelihood [Lindsay, 1988]; St. Comp-
like is stochastic composite likelihood [Dillon and Lebanon, 2010]; Psuedomax [Sontag et al., 2010] and
DecL [Samdani and Roth, 2012] are max-margin techniques. ∗: Consistent under some stronger assumption
mentioned in [Sontag et al., 2010]. †: exact for appropriate decompositions. ‡: tractable for appropriate
sized sets in the decomposition.
constraint
∑n
i=1 yi = 1. Pseudomax will estimate the parameters for one variable, say yi, while keeping the
remaining fixed to their ground truth values. However, due to the multiclass constraint, given the values of
n−1 variables, the value of yi is fixed and thus in principle the set of all possible weights, Rd, can “separate”
the data. Hence in this case, Pseudomax learns nothing as it provides a trivial outer bound on the set of
globally separating weights (as discussed in the beginning of Section 3.2.2, DecL-2, turns out to be exact in
this case.)
DecL on the other hand is a max-margin style technique that is different from all likelihood-based learning
techniques. Furthermore, the focus of this work is on Exactness, which is a novel finite sample property
whereas all the other related techniques focus on asymptotic convergence. In order to achieve exactness,
our formulation allows creation of decompositions based on the labels in the training instances, which is
also novel. While this idea of variable decompositions (that is not picking the same set of conditioned and
conditioning variables for each training instance) is similar to Stochastic Composite Likelihood, in the latter
case, the decompositions have to be random i.e. unlike DecL, they cannot depend on the ground truth
assignments and hence cannot take advantage of specific structure of the ground truth instances like we
did in Section 3.3.4. In fact, making decompositions instance-specific may not be advisable in probabilistic
likelihood based learning as that can introduce bias in the estimator destroying the consistency property.
Table 3.1 summarizes the key properties and distinctions of various methods related to DecL.
3.5 Experiments
This section presents experimental results on real world settings showing that DecL is effective and robust
even when some of the assumptions we made in Section 3.3 do not exactly hold. We show results on synthetic
data as well as two real-world tasks of multi-label classification and information extraction. We perform
61
exact inference using ILP, wherever needed using the Gurobi ILP Solver [Gurobi Optimization, 2013]. We
show that DecL performs favorably relative to GL on these tasks while greatly reducing the training time.
We use appropriate LL approaches as competing baselines. In settings with constraints, we consider another
baseline, LL+I, that uses constraints — which were ignored during learning — for inference during testing.
3.5.1 Experiments on Synthetic Data
We first analyze DecL with simple decompositions — DecL-1 (Pseudomax), DecL-2, and DecL-3 — with
singleton scoring functions in a controlled synthetic setting by measuring the performance and efficiency.
We generate data with 10 binary output variables, y1, . . . , y10, and 20 dimensional features, using randomly
generated scoring function and randomly generated linear constraints as follows.
Dataset generation: Let U [a, b] and N (µ, σ) represent uniform distribution on [a, b] and normal distri-
bution with mean µ and variance σ2, respectively. We sample the features for each training example, X,
from a 20-dimensional uniform random distribution, U [−1, 1]20. The weight parameter corresponding the
the ith label, wi, is also sampled from U [−1, 1]20. The scoring function for the ith label then is wi · x + ti,
where the offset ti is sampled from U [−2, 2]. To generate the constraints, we first generate the number of
constraints choosing uniformly at random from {10, 11, . . . , 100}. Each constraint is given by
∑
uiyi ≤ b,
where ui is sampled from N (0, 1) and b is sampled from N (5, 5). We ensure that the resulting constrained
space Y contains at least 50 outputs by rejecting a set of constraints that do not satisfy this. Finally, for
each instance x, the corresponding y is generated by using inference techniques for singleton functions with
constraints as in Equation 2.7 and thus we know that the data is separable.
Experimental setting: For learning, we use the SVM-Struct package2 to implement our algorithms. Our
LL baseline ignores the constraints during learning thereby reducing it to learning 10 independent binary
classifiers. We test on 200 instances and tune C, the regularization penalty parameter, on 100 validation
instances. Our results are presented over 10 random trials. Figure 3.6a plots the Hamming loss for each
algorithm against the size of the training data. Figure 3.6b shows the training time.
Results: As expected, GL shows the best performance all through the learning curve, but takes a long
time to train. We observe that although LL and LL+C exhibit relatively low error with a small amount of
data, they fail to converge to a near-perfect classifier like GL, with a large amount of data. This is because
they ignore the constraints and hence are not consistent and are likely to have non-zero asymptotic error.
2Available at http://svmlight.joachims.org/svm_struct.html.
62
 0.05
 0.1
 0.15
 0.2
 0.25
 0.3
 0.35
 0  50  100  150  200  250  300
A
v
e
ra
g
e
 H
a
m
m
in
g
 L
o
s
s
No. of Training Examples
LL
LL+I
DecL-1
DecL-2
DecL-3
GL
(a) Average Hamming loss for different learning algorithms.
Note that LL and LL+C are really close. LL+C fails to ob-
tain low error even with a large amount of training data, while
Decomposed Learning algorithms achieve a continuously di-
minishing error.
 0.01
 0.1
 1
 10
 100
 1000
 0  50  100  150  200  250  300
T
ra
in
in
g
 t
im
e
 (
in
 s
e
c
o
n
d
s
)
No. of Training Examples
LL
LL+I
DecL-1
DecL-2
DecL-3
GL
(b) Average training times in seconds for different learning
algorithms plotted on a log scale. Note that LL and LL+C
have the same training time. Decl algorithms are almost 2
orders of magnitued faster than GL.
Figure 3.6: Synthetic data comparisons with varying training sizes. LL: local learning; LL+C: local learning
with constraints during inference; GL: global learning; DecL-1,2,3: decomposed learning (our approach)
with all subsets of sizes 1,2, and 3 respectively.
On the other hand, DecL-2, 3 exhibit performance close to global learning while being almost 2 orders of
magnitude faster. Notably DecL-1 or Pseudomax exhibits very poor performance with a small number of
training examples, but with larger number of examples, it gets closer to the performance of GL. In particular,
DecL-1 is twice as fast as DecL-2 and thrice as fast as DecL-3, but the relative performance difference is
huge.
3.5.2 Multi Label Document Classification
Dataset: We test various algorithms on a multi-label document categorization task over the Reuters
dataset [Lewis et al., 2004]. Some examples of the labels we use are corn, grain, finance, etc. Some of
these labels are highly correlated (e.g. grain and corn) and some are mildly correlated (documents about
commodity prices of corn can also be about finance), and some have no correlation. This is a multi-label
prediction problem where each document can have one or more labels associated with it. In our experiments,
we use one section of the Reuters data with 6,000 instances and reduce it to the 30 most frequent labels (out
of 101 possible labels), following Meshi et al. [2010].
Experimental modeling and details: We model the scoring function for this case as a PMN over a
complete graph over all the labels to capture interactions between all pairs of labels. In our PMN, only the
vertex potentials depend on the features x and the edge potential for each edge is a fixed scalar that does
63
not depend on x. We compare DecL-1, DecL-2, and Decl-3 with GL and a local learning (LL) approach.
The LL approach drops the pairwise components reducing the problem to 30 independent binary classifiers.
Since this problem does not have constraints and there is no trivial way of estimating the pairwise potentials,
we do not have an LL+C baseline here. We again use SVM-Struct for learning the parameters for GL and
DecL, using Gurobi as the ILP engine.
We average over 10 randomized experiments. For each round, we select a random subset of 1200 test
examples, and separate the remaining into 3600 instances for training and 1200 for validation. In order to
evaluate the performance, we use three different measures:
• Per-instance F1 measure is proposed by Godbole and Sarawagi [2004] and also called labelling F-
measure by [Sokolova and Lapalme, 2009]. In this case, for m testing examples, the performance is
measured by 1m
∑
i
2ci
ti+pi
, where ti is the number of correct labels for instance i, pi is the number of
predicted labels, and ci is the number of correct predictions.
• Macro-F1 is an average of individual F1 values for each label
• Zero-one loss, discussed in Section 2.1.3, measures for how many instances we get all the labels correct
(the lower value, the better.)
Results: Table 3.2 presents results with 10-fold cross validation. We see again that GL performs better
than LL indicating that there is advantage in modeling label correlations in this case. However, this im-
provement comes at the cost of 15 times larger training time. Decl-1 or Pseudomax in this converges very
quickly and hence is even faster than LL. However, it severely underperforms giving almost 30 points lower
F1 than other baselines. Both Decl-2 and DecL-3 outperform LL. Interestingly, DecL-2 performs as good
as GL and DecL-3 performs even better than GL (statistically significantly better with a Wilcoxon Signed
Rank Test with p < 0.05). However, both DecL-2 and DecL-3 are faster than GL. Notably, DecL-2 is 6
times faster than GL. Thus, both DecL-2 and DecL-3 seem to be good alternatives to GL, providing almost
the same performance at a fraction of the training time.
3.5.3 Information Extraction: Sequence Tagging with Submodular Potentials
We test the efficacy of our approach on two information extraction tasks related to the example presented in
Section 1.1.1. The task is to identify functional fields by labeling text segments. In particular, we focus on
labeling functional fields like author, title, journal, etc. from a given citation and fields like facilities,
nbrhd, size, etc. from an apartment listing.
64
Table 3.2: Multi-label classification: Average per-instance F1, average macro-F1, and average training times
for the Reuters data. We report total time spent on inference during learning. DecL-3 is statistically
significantly the best performing algorithm outperforming, surprisingly, GL. The differences DecL-2 and GL
are not statistically significant. Also note the small amount of training time for DecL-2 and DecL-3.
LL DecL-1 DecL-2 DecL-3 GL
Average per-instance F1 79.72 53.98 81.52 82.50 81.70
Average Macro-F1 (in % points) 46.50 73.33 40.46 39.40 40.79
Average zero-one Loss (in % points) 66.67 47.27 72.37 72.73 70.00
Training Time (x 1000 seconds) 8.08 5.09 22.86 68.10 126.78
Dataset: For information extractions from citations, we use the CORA citations data [McCallum et al.,
2000], which contains a total of 500 labeled instances. We use 200 instances for testing and a varied number
of the remaining instances for different training settings. For apartment information extraction, we use the
craigslist advertisements data [Grenager et al., 2005] which has a total of 300 labeled instances. We use 200
instances for testing and the remaining for training.
Modeling: Following Grenager et al. [2005] and many works after that, we model this setting as a Hidden
Markov Model with different functional fields as hidden states and words as emissions. Furthermore, we
add certain global constraints borrowed from Chang et al. [2007] to the HMM, and certain local constraints
from Haghighi and Klein [2006]. The global constraints imply that global inference in this task requires
ILP-based techniques. In all our algorithms, instead of maximum-likelihood learning of HMMs, we use
discriminative learning [Collins, 2002] (see Algorithm 3). We use HMM without constraints as an LL
baseline. We obtain an LL+I baseline by adding constraints to the parameters learned by HMM during test
time.
Decomposition: Our decompositions used for this task are inspired by our analysis of PMNs in Sec-
tion 3.3.4. Note that HMM is a special case of PMN — it is defined on a chain graph and has fixed
pairwise potentials (i.e. log transition probabilities.) Furthermore, as pointed out by Grenager et al. [2005]
and Haghighi and Klein [2006], the hidden labels, i.e. the information fields, in this case tend to be “sticky”
i.e. words corresponding to a field, e.g. title, occur in long contiguous blocks. Grenager et al. [2005]
encode this assumption by assuming that the underlying HMM is “diagonal-heavy” that is it exhibits a high
same-state transition probability. The transition probabilities in this case are a multi-class generalization
of the submodular pairwise potentials we described in Definition 8 and are in fact submodular if there are
only two hidden states (i.e. the binary case.) In this case, we use the decomposition style Spair presented in
Section 3.3.4. In particular, given a training instance, this decomposition breaks the chain into contiguous
blocks of same labels. Intuitively, this decomposition enables DecL to capture the “diagonal-heavy” nature
65
size size size size size feat feat feat feat feat
Spacious 1 Bedroom apt . newly remodeled , gated ,
feat feat feat feat feat feat nbrhd nbrhd nbrhd nbrhd
new appliance , new carpet , near public transportation , close
nbrhd nbrhd nbrhd nbrhd rent rent rent rent
to 580 freeway , $ 500.00 Deposit (510)655-0106
Figure 3.7: An example labeling of an actual apartment advertisement from craigslist.
Table 3.3: Performance comparison showing average accuracy (Acc) of LL, LL+I, GL, and DecL. The
LL baseline here is a simple discriminative HMM training without constraints. The LL+I baseline adds
constraints during decision time. We also show average training time (Time) taken for GL and DecL in
minutes. Size indicates the number of training documents.
Training Size LL LL+I GL DecL
Acc Acc Acc Time Acc Time
Citations dataset
5 53.50 67.22 67.83 51.8 67.55 13.8
10 64.18 75.43 74.07 97.6 72.86 25.1
20 66.74 77.00 79.60 478.0 79.26 63.0
25 71.49 81.38 81.44 328.4 81.68 58.7
300 91.21 91.52 94.55 2450.0 94.77 641.2
Ads dataset
5 39.72 53.25 44.86 310 52.24 240.8
10 56.95 65.24 59.10 401.9 59.80 378.29
20 67.78 71.57 69.05 1365.3 69.18 694.37
25 67.74 71.86 70.69 1008 71.84 757.1
100 76.52 78.97 80.0 4527.8 80.3 2252.8
of the HMM transition matrix while allowing it to learn the transitions between different fields.
Illustrative Example 6. Consider a given instance for the craigslist information extraction example that
was presented in Figure 1.1 in Section 1.1.1. We have copied the example in Figure 3.7 for reader’s con-
venience. In this example, the first five tokens have label size, next eleven have label feat, next eight
have label nbrhd, and the next four have label rent. Since the Spair decomposition for this case con-
tains the maximal connected components with the same label, the decomposition Spair in this case is
{{1, . . . , 5}, {6, . . . , 16}, {17, . . . , 24}, {25, . . . , 29}}.
Results: Table 3.3 presents the results for the two domains. The LL+I approach performs very well for
small data sizes because with a less expressive model, LL needs less data to generalize. However, with large
amounts of training data, GL and DecL easily outperform LL and LL+I . DecL does slightly, although not
significantly, better than GL while being 2-8 times faster. Our results compare favorably with the state-of-
the-art supervised results reported on these datasets by Chang et al. [2007] (CRR07.) Overall, we get that
by using very simple knowledge of the task at hand (submodular potentials), we can perform near-global
66
learning while being very efficient. Another lesson learned is that empirical performance of DecL is very
robust as we obtain near GL performance even though the experimental setting is more general than our
theory (we have multi-class PMNs with global constraints while Theorem 3.3.5 is presented solely for binary
potentials with no constraints.)
3.6 Conclusion
This chapter presented Decomposed Learning (DecL) — a technique for efficiently performing supervised
discriminative structural learning in the max-margin setting. DecL learns efficiently by decomposing the
output variables into smaller subsets thereby restricting the inference to a small part of the output space.
We presented theoretical results to show equivalence between DecL and GL. Our results make use of charac-
terizations of the structure, target parameters, and ground truth labels to decompose the output space. Our
experimental results are very encouraging and show that DecL-based algorithms are robust and perform very
well on real world data, where our theoretical assumptions may not hold. In the next chapter, we present
a novel framework for unsupervised learning, and extend the idea of efficient learning by decomposing the
output space.
67
Chapter 4
Unified Expectation Maximization for
Structured Prediction
In this chapter, we will focus on the Expectation Maximization (EM) algorithm [Dempster et al., 1977] for
unsupervised and semi-supervised learning for structured outputs. In particular, we will present a unified
framework that not only incorporates several versions of the EM algorithm present in the literature and
discussed in Section 2.4, but also contains new and useful EM algorithms. Applying the resulting framework
to structured output cases with constraints, we will then present an optimization algorithm that decomposes
learning into tractable components.
4.1 Introduction
EM is inarguably the most widely used algorithm for unsupervised and semi-supervised learning. Many
successful applications of unsupervised and semi-supervised learning in NLP use EM including text classi-
fication [McCallum et al., 1998, Nigam et al., 2000], machine translation [Brown et al., 1993], dependency
parsing [Klein and Manning, 2004]; the list goes on.
Several variations of EM (e.g. hard EM) exist in the literature (presented in Section 2.4) and choosing
a suitable variation is often very task-specific. Some works have shown that for certain tasks, hard EM
(Section 2.4.3) is more suitable than standard EM. For instance, Spitkovsky et al. [2010] show that for unsu-
pervised probabilistic context-free grammar induction, hard EM greatly outperforms standard EM. Merialdo
[1994] reports that when performing unsupervised part-of-speech tagging with a first order Hidden Markov
Model (HMM), EM results in a very flat distribution over all possible tags for each word which is undesirable.
This could potentially be because in the absence of appropriate constraints or priors, learning with EM can
put too much probability mass on meaningless outputs, specifically in the case of model misspecification
(i.e. when the model being fitted is different from the underlying model, which is almost always the case.)
This problem is more conspicuous in structured prediction where due to the massive exponential size of
structured spaces, the probability mass on the unlikely outputs or the tail can sum to a significant amount.
Consequently, the hard EM algorithm sometimes outperforms EM as it is more parsimonious in terms of the
68
set of outputs with non-zero measure considered during the E-step. Also, several EM algorithms have been
proposed recently [Chang et al., 2007, Ganchev et al., 2010, Mann and McCallum, 2010], some discussed
in Section 2.4.4, that incorporate domain knowledge-based constraints to guide EM algorithms. Two such
prominent models are Posterior Regularization (PR) [Ganchev et al., 2010] and Constraint-Driven Learning
(CoDL) [Chang et al., 2007].
However, even in the presence of constraints, the distinction between EM and hard EM continues. In
the presence of constraints, Posterior Regularization (PR) [Ganchev et al., 2010] is the counterpart to EM
while Constraint-Driven Learning (CoDL)1 [Chang et al., 2007] corresponds to hard EM. Overall, with and
without constraints, the problem of choosing between EM and hard EM (or between PR and CoDL) remains
elusive, along with the possibility of simple and better alternatives, to practitioners.
In this chapter, we approach various EM-based techniques from a novel perspective. We believe that
“EM or Hard-EM?” and “PR or CoDL?” are not the right questions to ask. Instead, we present a unified
framework for EM, Unified Expectation Maximization (UEM) [Samdani et al., 2012a,b], that covers many
EM variations including the constrained cases along with a continuum of new ones. UEM allows us to
compare and investigate the properties of EM in a systematic way and helps find better alternatives. In
addition to providing a way to smoothly interpolate between EM and hard EM, UEM also provides a way
to regularize EM by tuning the entropy of the posterior distribution obtained in the E-step of EM.
Our focus in this chapter will largely be on UEM augmented with domain knowledge-based constraints.
Including constraints in UEM is challenging from a computational perspective. To this end, we present a dual
projected subgradient ascent algorithm that decomposes the required optimization into simpler components.
Our optimization algorithms generalizes and unifies several dual decomposition and Lagrange relaxation
algorithms [Bertsekas, 1999] introduced recently in NLP [Ganchev et al., 2008a, Rush and Collins, 2011],
which is another contribution of this chapter in terms of unification of existing techniques.
4.2 Unified Expectation Maximization
We begin by rewriting the optimization formulation for EM. We showed in Section 2.4.2 that EM optimizes
a function F (w, q) given by
F (w, q) =
(∑
y
q(y) logPw(x,y)
)
−H(q)
= L(w)−KL(q, Pw(y|x)),
1To be more precise, [Chang et al., 2007] mentioned using hard constraints as well as soft constraints in EM. In this chapter,
we refer to CoDL only as the EM framework with hard constraints.
69
where L(w) is the likelihood of the observed data given w, H(q) is the entropy of the variational or posterior
distribution q, and KL(p1, p2) is the KL divergence between two distributions p1 and p2. EM can be viewed
as block coordinate ascent on q and w. In particular, the E-step of EM sets q = Pw(y|x). Hard EM, as
presented in Equation (2.43), changes the E-step to q(y) = Iy=y∗ ,where y∗ = arg maxy∈Y(x) Pw(y|x).
We now present the Unified Expectation Maximization (UEM) framework, which captures a continuum
of (constrained and unconstrained) EM algorithms including EM and hard EM by modulating the entropy
of the posterior distribution q obtained in E-step. A key observation underlying the development of UEM is
that hard EM (or CoDL) finds a distribution with zero entropy while EM (or PR) finds a distribution with
the same entropy as Pw (or close to it). This hints at the possibility of producing interesting EM algorithms
by changing the entropy of the posterior q.
In the UEM framework, we explicitly tune the entropy of the posterior during the E-step. Specifically,
we change the objective function for estimating the posterior distribution obtained in the E-step (Equa-
tion (2.41)) as follows:
q = arg min
q′∈Q
∑
y∈H(x)
γq(y) log q(y)− q(y) log p(y) = arg min
q′∈Q
KL(q′, Pw(y|x); γ) , (4.1)
where KL(q, p; γ) is a modified KL divergence, parameterized by γ. In other words, UEM projects Pw(y|x)
on the space of feasible distributions Q w.r.t. KL(·, ·; γ) as the distance function to obtain the posterior q.
By simply varying γ, UEM changes the metric of projection and obtains different variations of EM including
EM (PR, in the presence of constraints) and hard EM (CoDL) as we will soon show.
The UEM Algorithm: While EM optimizes F (w, q) mentioned above and in Equaltion (2.39), UEM
optimizes a modified function F (w, q(y); γ) given by
F (w, q(y); γ) = L(w)−KL(q(y), Pw(y|x); γ) . (4.2)
Similar to EM, UEM also does block coordinate ascent on q and w. Algorithm 7 shows the UEM algorithm
for both the generative and the discriminative semi-supervised learning cases (both first discussed in Sec-
tion 2.4.2.) We refer to the UEM algorithm with parameter γ as UEMγ . Note that the M-step for UEM is
exactly the same as EM (or is the same as discriminative semi-supervised EM for semi-supervised learning.)
We define a function T (w; γ) = maxq∈Q F (w, q; γ). It is easy to see that in the absence of any constraints,
T (w; 1.0) = maxq∈Q F (w, q) = L(w)−minq∈QKL(q(y), Pw(y|x)) = L(w), as the minimum KL-divergence
(= 0) is attained at q = Pw(y|x). In general, we can view T (w; γ) as an entropy-penalized (or incentivized
depending on the value of γ) analog of L(w).
70
Algorithm 7 UEM algorithm for both generative (G) and discriminative (D) cases. We refer to this
algorithm as the method UEM(γ,w0)
Initialize w0
for t = 0, . . . , T or Until Convergence do
UEM E-step:
qt+1 ← arg minq∈QKL(q, Pwt(y|x); γ)
UEM M-step:
Generative: wt+1 = arg maxw Eqt+1 [logPw(x,y)]
Discriminative: wt+1 = arg maxw′
1
m
∑m
j=1 logPw(y
j|xj) + β′
∑
y∈Y(x) q(y) logPw(y|x)−
β
2 ‖w‖
2
end for
return wT+1
It is easy to see that F (w, q; γ) ≤ F (w, q; 1.0) = F (w, q) for γ ≤ 1 as the entropy of a discrete distribution
is always positive. This implies that T (w; γ) is a lower bound on the likelihood L(w) for γ ≤ 1. The following
theorem (analogous to similar theorem for EM) shows that Algorithm 7 cannot decrease the value of T (w; γ).
Theorem 1. After the tth iteration of UEMγ , ∀ γ, T (wt+1; γ) ≥ T (wt; γ).
Proof. T (wt+1; γ) = F (wt+1, qt+2; γ) ≥ F (wt+1, qt+1; γ) ≥ F (wt, qt+1; γ) = T (wt; γ).
4.3 UEM as a Generalization of Existing Algorithms
In this section, we explain the relationship between UEM and several versions of EM algorithms, in both
generative and discriminative domain. The relation between unconstrained versions of EM has been explored
before to some extent [Kearns et al., 1997, Ueda and Nakano, 1998, Hofmann, 2001, Smith and Eisner, 2004].
In some of the annealing literature, γ is called the temperature.
We show that the relationship between EM algorithms takes novel aspects in the presence of constraints.
Recall that in Section 2.4.4, we had expressed the space of allowed distributions Q using constraints in
Equation (2.46). We are going to use the same characterization for the space of posterior distributions q.
In order to better understand different UEM variations, we write the UEM E-step (4.1) explicitly as an
optimization problem:
arg min
q
KL(q, Pw(y|x); γ) (4.3)
s.t. Eq[U(x)y] ≤ b,
q(y) ≥ 0,∀y ∈ Y(x),∑
y∈Y(x) q(y) = 1 .
Note that the above formulation is convex for γ ≥ 0 and hence there is hope for tractably and exactly
71
Framework γ = −∞ γ = 0 γ ∈ (0, 1) γ = 1 γ =∞→ 1
Unconstrained Hard EM Hard EM (NEW)
UEMγ
Standard EM DA EM
Constrained CoDL [Chang
et al., 2007]
(NEW) EM
with LP
(NEW) con-
strained
UEMγ
PR [Ganchev
et al., 2010]
DA EM with Con-
straints [Dhillon et al.,
2012]
Table 4.1: Summary of different UEM algorithms. The entries marked with “(NEW)” have not been
proposed before. Equation (4.3) is the objective function for all the EM frameworks listed in this table.
Note that, in the absence of constraints, γ ∈ (−∞, 0] corresponds to hard EM (Section 4.3.1.) Please see
Section 4.3 for a detailed explanation.
solving the E-Step. We will elaborate further in Section 4.4 on solving the E-step with external constraints.
Below, we discuss both the constrained and the unconstrained cases for UEM and establish connections with
existing EM algorithms. Table 4.1 summarizes different EM algorithms in the UEM family.
4.3.1 UEM Without Constraints
In the absence of any external constraints, the E-step optimization in Eq. 4.3 computes q with only the
simplex constraints:
∑
y∈Y(x) q(y) = 1. For γ > 0, the objective function is strictly convex and we can find
its unique minima by creating the Lagrangian, differentiating and using the Karush-Kuhn-Tucker (KKT)
conditions.
For γ = 0, the objective function in Eq. 4.3 is solving arg minq∈Q
∑
y∈Y(x)−q(y) logPw(y|x) which is
a linear programming (LP) problem. It is known that the polytope resulting from simplex constraints has
only integral vertices because the simplex constraints are totally unimodular [Schrijver, 1986]. This implies
that one of the optimum of Eq. 4.3 for the LP lies at an integral vertex where only one of the outputs y
have a non-zero probability. Overall, using the KKT condition and the unimodularity argument, we get the
following results.
Theorem 4.3.1. In the absence of any constraints, and for γ ≥ 0, the optimum for Equation (4.3) is given
by
q(y) =
 Iy=argmaxy′ Pw(y′|x) if γ = 0Pw(y|x)γ∑
y′ Pw(y
′|x)γ if γ > 0 .
(4.4)
The proof is provided in the appendix. Based on the above result, the following four cases arise:
1. γ = 1 : q(y) = Pw(y|x), which is the same as standard EM.
2. γ = 0 : The E-step sets q(y) = Iy=argmaxy′ Pw(y′|x), which is the same as hard EM (2.43). It has already
been noted in the literature [Kearns et al., 1997, Smith and Eisner, 2004, Hofmann, 2001] that γ = 0
72
results in hard EM. In fact, for γ < 0, UEM stays the same as hard EM because of negative penalty
on the entropy of the posterior q. That is reducing the value of γ below zero will only penalize the
entropy of q which means distributions will low entropy will be preferred — the hard EM distribution
(at γ = 0) already has zero entropy and hence it will continue to be optimum.
3. γ ∈ (0,1) : The range γ ∈ (0, 1) has not been discussed in the literature, to the best of our knowledge.
Overall the range [0, 1] is the focus of this work. In Sec. 4.6, we show that UEMγ yields superior
performance when γ is tuned in the range [0, 1].
4. γ ∈ (1,∞) : The range of γ from ∞ to 1 has been used in deterministic annealing for EM [Rose, 1998,
Ueda and Nakano, 1998, Hofmann, 2001]. However, the focus of deterministic annealing is solely to
solve the standard EM while avoiding local maxima problems. Deterministic annealing is described in
Section 4.3.4 of this chapter.
4.3.2 UEM With Constraints
In this section, we assume that we are given linear expectation constraints: Eq[U(x)y] ≤ b on q that specify
the space of allowed distributions Q (Equation (4.3)). The form of resulting values of q as well as the
optimization involved in this step is discussed in Section 4.4. This section will show how for different values
of γ, we get different interesting variants of constrained EM.
1. γ = 1 : For γ = 1, UEM solves arg minq∈QKL (q, Pw(y|x)) which is the same as Posterior Regulariza-
tion Ganchev et al. [2010] (see Equation (2.47).)
2. γ = −∞ : Note that in Equation (4.3), γ is the coefficient of the negative entropy of the distribution
q. In other words, γ can be interpreted as an incentive to the entropy of q. When γ → −∞, then
there is an infinite penalty on the entropy. In particular, the objective function in Equation (4.3) will
take infinite value for any distribution with a non-zero entropy. Consequently, the minimizer of this
objective function must have entropy zero i.e. it must be a Kronecker delta distribution centered at
some y∗ ∈ Y. In order to find y∗, we can solve Equation (4.3), except now the entropy term vanishes
(as the entropy is zero) and we get
arg min
y
− logPw(y|x) = arg maxy Pw(y|x) (4.5)
s.t. U(x)y ≤ b .
This is the same optimization problem as Constraint-Driven Learning [Chang et al., 2007] (Equa-
73
tion (2.44).) The above problem can be treated a combinatorial maximization problem and can be
solved using inference techniques discussed in Section 2.2) like dynamic programming or ILP.
4.3.3 UEM with γ ∈ [0, 1]
The focus of this chapter and of Samdani et al. [2012a] is largely on values of γ between 0 and 1. There are
several reasons why this range is useful and interesting. First, the E-step (4.3) is non-convex for γ < 0 and
hence computationally expensive. For example CoDL (corresponding to γ = −∞) requires ILP inference.
For γ ≥ 0, (4.3) is a convex optimization problem which can be solved exactly and efficiently. Second, this
range also covers standard EM and PR. Furthermore, in case when we do not have any external constraints,
as discussed in Section 4.3.1, all γ ≤ 0 correspond to hard EM and so it is sufficient to only consider γ = 0
as a representative of the entire range (−∞, 0]. In the presence of constraints, with γ = 0, the E-step (4.3)
is solving the following optimization.
max
q
∑
y∈Y(x) q(y) logPw(y|x) (4.6)
s.t. Eq[Uy] ≤ b,
q(y) ≥ 0,∀y ∈ Y(x),∑
y∈Y(x) q(y) = 1 .
The above is a Linear Programming problem in terms of the posterior probability, q(y). LP relaxations are
known to give tight bounds in practice on corresponding ILP formulations. The above LP in its current
form may not necessarily be easy to solve as it is defined over a large number (precisely Y(x)) of variables.
We will see in Section 4.4 how we can use Lagrange relaxation to solve this step efficiently.
4.3.4 Discussion: The Role of Temperature and Its Use in Previous Works
UEM minimizes the modified KL divergence, KL(·, ·; γ) in the E-step, whereas Standard EM minimizes
regular KL divergence. KL(·, ·; γ) can be related to the standard KL divergence as
KL(q, Pw(y|x); γ) = KL(q, Pw(y|x)) + (1− γ)H(q) .
Since minimizing the KL Divergence in the absence of any constraints has the effect of setting q = Pw, we
can think of the additional term (1− γ)H(q) as an entropy regularizer.
For γ < 1, the regularization term penalizes the entropy of the posterior thus making the distribution
74
Algorithm 8 The Deterministic Annealing algorithm with multiplicative update parameter α, initialization
w0, and initial temperature γ∞
Input: Initial w0; multiplicative update 0 < α < 1; initial and final “temperatures” γ∞ and γ0
γ ← γ∞
repeat
w← UEM(γ,w)
γ ← αγ
until γ is not close to γ0
return w
more peaky and reducing the probability mass on the tail of the distribution. The effect of changing the
entropy of probability distribution is significant, for instance, in structured prediction where the tail can
carry a substantial amount of probability mass as structured output spaces are usually very large. This
notion aligns with the observation of Spitkovsky et al. [2010] who criticize EM for frittering away too much
probability mass on unimportant outputs while showing that hard EM does much better in PCFG parsing.
In particular, they empirically show that when initialized with a “good” set of parameters obtained by
supervised learning, EM drifts away (thus losing accuracy) much farther than hard-EM. In Section 4.5, we
study, in some detail, the interplay between initialization and γ.
Deterministic Annealing
UEM is closely related to the deterministic annealing (DA) technique [Rose, 1998, Ueda and Nakano, 1998,
Hofmann, 2001, Smith and Eisner, 2004, Dhillon et al., 2012]. DA techniques make use of a temperature
parameter to mitigate local minima problems associated with EM (or hard EM.) See Rose [1998] and Ueda
and Nakano [1998] for a detailed and well-written study of deterministic annealing.
DA maximizes the UEM objective function (4.2) for different values of γ, moving from a higher to a
lower value in a deterministic fashion, while feeding the parameter w learned from one round into the next
round. The term temperature for γ indeed comes from the annealing literature.
Deterministic annealing for solving the EM objective function is shown in Algorithm 8. The algorithm
starts with a high temperature (where the posterior distribution is close to uniform) γ∞ and reduces the
temperature until it is close to a pre-decided temperature γ0. In most common cases, when aiming to
solve the EM algorithm, γ0 is 1. At each step, with temperature γ, it minimizes the UEMγ objective
function (4.2), and uses the resulting parameter to initialize the next round.
Hofmann [2001] uses DA for a proposed unsupervised topic-modeling algorithm, PLSA. Smith and
Eisner [2004] use DA for unsupervised POS tagging and grammar induction. Also note that some works
(e.g. Dhillon et al. [2012]) use DA to solve the hard EM wherein they reduce the temperature all the way
close to zero.
75
Note that DA is really focusing on minimizing the objective function corresponding to EM (or hard EM.)
The goal of reducing the temperature γ is solely to achieve a better local minimum. Whereas, UEM, achieves
to minimize an objective function different from EM i.e. F (w, q; γ) (4.2). In some of our experiments, we
will study a version of DA inspired by UEM. In this version, instead of reducing the temperature all the way
to one or zero, we will reduce to a variable temperature γ0 determined using some development data.
Application to Discriminative Structural Learning: A Unifying View of Hidden Variable
CRFs and Latent Structural SVMs:
Similar to our work, Pletscher et al. [2010] (and later Schwing et al. [2012]) present a formulation that
unifies HCRFs and LSSVMs in a single framework. We present a brief review of this work. Recall that in
discriminative latent variable setting, we have a hidden or latent variable h which is crucial to predicting
the output variable y given input x. Furthermore, we have features φ(x,y,h) defined on input, output, and
the hidden variables.
Pletscher et al. [2010] parameterize the joint probability of y and h, given the parameter w using a fixed
temperature parameter γ ≥ 0 as follows2.
Pr(y,h|x; w, γ) =
exp
(
1
γ (w · φ(x,y,h))
)
∑
h∈H(x),y∈Y(x)
exp
(
1
γ (w · φ(x,y,h))
) . (4.7)
Using this formulation, they present the learning problem as minimizing the following objective function:
λ
2
‖w‖2+ 1
m
m∑
j=1
γ log
 ∑
h∈H(x),y∈Y(x)
exp
(
1
γ
(
w · φ(x,y,h) + ∆(y,yj,h)
))
− γ log
 ∑
h∈H(x)
exp
(
1
γ
(
w · φ(x,yj,h)
)) ,
(4.8)
where notably we have included the loss ∆(y,yj,h) in the partition function to bias the conditional distri-
bution to have larger margin for non-ground truth examples.
For γ = 1, the above optimization is essentially the same as the HCRF optimization (2.53) with a minor
difference of inclusion of the loss function. Pletscher et al. [2010] show that as γ → 0, the objective function
in Equation (4.8) approaches the objective function of Latent Structural SVMs in Equation (2.54). Thus
this is a unified framework based on a single parameter that can generalize both HCRF and LSSVM. This
unification is analogous to UEM where LSSVMs are akin to hard EM (both require MAP inference and
2In their work, Pletscher et al. [2010] define everything in terms of the inverse temperature, β = 1/γ.
76
correspond to γ = 0) and HCRFs are similar to regular EM (both require marginal inference and correspond
to γ = 1.)
4.4 UEM with Constraints: Decomposing the Constrained
E-step via Lagrangian Dual
In this section, we discuss how to solve the E-step for UEM in the presence of external constraints. We can
explicitly write down the E-step optimization as
min
q
∑
y∈Y(x)
γq(y) log q(y)− q(y) logPwt(y|x) (4.9)
s.t. Eq[Uy] ≤ b,
q(y) ≥ 0,∀y ∈ Y(x),∑
y∈Y(x) q(y) = 1 .
The above optimization is non-convex for γ < 0; however, for γ = −∞ (CoDL) one can use ILP solvers.
We focus here on solving the E-step for γ ≥ 0 for which it is a convex optimization problem, and use a
Lagrange relaxation algorithm [Bertsekas, 1999].
We solve the E-step (4.3) using a Lagrangian dual-based algorithm which iteratively performs projected
subgradient-ascent on dual variables and restimation of the primal variables. It is also referred to as the
dual gradient method. For problems with a specific structure, in particular when the objective function is
composed of a few easy-to-maximize components, our algorithm becomes a dual decomposition algorithm
for convex optimization. As a limiting case with γ → 0, our algorithm specializes to Lagrange relaxation
and dual decomposition techniques for approximating ILP-based inference, which were recently popularized
in NLP [Rush and Collins, 2011, Rush et al., 2010, Koo et al., 2010]. This helps us establish interesting
connections between existing techniques for ILP inference with constraints [Rush and Collins, 2011] and
convex optimization-based techniques [Ganchev et al., 2008a]. Our algorithm for UEM with constraints that
is as easy to implement as PR or CoDL. In particular, existing code for constrained EM (PR or CoDL) can
be easily extended to run UEM.
4.4.1 Projected Subgradient Ascent
We provide below a high-level and operational view of our algorithm. The technical derivations are presented
in the appendix. We refer to the constrained matrix U(x) as U for notational convenience, and let Ui be
77
the ith row of this matrix. To solve the E-step (4.3), we introduce dual variables λ — λi corresponds to the
ith expectation constraint, Uiy ≤ bi, where bi is the ith element of b.
Primal computation: For γ > 0, the primal variables q can be written using the dual variables λ as
q(y) ∝ Pwt(y|x)
1
γ exp
(
−λ
TUy
γ
)
. (4.10)
For γ = 0, the q above is not well defined and so we take the limit γ → 0 in (4.10) and since lp norm
approaches the max-norm as p→∞, this yields
q(y) = Iy=argmaxy′∈Y(x) Pwt (y′) exp(−λTUy′) . (4.11)
Another way to see this is to write down q explicitly as
q(y) =
Pwt(y|x)
1
γ exp
(
−λ
TUy
γ
)
∑
y′∈Y(x) Pwt(y
′|x)
1
γ exp
(
−λTUy′γ
) =
(Pwt (y|x) exp(−λ
TUy))
1
γ
(Pwt (y
∗|x) exp(−λTUy∗))
1
γ∑
y′∈Y(x)
(Pwt (y
′|x) exp(−λTUy′))
1
γ
(Pwt (y
∗|x) exp(−λTUy∗))
1
γ
,
where y∗ = arg maxy′∈Y(x) Pwt(y
′) exp(−λTUy′). Furthermore, lets assume that y∗ is a unique global
maximum. As γ → 0, (Pwt (y|x) exp(−λ
TUy))
1
γ
(Pwt (y
∗|x) exp(−λTUy∗))
1
γ
→ 0 if y 6= y∗ (due to the unique global maxima assumption.)
This yields the result in Equation (4.11).
We combine both the ideas by setting q(y) during the E-step, given the weight parameter wt obtained
during round t as
q(y) =

Pwt (y)
1
γ exp(−λ
TUy
γ )∑
y′ Pwt (y
′)
1
γ exp(−λTUy′γ )
γ > 0 ,
Iy=argmaxy′∈Y(x) Pwt (y′) exp(−λTUy′) γ = 0 .
(4.12)
Dual computation: Given the primal variables q, we can compute a subgradient w.r.t. the dual variables
λ which is given by
Oλ ∝ Eq[Uy]− b . (4.13)
Using this subgradient, we can perform subgradient ascent on dual variables which may be initialized as all
zeros or dual variables from the last iteration.
Thus to solve the E-step (4.3), we perform projected gradient ascent on λ along the gradient Oλ (4.13)
along with the primal posterior computation (4.12). The dual variables λ are constrained to be positive
(for inequality constraints) and hence if any dual variable becomes negative after a gradient update, it is
78
Algorithm 9 Solving E-step of UEMγ for γ ≥ 0.
1: Input: Distributions Pw, the input features x, and learning rates ηt
2: Output: Posterior distribution q in (4.9)
3: Initialize and normalize q; initialize λ = 0.
4: for t = 0, . . . , R or until convergence do
5: λ← max (λ + ηt (Eq[Uy]− b) , 0)
6: q(y)←

Pwt (y)
1
γ exp(−λ
TUy
γ )∑
y′ Pwt (y
′)
1
γ exp(−λTUy′γ )
γ > 0 ,
Iy=argmaxy′∈Y(x) Pwt (y′) exp(−λTUy′) γ = 0 .
7: update learning rate ηt to get ηt+1
8: end for
projected to 0.
Algorithm 9 shows the overall optimization scheme. Overall, the required optimization (4.3) can be
solved efficiently if the expected value computation in the dual gradient (Eq. (4.13)) w.r.t. the posterior q
can be performed efficiently. In cases where we can enumerate the possible outputs y efficiently, e.g. multi-
class classification, we can compute the posterior probability q explicitly using the dual variables. In cases
where the output space is structured and exponential in size, e.g. word alignment, we can optimize (4.3)
efficiently if the constraints and the model Pw(y|x) decompose over simpler structures in the same way. We
discuss this in a more concrete way in the next section.
4.4.2 Projected Subgradient based Dual Decomposition Algorithm
Often in many problems, specifically in NLP, the constraints are used to correct mistakes made by computa-
tionally tractable, albeit less expressive, models. For example, Ganchev et al. [2008a] introduce “agreement”
constraints that force two first-order HMM word alignment models (word alignment being used for machine
translation) models to agree on their decisions. While E-step with HMM models is tractable, the agree-
ment constraints make the task difficult. Similarly, Koo et al. [2010] force projective and non-projective
dependency parsing models (both individually tractable) to agree with each other (intractable when forced
to agree), thereby making the computational task challenging. In such cases, solving the inference (4.3)
using Lagrangian dual can help us decompose the problem into its “easy” components and handle complex
constraints in the dual space as we show by an example in this section.
Set-up: Suppose we are performing joint learning on two structured output variables y1 and y2, which
are coupled solely via linear constraints. Let the constraints be U1ey
1 = U2ey
2 (agreement constraints) and
U1i y
1 ≤ U2i y2 (inequality constraints) for given matrices U1e ,U2e ,U1i , and U2i . Denote the respective spaces
of these output variables for an input x by Y1(x) and Y2(x). Also, we have individual distributions P 1w1 and
79
Algorithm 10 Projected Subgradient-based Lagrange Relaxation Algorithm that optimizes Eq. (4.14)
1: Input: Two distributions P 1w1 and P
2
w2 , the input features x, and learning rates ηt
2: Output: Output distributions q1 and q2 in (4.14)
3: Define λ =
[
λe
λi
]
and U1 =
[
U1e
U1i
]
and U2 =
[
U2e
U2i
]
4: λ← 0
5: for t = 0, . . . , R or until convergence do
6: q1(y
1)←

P 1w1
(y1)
1
γ exp(−1γ (λ
TU1y1))∑
y′∈Y1(x) P
1
w1
(y′)
1
γ exp(−1γ (λTU1y′))
γ > 0 ,
Iy1=argmaxy′∈Y1(x) P 1w1 (y′) exp(−λTU1y′) γ = 0 .
7: q2(y
2)←

P 2w2
(y2)
1
γ exp( 1γ (λ
TU2y2))∑
y′∈Y2(x) P
2
w2
(y′)
1
γ exp( 1γ (λTU2y′))
γ > 0 ,
Iy2=argmaxy′∈Y2(x) P 2w2 (y′) exp(λTU2y′) γ = 0 .
8: λe ← λe + ηt(−Eq1 [Uey1] + Eq2 [Uey2])
9: λi ← λi + ηt(−Eq1 [Uiy1] + Eq2 [Uiy2])
10: λi ← max(λi, 0) {Projection step}
11: update learning rate ηt to get ηt+1
12: end for
13: return (q1, q2)
P 2w2 on y
1 and y2. For example, P 1w1 and P
2
w2 can be two HMM models (say for word alignment) [Ganchev
et al., 2010, Samdani et al., 2012a] or two parsing models [Koo et al., 2010] constrained to agree with
each other, or they can be logistic regression models to predict entities and relations with relation-type
constraints (discussed in Section 1.1.2) [Samdani et al., 2012a], or multiple views of a learning problem with
partial agreement constraints [Ganchev et al., 2008b].
The E-step (4.3) optimization in this case can be written as
arg min
q1,q2
KL(q1(y
1), P 1w1(y
1|x); γ) +KL(q2(y2), P 2w2(y
2|x); γ) (4.14)
s.t. Eq1 [U
1
ey
1] = Eq2 [U
2
ey
2]
Eq1 [U
1
i y
1] ≤ Eq2 [U2i y2] .
Applying Algorithm 9 to this problem, we get two sets of dual variables: λi for inequality constraints and λe
for equality constraints. The resulting dual decomposition scheme is described in Algorithm 10. Lines 6-7
compute the posterior over each component. Then lines 8 -9 compute the gradient for the dual variables
using the posteriors. Overall, the computations in lines 6-9 are decomposed over each sub-component.
Efficiency: The efficiency of the algorithm depends on the efficiency of computing the posterior and
expected values of linear functions over each subcomponent. In most cases, the posteriors q1 and q2 can be
expressed as distributions in the same model family as P1 and P2 respectively as often the linear term (see
80
lines 6-7) can be augmented into the distributions, as shown below.
Illustrative Example 7. Example with HMMs: Consider the case when constraints decompose linearly
over y and each component is modeled as an HMM with wS as the initial state distribution, wE as emmision
probabilities, and wT as transition probabilities. An instance of this is word alignment over language pair
(S, T ) modeled using an HMM augmented with agreement constraints which constrain alignment probabil-
ities in one direction (Pw1 : from S to T ) to agree with the alignment probabilities in the other direction
(Pw2 : from T to S.) The agreement constraints are linear over the alignments y.
Now, the HMM probability is given by Pw(y|x) ∝ wS(y0)
∏
i wE(xi|yi)wT (yi+1|yi), where xi is the ith
emmision (word or token) and yi is the i
th hidden state. For γ > 0, the resulting q1 can be expressed (see
line 6) as
q1(y
1) ∝
(
wS(y
1
0)
∏
i
wE(xi|y1i )wT (y1i+1|y1i )
) 1
γ
e
∑
i −(λ
TU1)iy
1
i
γ
∝ wS(y10)
1
γ
∏
i
(
wE(xi|y1i )e
−(λTU1)
i
y1i
) 1
γ
wT (y
1
i+1|y1i )
1
γ .
That is the dual variables-based term can be folded into the emission probabilities, wE and the resulting
q1 can be expressed as an HMM by raising wS ,wE , and wT to the power 1/γ and normalizing. Similar
approach can be followed for q2 but with the signs reversed. For γ = 0, q can be computed based on the
most probable output with the dual variables-based term included in the emission probabilities, which can
be done using the Viterbi algorithm.
Given that q1 and q2 can be expressed as distributions in the same model family as P
1 and P 2, we
only need that the models P 1 and P 2 admit an efficient way of computing expectations of linear functions,
required in lines 8 -9. This is again satisfied by a wide range of tractable models like bounded order HMMs,
tree structured MRFs, and so on. For HMMs, these computations can be performed using the forward
backward algorithm.
As a Unifying Algorithmic Framework Notice that for γ = 0, Algorithm 10 is a dual decomposition al-
gorithm for approximately solving a MAP inference problem over both the models with the given constraints
as hard constraints. An interested reader may see Rush et al. [2010] and Koo et al. [2010] for information,
who focus on dual decomposition only with equality constraints. Furthermore, for γ = 1 with agreement
constraints, our algorithm specializes to an earlier proposed technique by Ganchev et al. [2008a], which is a
dual decomposition technique for convex optimization. Thus our algorithm draws novel connection between
81
dual decomposition techniques for convex optimization and dual decomposition based relaxations for ILP
inference.
Furthermore, our general algorithm, Algorithm 9 is a more general technique than dual decomposition.
For γ = 0 (see Equation (4.11)), we are effectively solving a MAP inference like problem. In fact, with γ = 0,
it specializes to a Lagrange relaxation technique for approximately solving hard ILP inference which was
discussed in Section (2.2.2). Moreover, dual-decomposition is just a special case of Lagrangian dual-based
techniques. Hence Algorithm 9 is more broadly applicable.
4.5 Relationship between γ and Initialization for UEM
In this section, we study the relation between the quality of initialization of EM and the temperature
parameter γ. We present experiments to demonstrate how the value of γ and the quality of initialization
may affect the quality of the final learned model. The first experiment is on unsupervised POS tagging over
Penn Treebank and the second experiment, inspired by the first one, is on synthetic data for sequence tagging.
In both the experiments, we systematically vary the quality of initialization and observe the performance
(i.e. accuracy) of the resulting model for different values of γ.
4.5.1 Unsupervised POS Tagging
In order to study the effects of initialization quality on the performance, we conduct experiments on un-
supervised Part-of-Speech (POS) tagging. We use a standard subset of Penn Treebank containing 24,115
tokens [Ravi and Knight, 2009] with the tagging dictionary derived from the entire Penn Treebank. A tag-
ging dictionary gives the set of allowed POS tags for each word, thus reducing the possible number of tags
for each word from the total number of tags (46 for Penn Treebank) to a much smaller number [Smith and
Eisner, 2005].
We run UEM with a first order (bigram) Hidden Markov Model (HMM). The reader should note that Ravi
and Knight [2009] showed that a first order HMM model performs much better than a second order HMM
model on unsupervised POS tagging.
In this experiment, we consider initialization points of varying quality and observe the performance for
γ ∈ [0, 1]. Different initialization points are constructed as follows. We create a “bad” quality initialization
by uniformly spreading the probability mass over all possible tags for each token. We call this the uniform
posterior initialization. With this initialization, our EM model on this dataset obtains 84.9% accuracy on all
tokens and 72.3% accuracy on ambiguous tokens (i.e. words that have more than one possible part-of-speech
82
-0.15
-0.1
-0.05
 0
 0.05
1.0 0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.1 0.0
R
e
la
ti
v
e
 p
e
rf
o
rm
a
n
c
e
 t
o
 E
M
 (
G
a
m
m
a
=
1
)
Gamma
uniform posterior initializer
5 labeled examples initializer
10 labeled examples initializer
20 labeled examples initializer
40 labeled examples initializer
80 labeled examples initializer
Figure 4.1: POS Experiments showing the relation between initial model parameters and γ. We report the
relative performance compared to EM (see Eq. (4.15)). The posterior uniform initialization does not use
any labeled examples. As the number of labeled examples used to create the initial HMM model increases,
the quality of the initial model improves. The results show that the value of the best γ is sensitive to the
initialization point and EM (γ = 1) and hard EM (γ = 0) are often not the best choice.
tags), which is competitive with results reported in Ravi and Knight [2009].
Furthermore, we consider initialization points of better quality, by training a supervised HMM tagger
on hold-out labeled data and use the learned parameters to initialize the unsupervised learning process.
This process is naturally likely to create good quality initialization. We vary the quality of the initialization
points by varying the size of the labeled data over the set {5, 10, 20, 40, 80} — the more the amount of
labeled data, the better the quality of initialization. Those initialization points are then fed into different
UEM algorithms.
Results For a particular γ, we report the performance of UEMγ w.r.t. EM (γ = 1.0) as given by
rel(γ) =
Acc(UEMγ)−Acc(UEMγ=1.0)
Acc(UEMγ=1.0)
(4.15)
where Acc represents the accuracy as evaluated on the ambiguous words [Smith and Eisner, 2004] of the
given data. Note that rel(γ) > 0, iff the performance is better than EM. The results are summarized in
Figure 4.1.
Note that when we use the posterior uniform’ initialization, EM wins by a significant margin. Surprisingly,
with the initialization point constructed with merely 5 or 10 examples, EM is not the best algorithm anymore.
83
The best result for most cases is obtained at γ somewhere between 0 (hard EM) and 1 (EM). Furthermore,
the results not only indicate that a measure of “hardness” of EM i.e. the best value of γ, is closely
related to the quality of the initialization point but also elicit a more fine-grained relationship between
initialization and UEM.
This experiment agrees with Merialdo [1994], which shows that EM performs poorly in the semi-
supervised setting. Spitkovsky et al. [2010] show that hard EM (Viterbi EM) works better than standard
EM when initializing using supervised data. We extend these results and expose the nuances of this issue.
In particular, we show that the optimal performance is achieved for a γ value between 0 and 1, based on the
amount of available labeled data.
4.5.2 Synthetic Data Experiments with Hidden Markov Models
In this section, we study how learning with UEMγ behaves with varying quality of initialization as well as
with model mismatch. In particular, we generate data with a first order HMM with a certain number of
hidden states. During learning, we try to fit to it, an HMM with possibly different number of hidden states.
Furthermore, we vary the quality of the initialization parameters for the learning procedures. We analyze
the results of obtained HMM parameters.
Dataset Generation: Let HMM(θp, θt, θo) refer to a first order HMM distribution with θp as the prior
distribution, θt as the transition matrix, and θo as the emission probabilities. We generate the data with
H∗ = 10 hidden states and O = 200 observed states. We sample the prior distribution over the states
from a Dirichlet distribution with a uniform hyperparameter 1.0. We sample the transmission and emission
probabilities for each hidden state independently from a Dirichlet distribution with uniform hyperparameter
0.2. We choose 0.2 as the hyperparameter as it gives reasonably sparse distributions (which is more practically
relevant), but not too sparse in that the transmissions and emissions do not become deterministic. For each
such randomly generated set of parameters, we generate 500 examples (note that you only get to observe
the emissions and not the hidden states) for training and 500 examples for testing. All the examples are of
length 30.
Modeling during Training and Testing: During learning we fit a first order HMM with H(train)
number of hidden states H (as the true number of hidden states is not known to the experimenter.) In our
experiments we try different values of H(train) : 10, 20, 40, and 50. Furthermore, we initialize the learning
84
for each version of UEMγ by θ
i
p, θ
i
t, θ
i
o, which are given by
θip =
i
8θ
s
p + (1− i8 )θp,
θit =
i
8θ
s
t + (1− i8 )θt,
θio =
i
8θ
s
o + (1− i8 )θo ,
(4.16)
where i is an integer that takes values between 0 and 8, θsp, θ
s
t , and θ
s
o are the “supervised” parameters
obtained from 500 labeled examples, and θp, θt, and θo are randomly generated parameters sampled in
exactly the same way as the ground truth parameters (from Dirichlet distributions with hyperparameters
1.0, 0.2, and 0.2, respectively.) The supervised parameters for HMM are obtained in a standard way using
counting [Rabiner, 1989]. Thus, our initialization parameters are a convex combination of “good” parameters
and random parameters. For i = 0, we have a purely random initialization which is the “bad quality”
initialization, and for i = 8, we have a good initialization which is the initialization with the supervised
parameters. When the number of hidden states for our model, H(train), exceeds the number of actual
hidden states H∗, then we pad the parameters θsp, θ
s
t , and θ
s
o with zeros.
We vary the value of i from 0 to 8, thus going from bad to good initialization. Each value of i dictate
a certain quality of initialization. With this initialization, we run 20 rounds of UEMγ for all γ values in
{0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0}.
Evaluation and Results: We evaluate our models using the generated test data. Let x represent the
observed emission sequence for a test example. Then the ground truth for this example, y∗, is the hidden
variable sequence sampled when generating x from the true underlying parameters. To evaluate our model,
we compare the MAP prediction y made by our learned model parameters (using the Viterbi algorithm)
with y∗. The task of comparing, however, is tricky as the hidden states are not grounded (i.e. we can
permute all the states to get the same quality of labeling.) The issue is further complicated by the possible
mismatch between the number of actual hidden states and the number of predicted hidden states.
To circumvent this, we formulate the problem as a clustering evaluation task. Given the ground truth
labeling y∗ for an emission sequence x, we cluster together all the tokens that have the same underlying
hidden state to generate a ground truth clustering C∗. More formally,
C∗ = {C1, . . . , CH∗},where Ci = {j|y∗j = i} .
Similarly, for a given predicted labeling y based on a UEM model, we can define a corresponding predicted
clustering C. We aggregate these clusterings, C∗ and C, across all the testing examples. We now evaluate
85
the quality of prediction based on the distance or discrepancy between these clusterings C and C∗. In order
to measure the distance, we use an information theoretic metric known as the Variation of Information (VI)
proposed by Meilă [2007]. Briefly, the variation of information for two clusterings C1 = {C11 , . . . , C1n1} and
C2 = {C21 , . . . , C2n2} is defined as
V I(C1, C2) = −
n1∑
i=1
|C1i |
n
log
|C1i |
n
−
n2∑
i′=1
|C2i′ |
n
log
|C2i′ |
n
+ 2
n1∑
i=1
n2∑
i′=1
|C1i ∩ C2i′ |
n
log
|C1i ∩C
2
i′ |
n
|C1i |
n
|C2
i′ |
n
, (4.17)
where n is the total number of underlying items. The first terms in the above definition are entropies of
clustering C1 and C2, and the last term is the negative mutual information between these clusterings. VI
has many desirable properties as shown by Meilă [2007]. Since variation of information is a measure of
discrepancy, the lower the variation of information, the better the quality of clustering predicted by the
model.
The results for H∗ = 10 and H(train) = 10, 20, 40, 50 are show in Figure 4.2 and Figure 4.3. The
first figure shows the variation of information values whereas the second figure shows the values obtains
by subtracting and dividing by the VI for UEM1.0. Figure 4.4 shows results for H
∗ = 20 and H(train) =
20, 40, 80, 100. For each value of i, we conduct 10 random trials (each trial involves generating the data from
a different set of underlying parameters) and report the average performance. We present different graphs
for different amounts of model mismatch (as measure by the value of H(train).) Each graph is plotted
similar to Figure 4.1 with the exception that now lower values on y axis are better. The graphs here are not
as straightforward to interpret as the figure for POS tagging. Following are a few salient observations from
these results.
• With no model mismatch (i.e. H(train) = H∗ = 10), EM (UEM1.0) is almost always the best
performing algorithm regardless of initialization quality. Since EM minimizes the exact KL divergence
during the E-step, it takes advantage of the fact that the conditional distribution and the underlying
distribution are in the same model family.
• Even in the presence of model mismatch, EM is the best performing algorithm with random or bad
quality initialization. This is similar to what we observed for POS tagging in Section 4.5.1 where EM
outperformed all the other algorithms with random initialization. This is likely explained by the fact
that EM predicts a distribution with higher entropy during the E-step than any other UEMγ with
γ < 1, and so it is more likely to move farther away from initial parameters in the parameter space.
Hard EM, or UEM0 on the other hand, “commits” the most to the initial set of parameters and hence
performs the worst with random initialization.
86
1.1
1.3
1.5
1.7
1.9
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=10 and H(train)=10
1.5
2.0
2.5
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=10 and H(train)=40
1.25
1.50
1.75
2.00
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=10 and H(train)=20
1.5
2.0
2.5
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=10 and H(train)=50
Figure 4.2: Figure showing the performance of UEMγ for different γ values, for different initialization
qualities, and for varying model mismatch in terms of the number of hidden states. The data is generated
with H∗ = 10 hidden states. During learning, an HMM model with H(train) = 10, 20, 40, and 50 hidden
states is fit. Each graph corresponds to one particular value of H(train). The x-axis in each graph, similar
to Figure 4.1, has the value of γ decreasing from 1 to 0. The y-axis reports the variation of information (VI.)
Each line in the graph represents initialization with a given value of i as per Equation 4.16 where higher
value of i indicates better initialization.
87
0.0
0.1
0.2
0.3
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=10 and H(train)=10
−0.1
0.0
0.1
0.2
0.3
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=10 and H(train)=40
0.0
0.1
0.2
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=10 and H(train)=20
−0.1
0.0
0.1
0.2
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=10 and H(train)=50
Figure 4.3: Figure showing the normalized performance of UEMγ for different γ values, for different initial-
ization qualities, and for varying model mismatch in terms of the number of hidden states. Normalization
is achieved by centering and dividing w.r.t. the performance of EM (γ = 1) as in (4.15) with Accuracy
replaced by Variation-of-Information (thus lower values are better.)
88
0.00
0.04
0.08
0.12
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=20 and H(train)=20
−0.12
−0.08
−0.04
0.00
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=20 and H(train)=80
−0.050
−0.025
0.000
0.025
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=20 and H(train)=40
−0.10
−0.05
0.00
0.00.20.40.60.80.91.0
(decreasing) value of temperature (gamma)
V
I
value
 of i
0
1
2
3
4
5
6
7
8
HMM Simulations with H*=20 and H(train)=100
Figure 4.4: Figure showing the normalized performance of UEMγ for different γ values, for H
∗ = 20.
Normalization is achieved by centering and dividing w.r.t. the performance of EM (γ = 1.)
89
• With model mismatch and better quality initialization, EM is no longer the best performing algorithm.
For instance with H(train) = 20 and i ≥ 3, UEM with γ = 0.9 and 0.8 performs better than EM.
In many cases, γ = 0 performs better than γ = 1. This admits an explanation that is similar to
Section 4.5.1 that with better quality initialization, it is preferably to select γ < 1.
• In cases when the EM is outperformed by other variants of UEM (mostly UEM0.8 and UEM0.9),
interestingly, the difference is aggravated as the model mismatch increases. That is other variants
of UEM outperform EM by a larger margin as H(train) increases from 20 to 40 to 50. To explain
this, observe that as the number of hidden states in HMM increases, its degree of freedom and hence
amount of entropy achievable also increases. In particular, an HMM model with 50 hidden states
can achieve higher entropy than an HMM model with 40 hidden states, which in turn can achieve
much higher entropy than an HMM model with 10 hidden states. Thus when fitting an HMM model
with H(train) number of hidden states to data generated from an HMM model with H∗ number of
hidden states, where H(train) > H∗, it is likely beneficial to penalize the entropy. For this reason,
entropy penalization by reducing the γ value (see Section 4.3.4) provides larger gains as the the value
of H(train) increases.
There are a few things about these results that we do not have a good explanation for and are open problems.
For instance, it is difficult to explain the observation that for H∗ = 10, the curve for i = 8 (i.e. when we
initialize with true underlying parameters) is relatively flat across all γ values i.e. UEM1.0 has roughly
the same performance as UEM0.0. This is strikingly different from what we observe for POS tagging and
what Spitkovsky et al. [2010] observe for unsupervised grammar learning. This indicates that possibly our
simulations do not completely capture the generative distributions arising in real world applications. This
situation, however, does not continue for H∗ = 20.
4.6 Experiments
Our experiments are designed to explore tuning γ in the UEM framework as a way to obtain gains over PR
and CoDL in the constrained case. We have already presented our results on POS tagging in Section 4.5.1.
In this section we present experimental results on word-alignment and information extraction. In all the
cases we use our unified inference step to implement general UEM and the special cases of existing EM
algorithms. We use the algorithm we presented in Section 4.4.2 to efficiently decompose the obtained E-step
into tractable components. Since both of our constrained problems involve large-scale constrained inference
during the E-step, we use UEM0 (with a Lagrange relaxation based E-step) as a proxy for ILP-based CoDL.
90
As we vary γ over [0, 1], we circumvent much of the debate over EM vs hard EM [Spitkovsky et al., 2010]
by exploring the space of EM algorithms in a “continuous” way.
4.6.1 Semi-Supervised Entity-Relation Extraction
We conduct semi-supervised learning (SSL) experiments on entity and relation type prediction assuming
that we are given mention boundaries. In particular, we are given sentences with labeled entity boundaries
or mentions and our task is to predict the entity types of these mentions and predict the relation between a
pair of mentions. This task was alluded to in Section 1.1.2. We recapitulate the task and the example here.
Consider the following example sentence:
[Frank], who is a native of [Chicago], is a trader at [Morgan Stanley].
In the sentence above, interesting entities or mentions are marked by square brackets. The entity types
of Frank, Chicago, and Morgan Stanley are Person, Location, and Organization, respectively. Also
the relation type between Frank and Chicago is Lives-in and the relation type between Frank and Morgan
Stanley is Works-for.
We borrow the data and the setting from Roth and Yih [2004]. This dataset has 1437 sentences. We
focus on four possible entity types: Person, Organization, Location, Others and five relation types
Lives-in, Killed, Org-based-in, Works-for, Located-in. We consider relations between all within-
sentence pairs of entities. We add a relation type None indicating no relation exists between a given pair
of entities.
Data and setting: We work in a semi-supervised setting and train two log linear models for entity type
and relation type prediction, respectively via UEM for discriminative semi-supervised learning. We choose
to work in a discriminative setting in order to use several informative features, which we borrow from Roth
and Small [2009]. Using these features, we obtain 56% average F1 for relations and 88% average F1 for
entities in a fully supervised setting with an 80-20 split which is competitive with the reported results on
this data Roth and Yih [2004] and Roth and Small [2009]. In our semi-supervised learning set up, we use
20% of the data for testing, a small amount, κ%, as labeled training data, and the remaining as unlabeled
training data. We vary the value of κ to experiment with a varying amount of supervision in our setup. For
all of our experiments, with initialize UEM using the weights obtained by training a classifier on the given
labeled data.
91
q (Located-in; e1, e2) ≤ q (Location; e2) q (Located-in; e1, e2) ≤ q (Location; e2)
q (Org-based-in; e1, e2) ≤ q (Organization; e1) q (Org-based-in; e1, e2) ≤ q (Location; e2)
q (Lives-in; e1, e2) ≤ q (Person; e1) q (Lives-in; e1, e2) ≤ q (Location; e2)
q (Works-for; e1, e2) ≤ q (Person; e1) q (Works-for; e1, e2) ≤ q (Organization; e2)
q (Killed; e1, e2) ≤ q (Person; e1) q (Killed; e1, e2) ≤ q (Person; e2)
Table 4.2: Entity and Relation type constraints on posterior probability.
Constraints We use the following constraints in this experiment.
1. Type constraints: For two entities e1 and e2, the relation type ρ(e1, e2) between them dictates a
particular entity type (or in general, a set of entity types) for both e1 and e2. These type constraints
can be expressed as simple logical rules, which can be converted into linear constraints. E.g. if the
pair (e1, e2) has relation type Located-in then e2 must have entity type Location. This yields a
logical rule:
(ρ(e1, e2) = Located-in)→ (e2 = Loc) ,
which can be converted into a linear constraint on the posterior probability q as
q (Located-in; e1, e2) ≤ q (Location; e2) .
Table 4.2 lists all the constraints used. While on such cases exist in our experiments, in general, these
type constraints can exist in a more relaxed form where each relation, say R, implies that one of the
involved entities, call it e, can have one out of many possible entity types, e1(R), . . . , ek(R). This can
be expressed as the linear constraint:
(ρ = R)→
k∨
i=1
(e = ei(R)) .
The above constraint can also be linearized as
q(ρ = R) ≤
k∑
i=1
q(e = ei(R)) .
2. Expected count constraints: Since most pairs of entities are not related by any of the relations
in the list of relations available in our data, we have a large number of None (> 95%) relations.
Such a large number of None relations can overwhelm semi-supervised learning. Thus to mitigate the
effect of such a large number of None relations and to guide learning in the right direction, we put
92
0.3	  
0.32	  
0.34	  
0.36	  
0.38	  
0.4	  
0.42	  
0.44	  
0.46	  
0.48	  
5	   10	   20	  
Av
g.
	  F
1	  
fo
r	  r
el
a5
on
s	  
%	  of	  labeled	  data	  
Sup.	  Bas.	   PR	   CoDL	   UEM	  
Figure 4.5: Average F1 for relation prediction for varying sizes of labeled data comparing the supervised
baseline, PR, CoDL, and UEM. UEM is statistically significantly better than supervised baseline and PR in
all the cases.
0.3	  
0.35	  
0.4	  
0.45	  
0.5	  
0.55	  
0.6	  
0.65	  
0.7	  
0.75	  
0.8	  
5	   10	   20	  
Av
g.
	  F
1	  
fo
r	  r
el
a6
on
s	  
%	  of	  labeled	  data	  
Sup.	  Bas.	   PR	   CODL	   UEM	  
Figure 4.6: Average F1 for entity prediction for varying sizes of labeled data comparing the supervised
baseline, PR, CoDL, and UEM. EM-based approaches do not outperform the supervised baseline there.
However, notably, for entities, for κ = 10%, UEM outperforms CoDL and PR and for 20%, the supervised
baseline outperforms PR statistically significantly.
93
count constraints which upper bound and lower bound the number of each non-None relation type we
expect to see in the corpus. We enforce these constraints in a softer way by putting expected count
constraints for each relation. In particular, for each non-null relation ρ, we estimate the fraction of ρ
relations in our total training data (labeled + unlabeled) using the fraction of these relations in just
labeled training data and then use these fractions to bound the expected number of these relations we
expect to see across the entire corpus. These constraints are very similar to the label regularization
technique mentioned in Mann and McCallum [2010]. Let Dr be the set of entity pairs as candidate
relations in the entire corpus. For each non-None relation type ρ, we impose the constraints
Lρ ≤
∑
(e1,e2)∈Dr
q(ρ; e1, e2) ≤ Uρ ,
where Lρ and Uρ are lower and upper bound on the expected number of ρ relations in the entire corpus.
We obtain these bounds using the fractional counts of ρ over the labeled data and then perturbing it by
+/- 20% to get upper and lower bounds, and then extending it to the entire training data. Assuming
that the labeled and the unlabeled data are drawn from the same distribution, these bounds will hold
with high probability.
Results We use Algorithm 10 for solving the constrained E-step. We report results averaged over 10
random splits of the data and measure statistical significance using paired t-test with p = 0.05. The results
for relation prediction are shown in Figure 4.6. Recall the fraction of labeled data available to training is
given by κ. For each trial, we split this labeled data into two equal parts, where the second part is used as a
development set to tune the value of γ. For κ = 5%, 10%, and 20%, the average value of gamma is 0.52, 0.6,
and 0.57, respectively; the median values are 0.5, 0.6, and 0.5, respectively. For relation extraction, UEM is
always statistically significantly better than the baseline and PR. The difference between UEM and CoDL
is small which is not very surprising because hard EM approaches like CoDL are known to work very well
for discriminative SSL.
4.6.2 Word Alignment with Agreement Constraints
Statistical word alignment is a well-known structured output application of unsupervised learning and is
a key step towards machine translation from a source language S to a target language T . We experiment
with two language-pairs: English-French and English-Spanish. Consider the following illustration. Given an
English sentence e1, . . . , el and a French sentence f1, . . . , fm that are known be translations of each other,
an (asymmetric) alignment from English to French, ae→f maps each English word ei to a corresponding
94
French word fj . A word is mapped to NULL iff it means it does not align with any French word.
Model: Several models have been proposed for word alignment [Brown et al., 1993, Vogel et al., 1996,
Och and Ney, 2003]. We choose an HMM based sequential model the details of which can be found in Vogel
et al. [1996] and Liang et al. [2006]. Furthermore, we add agreement constraints to this model [Liang et al.,
2008, Ganchev et al., 2008a]. The agreement constraints constrain the alignments in direction (from S to
T ) to agree with the alignments in the other direction (from T to S). For example with English and French,
the constraints enforce that a word from the English side, ei maps to fj from the French side according
to ae→f iff fj maps to ei according to af→e. These constraints are relaxed to expectation constraints in
UEM. Ganchev et al. [2008a] showed significant improvements in alignment error rate (AER) over simple
unconstrained HMM models by introducing agreement constraints over the posterior probabilities of the
alignments.
Datasets: We use Hansards corpus for French-English translation [Och and Ney, 2000] and Europarl
corpus [Koehn, 2002] for Spanish-English translation with EPPS [Lambert et al., 2005] annotation. The
Hansards corpus is extracted from the proceedings of the Canadian parliament, which are recorded both
in English and French. The Europarl corpus is extracted from the proceedings of the European Union
Parliament. We use a small development set of size 50 to tune the model. Note that the amount of labeled
data we use is much smaller than the supervised approaches reported in Taskar et al. [2005] and Moore et al.
[2006] and unsupervised approaches mentioned in Liang et al. [2008] and Ganchev et al. [2008a] and hence
our results are not directly comparable.
Miscellaneous details: For the E-step, we use Algorithm 10 with 5 iterations and pick γ from {0.0, 0.1, . . . ,
1.0}, tuning it over the development set. We also use conduct experiments with deterministic annealing (DA)
EM. For DA experiments, we start with γ∞ = 1.0 and bring it down close to γ0 ≈ 0.0 with a multiplicative
update of 0.75. We present two DA algorithms — DA-0 refers to the final DA model at temperature 0 and
DA-best-γ refers to algorithm that selects the best DA model learned during the annealing procedure based
on the performance on the development set. We find that cooling down only to γ = 0.75 yields the best
result with the DA algorithm. During testing, instead of running HMM models for each direction separately,
we obtain posterior probabilities by performing agreement constraints-based inference as in Algorithm 10.
This results in a posterior probability distribution over all possible alignments. To obtain final alignments,
following Ganchev et al. [2008a] we use minimum Bayes risk decoding: we align all word pairs with posterior
marginal alignment probability above a certain threshold, tuned over the development set.
95
Size EM PR CoDL UEM DA-0 DA-γ EM PR CoDL UEM DA-0 DA-γ
En-Fr Fr-En
10k 23.54 10.63 14.76 9.10 13.60 8.82 19.63 10.71 14.68 9.21 13.08 8.95
50k 18.02 8.30 10.08 7.34 10.54 7.27 16.17 8.40 10.09 7.40 10.11 7.00
100k 16.31 8.16 9.17 7.05 10.04 6.50 15.03 8.09 8.93 6.87 9.91 6.39
En-Es Es-En
10k 33.92 22.24 28.19 20.80 24.86 20.69 31.94 22.00 28.13 20.83 24.41 20.78
50k 25.31 19.84 22.99 18.93 22.13 18.95 24.46 20.08 23.01 18.95 22.18 19.18
100k 24.48 19.49 21.62 18.75 21.17 18.46 23.78 19.70 21.60 18.64 21.05 18.50
Table 4.3: AER (Alignment Error Rate) comparisons for French-English (above) and Spanish-English (be-
low) alignment for various data sizes. For French-English setting, tuned γ for all data-sizes is either 0.5 or
0.6. For Spanish-English, tuned γ for all data-sizes is 0.7. DA-0 refers to deterministic annealing when tem-
perature comes down from 1 all the way to 0. DA-γ is when the best temperature (based on the performance
on the development set) during the annealing procedure is picked.
Results We compare UEM with EM, PR, and CoDL on the basis of Alignment Error Rate (AER) for
different sizes of unlabeled data (See Tab. 4.3.) Alignment Error Rate Och and Ney [2003] is given by
1− |A ∩ S|+ |A ∩ P |
|A|+ |S|
,
where S is the set of ground truth alignments deemed to be sure by annotators, P is set of alignments
deemed to be probably correct by annotators, and A is the set of alignments suggested by the system being
evaluated. UEM consistently outperforms EM, PR, and CoDL with a wide margin. We believe that the
results with UEM are likely to be more dramatic in cases with huge, structured combinatorial spaces like
word alignment because modulating the entropy of the posterior distribution has a significant impact as the
tail of this distribution can carry a huge probability mass.
4.7 Conclusion
In this chapter, we presented UEM which is a unified framework for EM algorithms parameterized by a single
parameter. UEM naturally incorporates constraints on output variables and generalizes existing constrained
and unconstrained EM algorithms like standard and hard EM, PR, and CoDL. We show how to efficiently
solve the E-step for UEM in the presence of constraints by decomposing it into tractable subcomponents
using a Lagrangian dual based method. We empirically showed that selecting an EM version through UEM
using a development set can significantly boost the accuracy. In the next section, we present a model for
discriminative latent variable clustering where we again make use of the temperature parameter γ to consider
a general family of models.
96
Chapter 5
Latent Left-Linking Model for
Clustering
The focus of this section is on supervised discriminative clustering of items like noun phrases in a document,
emails arriving at a server, online documents and so on. We will present a novel structured output prediction
model for clustering these items. Our model works in a streaming setting where it can cluster items as they
arrive which leads to efficient inference and captures the natural ordering of items in many cases. In order
to make learning efficient, we will again take a decomposed learning approach wherein instead of performing
inference over the entire set of items for gradient updates, we will make rapid online SGD updates for each
item.
5.1 Introduction
Clustering of data items is a fundamental problem in machine learning and statistics. Applications that use
clustering are varied and highly ubiquitous like entity linking and disambiguation in NLP, image clustering
in Computer vision, bioinformatics, marketing research, etc. Many of these applications require clustering
of items appearing as a data stream where items arrive one-by-one in a specific order, e.g. network intrusion
detection [Guha et al., 2003], email spam detection [Haider et al., 2007], and thread identification in text
message streams [Shen et al., 2006].
The focus of this chapter is on discriminative supervised clustering where we will have access to some
ground truth clustering of items as training data. Most supervised clustering techniques rely on pairwise
similarities between items to drive a batch or an on-line algorithm. We will take an expressive feature-based
approach to clustering, where the pairwise similarity for item pairs is obtained from a similarity function that
uses features extracted form the item pairs. The similarity function is learned using supervised data. This
is unlike some of the unsupervised clustering techniques like k-means, Gaussian mixture models, Chinese
restaurant process, and even metric learning approaches [Xing et al., 2002] that learn an appropriate metric
for items as the features in our case are defined for pairs of items and not individual items. We will focus
on learning the similarity function and performing clustering for data containing streaming items, which is
97
a challenging task.
We address these challenges by assuming that for an observed item i, information about previous items is
sufficient to cluster i and update our model. This is a plausible assumption in many clustering applications,
especially when the items follow a streaming order. We present a novel discriminative model for clustering
streaming items, which we call the Latent Left-Linking Model (L3M). L3M is a feature-based probabilistic
structured prediction model in which each item can link to a previous item with a certain probability, creating
a left-link. L3M expresses the probability of an item connecting to a previously formed cluster as the sum of
the probabilities of multiple left-links connecting that item to the items inside that cluster. L3M admits an
efficient and straightforward inference (or clustering) procedure. For learning in L3M, we present a latent
variable framework, which we optimize using a fast stochastic gradient technique in an online fashion.
Following the theme of Chapter 4, we use temperature γ in L3M, which leads to significant flexibility
in terms of the modeling the contribution of different left-links towards the probability of connecting an
item to a cluster. Using this parameter [Pletscher et al., 2010, Schwing et al., 2012], our learning procedure
generalizes hidden variable conditional random fields [Quattoni et al., 2007] and latent structural support
vector machines [Yu and Joachims, 2009] which were presented in Section 2.5.2. However, notably, unlike
previous works which restrict the use of temperature to latent variable learning [Pletscher et al., 2010,
Schwing et al., 2012], we also use this parameter during inference.
We present experiments on coreference resolution and document clustering. Coreference resolution (dis-
cussed in Section 1.1.3) is a popular and challenging Natural Language Processing (NLP) task, which entails
clustering noun phrases in a document where two noun phrases are co-clustered if and only if they refer to
the same entity. We consider document clustering from two different views: clustering documents based on
authors and clustering documents based on topics. In the former case, the task is to cluster a collection
of textual items (like emails or blog posts) where two textual items are co-clustered if and only if they are
written by the same author. In the latter case, documents are clustered if they belong to the same topic.
We compare L3M to supervised clustering techniques that can be applied in a streaming setting [Haider
et al., 2007, Bengtson and Roth, 2008] as well as non-streaming clustering techniques that need to consider all
the items together [Mccallum and Wellner, 2003, Finley and Joachims, 2005, Yu and Joachims, 2009]. L3M
outperforms all the competing baselines. Interestingly, it outperforms non-streaming clustering techniques,
which are also computationally slower (e.g. correlational clustering is NP hard [Bansal et al., 2002].) This
hints that clustering tasks where the items follow a natural order (e.g. noun phrases in a document) are
better modeled as a data stream even in the finite item setting (notably, in a pure streaming setting the
number of items is potentially infinite.)
98
5.2 Notations and Pairwise Classifier
Notation: For a data stream d, let md denote the number of items
1 in d, e.g. in coreference, d is a document
and md is the number of noun phrases in d. We refer to items using their indices, which range from 1 to md.
We represent a cluster c of items as a subset of {1, . . . ,md}. A clustering C for a data stream d partitions the
set of all items, {1, . . . ,md}, into disjoint clusters. For notational convenience, we represent C as a binary
function with C(i, j) = 1 if items i and j are co-clustered in C, otherwise 0. So far in this thesis, we have
referred to the input as x and the output as y. In this chapter, we will however depart from this notation
and use the more intuitive notation we have introduced above where the set of items in d (along with their
features) form the input, and the clustering C is the output.
Pairwise classifier: We use a pairwise scoring function indicating the compatibility or similarity of a
pair of items as the basic building block for clustering. In particular, for any two items i and j, we produce
a pairwise compatibility score wij using features extracted from i and j, φ(i, j), as
wij = w · φ(i, j) , (5.1)
where w is a weight vector to be estimated during learning. The feature-set consists of different features
indicative of the compatibility of items i and j. E.g. in author-based document clustering, these features
could be the cosine similarity of the document pair, the distance between items i and j in the data stream
(i.e. |i − j|), the set of commons words, etc. The pairwise approach is very popular for discriminative
supervised clustering tasks like coreference resolution and email spam clustering [Mccallum and Wellner,
2003, Finley and Joachims, 2005, Haider et al., 2007, Bengtson and Roth, 2008, Yu and Joachims, 2009, Ng,
2010].
5.3 Probabilistic Latent Left-linking Model
For a given document d and items 1, 2, . . . ,md, the task is to cluster these items. The items in some
applications arrive one-by-one in a streaming ordering. In many applications, the items are not streaming
i.e. we have access to all the items at once but the items still follow an order e.g. noun phrase mentions in
documents can be assumed to follow a natural left-to-right order (assuming a language that flows left-to-
right.) Regardless of the ordering between items, we can consider items one-by-one for efficiency reasons.
Our model, which we call the Latent Left-Linking Model (L3M), clusters items in precisely this fashion and
1We use md as the number items only for notational convenience and because some applications like coreference have a
finite number of items. As such md can be unbounded, and our algorithms will still apply.
99
[Former Governor of Arkansas]1, [Bill Clinton]
a
1 , who was recently elected as the [President of the U.S.A.]
b
1, has
been invited by the [Russian President]c2, [Vladimir Putin]2, to visit [Russia]3. [President Clinton]
d
1 said that [he]1
looks forward to strengthening the relations between [Washington]4 and [Moscow]5.
Figure 5.1: Example of coreference clustering. Mentions with the same subscript (or redundantly, the same
color) are coreferent (our system needs to predict this.)
we describe it in this section.
Motivation
L3M considers items one-by-one in a left-to-right order. The idea of Latent Left-Linking Model is inspired
by what we call the Best-Left-Link approach. In the Best-Left-Link strategy, each item i is connected to the
best antecedent (i.e. previously seen) item j with j < i (i.e. j occurs before i.) The “best” antecedent item
is the one with the highest pairwise score wij ; furthermore, if wij is below some threshold, say 0, then i is
not connected to any antecedent item. The final clustering is a transitive closure of these “best” links.
This approach has been empirically successful for coreference clustering [Soon et al., 2001, Ng and Cardie,
2002, Bengtson and Roth, 2008], where the intuition for this strategy is placed in how humans read and
decipher coreference links (assuming a left-to-right reading order.) However, for a given clustering, we do
not know the true best antecedent nor that a machine learning system based on pairwise classifier can make
the right decision by looking at just one best item. To see this, lets consider the example for coreference
clustering presented in Figure 5.1.
Illustrative Example 8. Let us say that we are trying to resolve the membership of mention d (‘President
Clinton’) and that all the previous mentions have been correctly clustered. It is possible that the Best-Left-
Link strategy might prefer to link mention d to mention c (which is incorrect) over mentions a and b (which
are correct) as all the mentions a, b, and c have similar lexical overlap with mention d, but c is more closely
placed in the document (we observe in our experiments that the distance feature does indeed get a very high
weight.) This will naturally be a mistake. However, by looking at two links — from d to both a and from
b to a — and combining the scores of these links, it is possible for a pairwise classifier-based system to rule
out the link from d to c. The crux of this example is that looking at the best-links may not be sufficient to
cluster items correctly and we need a more expressive model.
We formalize and generalize this idea to present our novel model, L3M. First we will describe our
modeling assumptions that lead to a probabilistic model, then we will discuss the clustering (or inference)
algorithms, we will elaborate on the underlying latent variables in our model, and finally we will present
learning algorithms for this model.
100
5.3.1 Clustering with Latent Left-Linking Model
The items arrive in the order 1, . . . ,md, where we assume a left-to-right streaming order. In order to simplify
the notation, we introduce a dummy item with index 0, which is to the left (i.e. appears before) all the items
and has φ(i, 0) = ∅, and consequently, wi0 = w · φ(i, 0) = 0 for all actual items i > 0. For a given clustering
C, an item i links to item 0 if it is not co-clustered with any previous actual item j, 0 < j < i, and thus we
assume C(i, 0) = 1 for notational convenience. In other words, C(i, 0) = 1 iff i is the first actual item of a
cluster in C. However, such an item i is not considered to be co-clustered with 0 as that would incorrectly
imply, by transitivity, that all the items (1, . . . ,md) are co-clustered. In particular, for any valid clustering,
item 0 is always in a singleton dummy cluster, which is eventually discarded.
Model Specification:
L3M is specified by three simple modeling assumptions on the links between items:
1. Left-linking: Each item can only link to an antecedent item on its left (i.e. occurring before it),
thereby creating a left-link, j ← i.
… …
i 
X
j 
Figure 5.2: Figure showing the first modeling assumption in L3M.
2. Independence of left-links: The event that an item i has a left-link to an antecedent item j is
independent of the event that any item i′, i′ 6= i, has a left-link to some item j′.
… ……
i i’ 
? 
j j’ 
Figure 5.3: Figure showing the second modeling assumption in L3M.
3. Probabilistic left link: For a data stream d, the probability of an item i ≥ 1 linking to an item j to
101
its left (0 ≤ j < i), P (j ← i;w), is given by
Pr[j ← i; d,w] =
exp
(
1
γ (w · φ(i, j))
)
∑
0≤k<i exp
(
1
γ (w · φ(i, k))
) = exp
(
1
γ (w · φ(i, j))
)
Zi(d,w, γ)
, (5.2)
where Zi(d,w, γ) =
∑
0≤k<i exp(
w·φ(i,k)
γ ) is the normalization and γ ∈ (0, 1] is the inverse temperature
also used in Chapter 4, and can be tuned.
In previous works on discriminative latent variable learning [Pletscher et al., 2010, Schwing et al.,
… …
i 
exp (w · Á(1, j)/°) 
j 
Figure 5.4: Figure showing the third modeling assumption in L3M.
2012], use of temperature in discriminative models has been restricted to variance or entropy reduction
in learning. We, on the other hand, extend it to explicitly create a general probabilistic model, which
leads to a very general and flexible inference (or clustering) algorithm.
Note that the left-links remain latent as the final clustering, and not the left-links, is observed during training
and is also the output variable of interest. In Section 5.3.2, we elaborate on the actual underlying latent
structure for L3M.
Also, note that our modeling assumptions have an obvious similarity to the Distance Dependent Chinese
Restaurant Process (CRP) model for generative clustering [Blei and Frazier, 2011]. However, L3M, to the
best of our knowledge, is the first supervised discriminative model to exploit a similar idea and generalize it
to the use of arbitrary pairwise features with learned weights.
Clustering (or Inference) in the Latent Left-Linking Model
We now describe the algorithm for clustering items in a given data stream, given w. Since each item links
only to antecedent items (Assumption 1) and left-links for different items are independent (Assumption 2),
the clustering decision for an item depends only on its antecedent items. This implies that we can cluster
the items in a greedy left-to-right streaming order, where each item either joins an existing cluster or starts
a new cluster. The probability that item i joins the cluster c, Pr[c  i; d,w], is simply the sum of the
102
probabilities of i linking to the items inside c:
Pr[c i; d,w] =
∑
j∈c,0≤j<i
Pr[j ← i; d,w] =
∑
j∈c,0≤j<i
exp
(
1
γ (w · φ(i, j))
)
Zi(d,w, γ)
. (5.3)
The case of γ = 0: Noting that lp norm approaches the max norm as p→∞, as γ approaches zero, the
probability P [j ← i; d,w] in Equation (5.2) approaches a Kronecker delta function that puts probability 1
on the max-scoring item (assuming no ties) j = arg max0≤k<i w · φ(i, j), and 0 everywhere else [Pletscher
et al., 2010, Samdani et al., 2012a,b]. This is similar to our observation in Chapter 4 where UEM yields
hard EM as γ → 0. Consequently, as γ → 0, Pr[c i; d,w] in Eq. 5.3 approaches a Kronecker delta function
centered on the cluster containing the max-scoring item. Thus, for the rest of the chapter, we abuse the
notation and use the expressions in Equations (5.2) and (5.3) for all γ ∈ [0, 1], where for γ = 0, they are
assumed to be replaced by the appropriate Kronecker delta distributions.
Clustering Algorithm Based on Eq. (5.3), we use a simple greedy clustering algorithm: sequentially add
each item i to a previously formed cluster arg maxc Pr[c  i; d,w]. If the ‘arg max’ cluster is the singleton
cluster with the dummy item 0 (with unnormalized log-probability score 0), then i starts a new cluster
and is not included in the dummy cluster. Algorithm 11 formally presents this algorithm. Note that in
Algorithm 11, we do not use the dummy item 0, and directly compare with the threshold of zero.
It is easy to see that inference for γ = 0 is the same as Best-Left-Link inference. Overall, L3M is an
expressive model that, by tuning γ, can express inference based on not only the maximum weight link, but,
with the same time complexity (i.e. quadratic), inference based on multiple links between an item and a
cluster. Also, note that previous works using Best-Left-Link inference [Ng and Cardie, 2002, Bengtson and
Roth, 2008, Shen et al., 2006] often treat learning in an ad hoc fashion, without relating it to inference.
L3M presents a principled structured prediction view of learning and inference. In particular, for γ = 0, the
learning algorithm (presented later in this section) for L3M is novel and experimentally superior.
Likelihood of a Clustering in L3M model
In this section, we compute the probability Pr[C; d,w] of generating a clustering C, given w. This probability
will not only shed more insight into our model, but will also later be helpful in performing likelihood based
learning. Due to modeling assumptions 1 and 2 of L3M, we can express Pr[C; d,w] as the product of the
103
Algorithm 11 Inference algorithm for L3M.
1: Input: Data stream d with mentions 1, . . . ,md and weight parameters w
2: Output: Clustering B of items (Notably, for notational convenience we return the clustering as set
partitioning items in {1, . . . ,md} and not as a binary function as in the rest of this chapter.)
3: initialize B = ∅
4: for i = 1, . . . ,md do
5: bestscore← 0, bestcluster ← ∅
6: for b ∈ B do
7: score←
{ ∑
j∈b e
1
γ
(w·φ(i,j))
γ > 0 ,
maxj∈b e
(w·φ(i,j)) γ = 0
8: if score > bestscore then
9: bestscore← score, bestcluster ← b
10: end if
11: end for
12: if bestscore > 1 then
13: B ← B \ {bestcluster} ∪ {bestcluster ∪ {i}}
14: else
15: B ← B ∪ {i}
16: end if
17: end for
18: return B
probabilities of each item i connecting to its left in a manner consistent with C:
Pr[C; d,w] =
md∏
i=1
Pr[C / i; d,w] , (5.4)
where Pr[C / i; d,w] is the probability that item i ≥ 1 connects to its left as per C i.e. the probability that
i links only to those antecedent items j that have C(i, j) = 1. Using Eq. (5.3), Pr[C / i; d,w] is simply given
by:
Pr[C / i; d,w] =
∑
0≤j<i
Pr[j ← i; d,w]C(i, j) =
∑
0≤j<i exp
(
1
γ (w · φ(i, j))
)
C(i, j)∑
0≤j<i exp
(
1
γ (w · φ(i, j))
) = Zi(C; d,w, γ)
Zi(d,w, γ)
, (5.5)
where Zi(C; d,w, γ) =
(∑
0≤j<i exp
(
1
γ (w · φ(i, j))
)
C(i, j)
)
is the unnormalized probability of connecting
as per clustering C, and Pr[j ← i; d,w] and Zi(d,w, γ) are defined in Eq. (5.2). Finally using (5.5), we get
that the likelihood of clustering C is
Pr[C; d,w] =
md∏
i=1
Pr[C / i; d,w] =
md∏
i=1
Zi(C; d,w, γ)
Zi(d,w, γ)
=
md∏
i=1
(∑
0≤j<i exp
(
1
γ (w · φ(i, j))
)
C(i, j)
)
(∑
0≤j<i exp
(
1
γ (w · φ(i, j))
)) . (5.6)
104
5.3.2 Alternative View of L3M as a Latent Tree-based Approach
In this section, we present an alternative way of explaining L3M, which exposes the underlying latent
variables. We observe that in L3M, each item connects to one item (possibly the dummy item 0) on its left
during inference. This creates a special tree structure which we call a Left-Linking Tree, where the parent
of each item is on its left in the data stream.
More formally, a valid left-linking tree for document d can be represented as a set of edges
z = {(i, j)|0 ≤ j < i ≤ md}, such that (5.7)
1) ∀i ∈ {1, . . . ,md}, ∃ a unique j ∈ {0, . . . , i− 1} (to the left of i) such that (i, j) ∈ z and
2) @k ∈ {i, . . . ,md}, (i, k) ∈ z.
Trivially, a left-linking tree is always rooted at the dummy item 0. For a document d, let Zd represent the
set of all valid left-linking trees.
Probability of a Left-linking Tree We present a simple model to compute the probability of a left-
linking tree using the pairwise scoring metric. We express the probability of a left-linking tree as a Gibbs
distribution based on the sum of the scores of its edges:
Pr[z; d,w] =
1
T (d,w, γ)
exp
 1
γ
 ∑
(i,j)∈z
w · φ(i, j)
 , (5.8)
where T (d,w, γ) is the partition function or the normalization and γ ∈ (0, 1] is the inverse temperature
parameter. As γ approaches zero, the above probability approaches a Kronecker delta function that puts
probability 1 on maximum weight tree z∗ = arg maxz∈Zd
(∑
(i,j)∈z w · φ(i, j)
)
, and 0 everywhere else. Thus,
as before, we abuse the notation a little bit and use the expression in Eq. (5.8) for all γ ∈ [0, 1].
Probability of a Clustering using the Left-linking Trees There is a many-to-one mapping from the
set of all left-linking trees to the set of all clusterings. In particular, a given left-linking tree z implies a
unique clustering (the one obtained by taking a transitive closure of z). However, for any given clustering,
there are many possible left-linking trees. Given a clustering C, let
ZCd = {z ∈ Zd|∀(i, j) ∈ z, C(i, j) = 1}
refer to the set of all left-linking trees consistent with C.
105
Since the clustering C is the output of interest, we treat the left-linking trees as latent variables and
express the probability of C as the sum of the probabilities of all the left-linking trees consistent with C:
Pr′[C; d,w] =
∑
z∈ZCd
Pr[z; d,w] =
1
T (d,w, γ)
∑
z∈ZCd
exp
 1
γ
 ∑
(i,j)∈z
w · φ(i, j)
 . (5.9)
Lets call this model the Latent Left-Linking Tree (L3T) model. The following theorem shows that indeed
L3M and L3T are equivalent.
Theorem 5.3.1. The probability of a clustering in L3T (expressed in Eq. (5.9)) is the same as probability
of clustering for L3M (expressed in Eq. (5.6)), i.e. Pr′[C; d,w] = Pr[C; d,w].
The proof is presented in the appendix. As a direct implication of this theorem, we can view L3M
as a latent variable structured prediction approach, in which the true latent variables are the underlying
left-linking trees. L3M is marginalizing over the left-linking trees in order to generate the probability of the
output variable of interest i.e. the clustering.
5.3.3 Latent Variable Learning
The task of learning in this case is to estimate w, given a set of annotated data streams D, where for each
data stream d ∈ D, Cd refers to the true clustering (i.e. partition). We use a likelihood-based approach to
learning.
The log-likelihood of all annotated clusterings, assuming the data streams are drawn i.i.d., can be obtained
by summing the log-likelihood of one clustering as expressed in Equation (5.6) as
∑
d∈D
logPr[Cd; d,w] =
∑
d∈D
md∑
i=1
(logZi(Cd; d,w, γ)− logZi(d,w, γ)) . (5.10)
Objective Function for Learning
Assuming the data streams are generated I.I.D., we learn w by minimizing the regularized negative log-
likelihood of the data. We augment the partition function with a loss-based margin following Pletscher et al.
[2010] and Gimpel and Smith [2010] and as we observed in Section 2.5.2. In particular, we augment the
unnormalized log probability of each clustering C by a loss function ∆(C, Cd). In order to achieve tractable
loss-augmented minimization — something we touch on in the context of structural SVMs in Section 2.3.1 —
we use a decomposable loss function that just counts the number of item pairs on which C and Cd disagree:
∆(C, Cd) =
∑md
i,j=0,j<i IC(i,j)=Cd(i,j), where I is a binary indicator function
106
The resulting regularized, loss-augmented, negative log-likelihood function LL(w) is given by
LL(w) =
β
2
‖w‖2 + γ
|D|
∑
d∈D
1
md
md∑
i=1
log( ∑
0≤j<i
e
1
γ (w·φ(i,j)+δ(Cd,i,j)))− logZi(Cd; d,w, γ)
 , (5.11)
where β is the regularization penalty and δ(Cd, i, j) = 1−Cd(i, j) is 0 if i and j share the same cluster in Cd,
otherwise 1.
As γ approaches zero, LL(w) approaches latent structural SVMs (LSSVM) [Yu and Joachims, 2009].
For γ = 1, LL(w) is the objective function for hidden variable conditional random fields (HCRF) [Quattoni
et al., 2007]. This was described in Section 2.5.2. Thus by tuning γ, we consider a learning technique more
general than LSSVM and HCRF (see Pletscher et al. [2010] and Schwing et al. [2012] for more details.)
Optimization using Concave Convex Programming
It is easy to seee that the objective function in Equation (5.11) is a difference of two convex functions g1(w)
and g2(w) expressed as
LL(w) =
β
2
‖w‖2 + γ
|D|
∑
d∈D
1
md
md∑
i=1
log(
∑
0≤j<i
e
1
γ (w·φ(i,j)+δ(Cd,i,j)))︸ ︷︷ ︸
g1(w)
− γ
|D|
∑
d∈D
1
md
md∑
i=1
logZi(Cd; d,w, γ)︸ ︷︷ ︸
g2(w)
.
Thus the CCCP technique [Yuille and Rangarajan, 2003], discussed in Section 2.5.2 and presented in Algo-
rithm 4 can be used for optimizing this function.
The CCCP algorithm requires the the gradient of g2 which is given by
γ
|D|
∑
d∈D
1
md
md∑
i=1
∑
0≤j<i
p′jφ(i, j), where p
′
j =
Cd(i, j)Zi(d,w, γ)
Zi(Cd; d,w, γ)
Pr[j ← i; d,w] .
Thus we can iteratively solve a convex optimization problem obtained by replacing g2 in our objective
function by a hyperplane that uses the gradient above. The resulting convex problem can be solved using
gradient descent or limited memory BFGS.
However, we are not going to use CCCP for optimization. This is because CCCP requires one complete
pass over the entire training data to make a single gradient computation. While this can be used for small-
sized data streams, it will be computationally very expensive for a large number of items. In fact, CCCP is
not even feasible in a pure streaming setting where the number of items can be potentially unbounded and
the ground truth is revealed in the form of oracle calls.
Following the theme of this thesis, we will decompose the learning procedure into smaller steps. We will
107
use a stochastic gradient descent (SGD) technique as explained below.
Decomposing the Learning using Stochastic (sub)gradient based Optimization
We use an SGD based technique for optimizing LL(w). The key insight follows from the observation that
LL(w) decomposes not only over individual training data streams, but also over individual items in each
data stream as we can re-write LL(w) as
LL(w) =
1
|D|
∑
d∈D
1
md
md∑
i=1
(
β
2
‖w‖2 + e
1
γ (w·φ(i,j)+δ(Cd,i,j)) − e
1
γ (w·φ(i,j))Cd(i, j)
)
.
Consequently, we use a fast stochastic gradient descent (SGD) strategy that instead of performing
marginal inference over entire data stream, makes rapid online updates on a per-item basis, thereby de-
composing the learning into smaller steps. The stochastic gradient (subgradient when γ = 0) w.r.t. item i
in data stream d makes use of a weighted sum of features of all left-links from i:
∇LL(w)id ∝
∑
0≤j<i
pjφ(i, j)−
∑
0≤j<i
p′jφ(i, j) + βw, (5.12)
where pj and p
′
j , j = 0, . . . , i− 1, are non-negative weights that sum to one and are given by
pj =
e
1
γ (w·φ(i,j)+δ(Cd,i,j))∑
0≤k<i e
1
γ (w·φ(i,k)+δ(Cd,i,k))
and p′j =
Cd(i, j)Zi(d,w, γ)
Zi(Cd; d,w, γ)
Pr[j ← i; d,w] .
Intuitively, SGD with the gradient in Equation (5.12) promotes a weighted sum of correct left-links from i
and demotes a weighted sum of all other left-links from i. The reader should note that our algorithm is not
SGD in a pure sense as the items are chosen in the streaming order and not randomly (as in Algorithm 3.)
Convergence: It is difficult to characterize the behavior (e.g. convergence) of SGD strategies for non-
convex problems. However, SGD is known to be quite successful in practice when applied to many different
non-convex learning problems [Guillory et al., 2009, LeCun et al., 1998]. In Section 5.5, we show that our
SGD-based learning is robust and when compared with CCCP, shows rapid convergence without sacrific-
ing empirical accuracy. Theoretical characterization of our SGD approach in terms of convergence and
improvement of the objective function remains an open problem.
Finally, note that for γ = 0, our stochastic gradient update algorithm is similar to the latent structured
perceptron like algorithm used in Chang et al. [2012]. Following Chapter 4, we improve over this algorithm
by tuning the value of γ using a development set.
108
5.4 Related Work
Streaming data clustering using k-center approaches [Guha et al., 2003] over points in a fixed metric space
has enjoyed much popularity in the data mining literature. However, our focus is on pairwise feature-based
clustering which is more general than clustering points in a metric space [Xing et al., 2002] as our pairwise
similarities are not restricted to be metrics. Also, we do not have to specify the number of clusters in
advance.
Our work can be viewed as a supervised discriminative counterpart to the Distance Dependent Chinese
Restaurant Process (DDCRP) [Blei and Frazier, 2011] that performs unsupervised clustering of items arriving
in an order based on their pairwise similarities. In DDCRP, customers (items) arrive in some order and
either join an existing table (cluster of items) or start a new table (create a new cluster). The probability
that a customer i joins a customer j is given by
Pr(i joins j) ∝
 f(dist(i, j)) if j 6= iα if j = i ,
where dist(i, j) computes some kind of fixed distance between items i and j, f is a decay function that gives
lower score for larger distances, α is a fixed scalar, and j = i refers to the case when item i starts a new
cluster (same as linking to the dummy item 0 in our case.) L3M is more general than DDCRP because it
allows learning feature-based similarity between items because it has access to training data.
Our work is most closely related to other discriminative approaches that pose clustering as a structured
prediction problem. We divide the discussion on these techniques into two groups: non-streaming techniques
that require looking at all the items together and streaming techniques that can be applied on one item at
a time. We experimentally compare with these techniques in Section 5.5.
5.4.1 Non-Streaming Structured Prediction based Clustering Techniques:
The following two techniques require looking at all the items of the stream and cannot be used for clustering
in a pure streaming setting.
Correlation Clustering: Mccallum and Wellner [2003] and Finley and Joachims [2005] use correlation
clustering [Bansal et al., 2002] on a complete graph over all the items with edge weights wij given by the
pairwise classifier. In this case, for a given data stream d, we specify the target clustering C by a collection
of binary variables {yij ∈ {0, 1}|1 ≤ i, j ≤ md, i 6= j} where yij ≡ C(i, j), that is yij = 1 if and only if
i and j are in the same cluster in C (yij and yji thus refer to the same variable.) For a data stream d,
109
given w, correlation clustering finds a clustering by solving the following integer linear programming (ILP)
optimization problem:
arg max
y
∑
i,j
wijyij , yij ∈ {0, 1}
s.t ykj ≥ yij + yki − 1 ∀ mentions i, j, k .
(5.13)
Intuitively correlation clustering tries to maximize the sum of all intra-cluster edges. The inequality con-
straints in Equation (5.13) enforce the transitive closure of the clustering. The solution of Equation (5.13)
is a set of clusters. Correlation clustering is an NP Hard problem [Bansal et al., 2002] and hence using
exact inference in this approach is very slow for a large number of items. Nonetheless, for reasonable prob-
lem sizes, the problem can be solved by using an Integer Linear Programming (ILP) solver. For large size
problems, one can use an incremental greedy algorithm [Finley and Joachims, 2005] or a trivial randomized
3-approximation [Ailon et al., 2008]. Finley and Joachims [2005] learn w in this setting using a structural
SVM formulation, which we also use in our implementation.
Latent Spanning Forest [Yu and Joachims, 2009]: This approach was proposed by Yu and Joachims
[2009] for coreference clustering. The key motivation for this approach is that most of the
(
md
2
)
links
considered by All-Link clustering may not contain any useful signal and the coreference decision may likely
be figured out transitively after determining a few strong coreference links. Yu and Joachims propose to
model these “strong” coreference links using a latent spanning forest. In particular, they posit that a given
coreference clustering C is a result of taking a transitive closure of a spanning forest — every cluster in C is
a connected component (i.e. a tree) in the forest, and distinct clusters in C are not connected by any edge
in the forest.
The task of inference in this case is to find the maximum weight spanning forest over a complete weighted
graph connecting all the items, where edge (i, j) has weight wij . This inference can be performed using
Kruskal’s algorithm. Yu and Joachims learn the pairwise weights w using a latent structural SVM formula-
tion (presented in Section 2.5.2) which they optimize using CCCP.
Notably, L3M also uses a tree structure spanning the items (removing the dummy item gives a spanning
forest) as the underlying latent structure (Section 5.3.2.) However, L3M considers a restricted class of
spanning trees (the left-linking trees.) Due to the left-linking property, L3M can work in a streaming fashion
and can sum over all possible left-linking trees, and not just the maximum weight one, in quadratic time (Yu
and Joachims only consider the maximum weight tree). On the other hand, the spanning forest approach
cannot work in a streaming setting and summing over all spanning forests will take at least cubic time using
110
the Matrix tree theorem [Koo et al., 2007]. Furthermore, unlike arbitrary spanning forests, left-linking trees
capture the directionality of streaming and outperform the spanning forest model in our experiments.
5.4.2 Streaming Clustering Techniques:
We now discuss two existing clustering techniques that can cluster mentions or items appearing in a streaming
order. We now discuss two techniques that cluster items in a greedy streaming order. Notably, search-based
structured prediction techniques [Daumé III et al., 2009] cannot be used in a streaming setting as they
require access to the entire stream to compute the loss associated with a greedy atomic action used to train
a base classifier.
Best-Left-Link Clustering: As described in Section 5.3, in the Best-Left-Link inference strategy, each
item connects according to only the maximum weight left-link (corresponds to γ = 0 in L3M.) This strategy
has been successfully used in applications like coreference clustering [Ng and Cardie, 2002, Bengtson and
Roth, 2008, Stoyanov et al., 2009] and thread detection [Shen et al., 2006]. However, most works perform
learning in an ad hoc fashion, not relating it to inference in a principled way and with no good explanation.
For instance, Ng and Cardie [2002] and Bengtson and Roth [2008] train w on binary — and not structured
— classification data extracted from the annotated clustering. For instance Bengtson and Roth [2008] train
w on binary training data generated by taking for each item, the closest antecedent coreferential item as a
positive example, and all the other items in between as negative examples. No explanation is available as
to why this is the right way to train. L3M not only generalizes Best-Left-Link inference (by tuning γ), but
also provides a more principled structured prediction framework, and experimentally outperforms such ad
hoc techniques.
Sum-Link Clustering: This supervised streaming data clustering technique was proposed by Haider et al.
[2007] as an approximation to correlation clustering for detecting batches of spam emails. In particular, Sum-
Link considers the items in a streaming order and expresses the score of connecting an item i to a cluster c
as the sum of the scores of pairwise links from i to all items in c:
∑
j∈c,j<i
w · φ(i, j) .
It connects i to the cluster with highest score if the score is greater than 0. Like L3M, once an item is
assimilated in a cluster, the cluster membership is never changed later. Haider et al. [2007] proposed an
efficient quadratic programming based learning technique for this model.
111
At the first glance, sum-link seems very similar to L3M as both combine weights obtained from multiple
pairwise links between a given item i and a cluster c. However, there is a fundamental difference in terms
of how the weights are combined. Sum-Link combines all the links linearly whereas L3M is a non-linear
log-sum-exponential model and puts significantly more importance on high scoring links than low scoring
links (the weighting can be flexibly modulated by the use of the parameter γ.) For instance, consider two
sets of pairwise links: one with weights 10, -1, and -6 and another with weights 3, 1, and 1. Sum-link will
associate a higher score with the latter case than the former as the latter sums to 5 and the former sums to
3. However, L3M will do the opposite for at least γ ≤ 1. In fact, with γ = 0, L3M only considers the best
scoring links. For several tasks like coreference resolution, it is believed that only a few strong links and not
all links, especially not the weak links, are likely to be informative [Ng and Cardie, 2002]. For such cases,
L3M is much more suitable than Sum-Link. We will show that L3M significantly outperforms sum-link in
our experiments.
Advantages of the L3M Approach
Following is a summary of the key advantages of L3M over competing approaches.
1. Efficiency of Inference: Our approach has inference complexity of O(m2d), where md is the number
of mentions in a document, which is as good as the spanning forest approach and the best-left-link
approach. However, inference in L3M can sum over all possible left-links (or, alternatively, sum over a
large number of underlying forests), and not just the maximum weight ones, also in time O(m2d). On
the other hand, summing over all spanning trees will require a complicated application of the Matrix
Tree Theorem and will take at least O(m3d) time [Koo et al., 2007]. Inference for correlation clustering
is NP hard.
2. Efficiency of Learning: Determining the gradient while marginalizing over left-links has complexity
O(m2d) for our L
3M approach. This is the same as the gradient computation in the spanning forest ap-
proach, however, that takes into account only one spanning forest. More importantly, in our approach,
we can make rapid online stochastic gradient updates on a per-mention basis which is not feasible for
the non-streaming clustering techniques.
3. Modeling Flexibility We use a temperature-like parameter to generalize the Best-Left-Link inference
and allow our learning to smoothly interpolate between a hidden variable CRF and latent structural
SVM approach.
112
5.5 Experiments and Results
In this section, we present experiments on two supervised clustering tasks: coreference resolution and doc-
ument clustering in the form of clustering of online forum postings. First, we discuss competing algorithms
and some experimental details.
Baselines: We compare with the following different baselines that have already been discussed in Sec-
tion 5.4.
1. Corr-Clustering: This is a correlational clustering-based approach. Following Finley and Joachims
[2005], we use structural SVMs [Tsochantaridis et al., 2004] for learning. We use an ILP solver to solve
the inference problem unless otherwise stated.
2. Spanning: This is the latent spanning forest based approach where we use Kruskal’s algorithm for
inference.
3. Bin.-Left-Link: This approach uses the Best-Left-Link inference and performs relatively ad hoc
training used by Bengtson and Roth [2008]. In particular, we train w with an online SGD-based
SVM on binary training data generated by taking for each item, the link to the closest antecedent
co-clustered item as a positive example, and links to all other items in between as negative examples.
4. Sum-Link: This is the streaming clustering technique by Haider et al. [2007]. We use stochastic
gradient descent for learning.
L3M implementation details : we try two versions of our proposed L3M approach. L3M (tuned γ): In
this version, we tune the value of γ using a validation set picking the best γ from {0.0, 0.2, 0.4, 0.6, 0.8, 1.0}.
We use the same γ for training and testing. L3M (γ = 0): In order to test whether considering multiple
left-links help, we consider L3M with γ set to 0 (which only uses the maximum weight left-link.) This is
really a non-probabilistic latent SVM-like version of our algorithm that considers only one left-linking tree
instead of multiple trees.
Other implementation details: For all the streaming clustering techniques (Sum-Link, Bin.-Left-Link,
L3M), we present results with multiple number of passes tuned on a validation set as well with just a single
pass over the data. We assume that the pairwise score is given by w ·φ+ t where t is a bias parameter set to
0 during learning. For all the algorithms, we tune the value of t and the regularization parameters (and also
γ for L3M) to optimize the targeted evaluation metric on the development set. We use the same features
for all the techniques.
113
5.5.1 Coreference clustering
Coreference resolution is a challenging NLP task requiring a system to identify denotative noun phrases
called mentions and cluster those mentions together that refers to the same underlying entity. An example
of coreference clustering was presented in Figure 5.1.
We argue that coreference clustering can be treated as a streaming data clustering problem with docu-
ments as data streams and mentions as items as the mentions follow a natural left-to-right order (right-to-left
for a few languages.) This is motivated by the linguistic intuition that humans are likely to resolve corefer-
ence for a given mention based on antecedent mentions. We show experimental results on two benchmark
English coreference datasets — ACE 2004 [NIST, 2004] and Ontonotes-5.0 [Pradhan et al., 2012].
Datasets: ACE 2004 [NIST, 2004] data contains 442 documents, split into 268 training, 68 development,
and 106 testing documents — the same split is used across the NLP literature as a benchmark [Bengtson
and Roth, 2008] to compare various systems. OntoNotes-5.0 [Pradhan et al., 2012] is the largest annotated
corpus on coreference with a total of 3,145 training documents and 348 testing documents. We use 343
documents from the training set for validation. Ontonotes contains documents drawn from different sources
— newswire, bible, broadcast transcripts, magazine articles, and web blogs. We train and validate separate
models for different parts of the corpus (like newswire or bible).
Features and Evaluation: We use gold mention boundaries (i.e. mentions provided by the dataset) in
our experiments in order to compare the algorithms purely on clustering, unmitigated by errors in mention
detection. For all the techniques, we use the set of features given by Chang et al. [2012] which are reported
in Table 5.1. NLP literature evaluates coreference on primarily three different metrics — MUC [Vilain et al.,
1995], B3 [Bagga and Baldwin, 1998], and CEAF [Luo, 2005]. We report F1 scores for these metrics and
also their average, which we use as the main metric of comparison2.
For inference in Corr-Clustering, we use an ILP solver. As Corr-Clustering can be inhibitively slow, we
use a reduced and faster version (Corr-Clustering-Red) which drops one of the three transitivity constraints
for each triplet of mention variables. Similar to Pascal and Baldridge [2009] and Chang et al. [2011] we
observe that this also slightly improves the accuracy over standard Corr-Clustering approach on ACE data,
in addition to speeding up inference. For the larger OntoNotes data, we only use Corr-Clustering-Red.
For the Spanning baseline [Yu and Joachims, 2009], we use the implementation provided by the authors3
for the ACE corpus. Since their CCCP implementation is very slow, we implemented our own stochastic
2Following, the CoNLL shared task competition [Pradhan et al., 2012] on Coreference Resolution.
3Available at http://www.cs.cornell.edu/ cnyu/latentssvm/
114
Category Features
Mention Type MentionTypePair, EnityTypePair, EntityTypeMatch
String Match HeadMatch, ExtentMatch, SubstringMatch, ModifierMatch, AliasMatch AlignedModifier
Semantic inQuoted, GenderMatch, NumberMatch, Synonyms, Antonyms, Hypernyms, BothSpeak
Form isDemonstrative, isDefinite, isIndefinite, NumWordsInHead, NumWordsInExtent
Relative Location Apposition, RelativePronoun, SentDistances, AEmbeddedB, isNearestCompatibleMent
Learned Feature Anaphoricity, NameModifiers
Lexicon LastWordsOfHead
Pronoun Resolution ProType(e.g., number, gender, person), LeftPOS, RightPOS, isHuman, isSpeak
Table 5.1: The features we extract from mention pairs for coreference resolution [Chang et al., 2012]
MUC BCUB CEAFe AVG MUC BCUB CEAFe AVG
Technique ↓ ACE 2004 OntoNotes-5.0
Corr-Clustering 77.45 81.1 77.57 78.71 84.26 75.03 63.07 74.12
Spanning Forest 73.31 79.25 74.66 75.74 84.75 73.93 60.47 73.05
Sum-Link (1 pass) 69.61 77.51 73.86 73.66 80.32 71.83 62.64 71.6
Sum-Link 72.7 78.75 76.42 75.96 82.26 74.59 64.8 73.88
Bin-Left-Link (1 pass) 74.19 79.3 77.77 77.09 80.74 72.15 64.36 72.42
Bin-Left-Link 76.02 81.04 77.6 78.22 81.57 73.18 65.54 73.43
L3M (γ = 0) (1 pass) 76.7 80.89 78.02 78.54 84.45 76.18 66.41 75.68
L3M (γ = 0) 77.57 81.77 78.15 79.16 85.14 77.01 67.6 76.58
L3M (tuned γ) (1 pass) 76.7 80.89 78.02 78.54 85.07 76.97 67.17 76.40
L3M (tuned γ) 78.18 82.09 79.21 79.83 85.73 77.67 68.13 77.18
Table 5.2: Performance on ACE 2004 and OntoNotes-5.0. Corr-Clustering is proposed by Finley and
Joachims [2005]; Spanning Forest is the latent spanning forest-based approach by Yu and Joachims [2009];
Sum-Link is a streaming data clustering technique by Haider et al. [2007]; Bin-Left-Link uses a Best-Left-
Link inference and the training strategy by Bengtson and Roth [2008]. Our proposed approach is L3M—
L3M with tuned γ is when we tune the value of γ using a development set; L3M (γ = 0) is with γ fixed to
0. Corr-Clustering-Red drops some transitivity constraints during inference. Corr-Clustering and Spanning
Forest are not streaming clustering techniques. Sum-Link, Bin.-Left-Link, L3M (tuned γ), and L3M (γ = 0)
are streaming clustering techniques. “(1 pass)” means when trained with just one pass over the data.
gradient descent version for a much larger OntoNotes. We perform ten passes over the data for ACE and five
passes for Onto-Notes for all the techniques, which were sufficient to achieve top performance. For streaming
techniques, we also report performance with just one pass.
Results: Table 5.2 reports the results on coreference. Clearly, our L3M approach outperforms all the
competing baselines and notably achieves state-of-the-art B3 results on the ACE 2004 data. For all the
settings with the exception of ACE with one pass, L3M with tuned γ is better than L3M with γ = 0 by
0.6-07 points in terms of the average showing that considering multiple links is actually helpful. For L3M
(tuned γ), the best value of γ for ACE 2004 for one pass was 0 and with multiple passes, the best γ was 0.2.
For OntoNotes, we obtained different γ values for different parts of the corpus with no one clearly better γ
value. Also, in the multiple pass setting, when tuning the number of passes on the development set, it took
five passes to achieve top performance for both the datasets. Also, as opposed to what is reported by Yu and
115
# authors
# data
streams
# posts
avg. #posts
/ author
avg. #posts
/ data stream
avg. #tokens
/ post
max. #posts
by author
18,617 1,984 690,498 37.09 348 53.64 72
Table 5.3: Summary statistics for the online forum data. One data stream contains postings from one day.
Last column represents maximum number of posts by any author in a single data stream.
Joachims [2009], the spanning forest approach performs worse than the correlation clustering approach. We
think that this is because we compare the systems on different metrics than them and also because we use
exact ILP inference for correlational clustering whereas Yu and Joachims used approximate greedy inference.
5.5.2 Clustering of Online Forum Postings
We present experiments on document clustering using postings downloaded from discussions on an online
forum 4. We consider two different clustering perspective for these posts as described below.
• Author-based Clustering: In this case, the task is to cluster the postings based on their authorship
such that each cluster represents the items written by the same author. This task is essentially
equivalent to Author Identification [Stamatatos, 2009], where a system is required to cluster a collection
of textual items (e.g. emails, forum postings, articles) based on their authors. This task has potential
applications, e.g., in email spam detection, intelligence, and criminal law.
• Topic-based Clustering: In this case, we cluster the postings based on their discussion thread —
all the postings belonging to the same discussion thread (e.g. what is a disabled veteran) correspond
to one cluster. In effect this means that we are clustering postings based on topics. The application of
this includes detecting batches of spam emails that may share the same topic.
Admittedly, the clusterings for the given data may not perfectly align with the described tasks. For example,
two posts in two different discussion threads may share the same “topic” (and we will deem them as different
as they belong to different threads) or one of the posts written by an author may be too short and sparse
to have a significant correlation with other posts written by the same author. Nonetheless, we assume that
our data provides a fair comparison of various streaming clustering techniques.
Data: We downloaded a large number of posts corresponding to various discussions. These posts carry a
time stamp and hence they are naturally ordered based on the time of their posting. Consequently, they fit
the streaming data description we have assumed in this chapter. However, in order to perform 10-fold cross
4http://forums.military.com
116
Task → Author Clustering Topic Clustering with five passes
Technique VI FM VI FM VI FM
Corr-Clustering 143.67 31.83 275.7 9.24 - -
Spanning Forest 134.44 37.12 274.70 19.30 - -
Sum-Link 133.12 39.25 249.75 25.42 245.44 26.98
Bin-Left-Link 133.09 38.96 246.76 21.68 240.69 23.88
L3M (γ = 0) 133.39 38.78 244.13 22.71 240.73 23.78
L3M (tuned γ) 132.12 39.57 240.55 23.52 235.59 25.05
Table 5.4: Results on the forum data for author-based and discussion topic-based clustering. For streaming
algorithms, one pass over the data was sufficient. For streaming algorithms with topic-based clustering, we
report results with one pass as well as five passes (last two columns) during training. All the results are
scaled by 100. Small VI and large FM are desirable. In most cases, L3M (tuned γ) is statistically significantly
better than all the other approaches.
validation, we divide the data into different data streams — all the postings from one day form one data
stream, ordered by the time of posting. Table 5.3 presents some statistics of the data.
Features and Evaluation: We use the following pairwise features between a given pair of postings:
TFIDF-based cosine similarity of the content, time difference between the posts, difference between their
positions (|j−i|), and the common words between the posts (weighted by IDF.) For this task, we report results
on two measures commonly used in the machine learning literature for evaluating supervised clustering: the
Variation of Information (VI) [Meilă, 2007] and the Fowlkes Mallow (FM) index [Fowlkes and Mallows,
1983]. Note that lower values of VI and higher values of FM are desirable. We use a greedy algorithm for
Corr-Clustering proposed by Finley and Joachims [2005] as the data streams in this task are too large for
ILP inference. For non-streaming techniques, we perform ten passes over the data. In the case of streaming
techniques, for author identification, a single pass was sufficient to achieve top performance. For topic
clustering, the streaming techniques achieve top performance with five passes; we also report results with
one pass.
Results: The results are reported in Table 5.4. For streaming clustering techniques and so we do not
report results with multiple passes separately. We observe that L3M with tuned gamma outperforms all the
other algorithms on both VI and FM for author identification and on VI for topic-based clustering (p-value
< 0.006 with Wilcoxon Signed Rank test using Holm-Bonferroni correction). In particular, again, tuning the
γ value improves the performance significantly over γ = 0. For L3M with tuned γ, the median best value of
γ over the 10 folds was 0.4.
117
Task → ACE Coreference Author Clustering Topic Clustering +five passes
Technique MUC B3 CEAF AVG VI FM VI FM VI FM
Sum-Link 69.35 77.3 73.54 73.40 134.03 39.58 263.62 22.48 259.57 23.45
Bin-Left-Link 72.62 76.84 74.89 74.78 133.62 39.48 257.69 20.15 252.69 19.95
L3M (γ = 0) 75.18 78.66 76.02 76.62 133.66 39.40 254.64 20.01 252.17 20.19
L3M (tuned γ) 75.47 79.1 76.16 76.91 132.81 40.00 249.09 21.15 245.33 22.59
Table 5.5: Results with randomized ordering of items on coreference resolution for the ACE data and on
author-based and discussion topic-based clustering for Forum data. All the results are scaled by 100. The
results for author clustering are largely the same when items were not randomized (Table 5.4. The results
for coreference resolution and topic clustering are significantly worse.
5.5.3 Measuring the Impact of Streaming Ordering
Our experimental results on four different datasets we have considered have a mildly surprising element to
them — the techniques that consider items one-by-one in a streaming order (i.e. L3M, Sum-Link, and Bin-
Left-Link) outperform techniques that have access to all the items at once (Corr-Clustering and Spanning.)
Focusing on L3M, its superior performance could be because of two reasons. 1) Considering the items one-
by-one in a left-to-right order captures an inherent ordering of items in the tasks that aligns with how the
true clusterings are realized based on some unknown clustering model. 2) The probabilistic model assumed
in L3M is more suitable for the presented clustering tasks at hand. Naturally, these two reasons are not
mutually exclusive and the obtained performance can be because of a combination of both.
In order to tease apart the contribution of these two effects, we conduct a control experiment where we
consider the items in a random order (instead of the given streaming order), while keeping the pairwise
features between the items intact i.e. we make sure that the features that explicitly depend on the distance
between items in the stream remain unaffected. With this randomization, we perform learning and inference
as before for L3M, Sum-Link, and Bin-Left-Link. We use the same set-up as described before and conduct
experiments on ACE 2004 Coreference data, Author Clustering, and Topic Clustering.
Results: Table 5.5 contains the results of this experiment. We conduct the same number of passes as
are reported in Tables 5.2 and 5.4. Compare the results on coreference clustering with Table 5.2. Each of
the coreference metrics — MUC, B3, and CEAF — decline significantly. Their average declines by around
3 points for each of the streaming clustering techniques including L3M. This shows that in coreference, it
really does make a difference if we consider the mentions in a left-to-right order. For document clustering, we
observe mixed results. The results for author-based clustering are not significantly affected by randomization.
However, results for topic-based clustering get significantly worse for all the algorithms after randomization
with VI increasing roughly by 10 points (≈ 4%) and FM index decreasing by around 3 points (≈ 10%.) This
intuitively makes sense as posts belonging to the same topic are more likely to have non-trivial temporal
118
interactions than posts written by the same author.
5.5.4 Measuring the Impact of Non-Convexity on SGD Learning
While it is difficult to theoretically analyze Stochastic Gradient Descent (SGD) for non-convex functions,
we perform some experiments to observe the empirical impact of non-convexity on SGD.
1. Random Initialization: In this set of experiments, we measure the variance of the training data
performance of randomly initialized L3M with γ = 1.0 over 30 trials. For each trial, we initialize
learning with a random w whose elements are drawn independently from N (0, 1) and perform SGD
with one pass over the data. On coreference clustering over ACE 2004 data, we obtain a mean
performance (w.r.t. the average of MUC, B3, and CEAF) of 72.11 with a standard deviation of 0.17
(the low accuracy compared to the performance reported in Table 5.2 is due to the introduction of
noisy and non-sparse feature weights.) On author identification with a randomly selected sample of size
500, the VI and FM results we obtain are: 81.37 +/- 5.2×10−5 and 38.13 +/- 7.8×10−5, respectively.
The low variance in these results indicates that our SGD learning is very robust to initialization.
2. Comparison with CCCP: Recall that CCCP converges to a local minimum whereas SGD has no
such theoretical guarantees for non-convex functions. To see if this indeed affects the performance,
we compare their training data performance on the forum data using L3M with γ = 1.0. We use
just 1 pass of SGD; however, CCCP is really slow, taking around 100 iterations to converge, with the
convex program within each iteration taking 100 further iterations. Early stopping CCCP by relaxing
the stopping conditions is not a good option as it gives significantly worse results. Consequently, for
computationally reasons, we make comparisons only on randomly drawn (without replacement) small
subsets of 100 training examples. Averaged over 10 iterations, the difference between CCCP and SGD
is -0.23 in terms of VI and 0.17 in terms of FM (all values scaled by 100.) Thus SGD provides very
slightly worse training data performance than CCCP with around 10,000x speed-up.
5.6 Conclusions
This chapter presented a pairwise, feature-based, and discriminative latent variable model for clustering of
streaming data items. The model, L3M, takes into account probabilities of multiple links when greedily
connecting an item and uses a temperature parameter to tune the entropy of the resulting probability
distribution. We proposed a learning framework that generalizes and interpolates between hidden variable
CRF and latent structural SVM. In order to perform efficient and accurate learning, we present an online
119
stochastic gradient descent algorithm that decomposes the learning into online stochastic updates for each
item in the data stream. L3M outperforms existing streaming as well as non-streaming structured prediction
approaches to supervised clustering on coreference resolution and document clustering.
120
Chapter 6
Conclusion and Discussion
Structured output prediction forms the cornerstone for many applications in NLP, Vision, Speech Processing,
Bioinformatics, etc. In this thesis, we presented some techniques for learning with structured outputs for
a diverse set of scenarios. In all the learning scenarios, we achieve tractable learning by decomposing the
learning problem into smaller, more tractable, components. In this chapter, we conclude by discussing some
directions for future research.
6.1 Future research
6.1.1 Theoretical Analysis of Decomposed Learning
We showed in Chapter 3 that Decomposed Learning (DecL) is a very useful technique for max-margin
structural learning. We presented convincing empirical results as well as theoretical arguments in a few
scenarios with the assumption of separability. While there are several questions one can ask, we pose the
following two for future work. First, we re-write the DecL objective function from Equation (3.4) for the
ease of exposition.
β
2
‖w‖2 + 1
m
m∑
j=1
max
s∈Sj ,ys∈{0,1}|s|:(ys,yj−s)∈Y(xj)
(
w · φ(xj, (ys,yj−s))−w · φ(xj,yj) + ∆
(
(ys,y
j
−s),y
j
))
,
Getting rid of the Separability Assumption: DecL minimizes the function DecL(w;D) given above
as a tractable approximation to a more time-consuming structural SVM which minimizes the function
GL(w;D) (2.29). We analyzed the exactness relation between the set of separating weights for the tww,
assuming that the data is separable (Assumption 1). In a more realistic scenario, however, one deals with
potentially inseparable data by not enforcing hard separation and obtains a unique minimum by using
regularization. Thus it will be instructive to directly analyze the relation between the minima of both the
objective functions — DecL(w;D) and GL(w;D).
121
Generalization Analysis of DecL: Relating empirical error on the training set to expected error on
the underlying distribution is central to statistical learning theory. Collins [2002] provide mistake bounds
for structured perceptron and Taskar et al. [2004] give generalization bounds for relating test error with
training error for max-margin Markov networks. It is interesting to develop a similar bound for DecL
relating test error to “DecL-error”. More recently, London et al. [2013] presented a new set of bounds for
templated structured prediction models i.e. structured models created via repetitions of simpler structures
called templates (e.g. a pairwise Markov network can be considered to be constructed from individual edge
templates.) Since DecL breaks down learning-time-inference into inference over small subset of variables, it
is particularly amenable to template-based generalization bounds.
6.1.2 Supervised Structural Learning with Lagrange Relaxation
In Chapter 3, we observed that exploring a small neighborhood around the gold output in the DecL framework
works well for a fairly large class of problems. We can further develop DecL to deal with a larger class
of problems which do not satisfy the neighborhood properties in DecL, while keeping the computational
complexity of inference bounded. More specifically, instead of doing inference for each subset of variables
in isolation, we can “connect” decompositions to each other using agreement constraints which force MAP
inference on each decomposition to agree on shared output variables. We can make use of Lagrange relaxation
techniques we discussion in Section 4.4. We elaborate below.
Consider learning w with the inference problem discussed when presenting Lagrange relaxation in Sec-
tion 2.2.2. Recall that the inference problem is given by
arg max
y∈{0,1}n
w · φ(x,y) s.t. U(x)y ≤ b .
The global learning objective function with this inference is given by
GL(w) =
β
2
‖w‖2 + 1
m
m∑
j=1
max
y∈{0,1}n:U(x)y≤b
(
w · φ(xj,y) + ∆(y,yj)−w · φ(xj,yj)
)
. (6.1)
While exact inference based learning with the above objective function may be intractable, one can use
approximate Lagrange relaxation based learning. The Lagrange relaxation based approximate inference for
a given set of features x, borrowed from Section 2.2.2, is given by
min
λ0,µ1,...,µl
arg max
y1∈{0,1}n1 ,...,yl∈{0,1}nl , and y∈{0,1}n
l∑
k=1
w ·φ(x,yl)−λ ·(U(x)y−b)−
l∑
k=1
µk ·(Aky−yk) , (6.2)
122
where y1, . . . ,yl represents factors that allow tractable inference, λ represents dual variable corresponding
to inequality constraints, and µ represent dual variables corresponding to agreement constraints.
In particular, we can use Algorithm 2 for generating approximate Lagrange relaxation based subgradient.
However, this procedure still may not be fast enough as performing Lagrange relaxation based inference
multiple times for training instances may be fairly slow. We propose a technique to further speed it up by
allowing to perform gradient updates over parameters w without having to solve the Lagrange relaxation
inference step to completion. To see this, let us rewrite learning in Equation (6.1) using the approximate
inference objective from Equation (6.2). Furthermore, we assume that the loss function ∆ is the Hamming
loss (see Section 2.1.3 and the discussion on loss-augmented inference in Section 2.3.1.) We obtain
β
2
l∑
k=1
‖wk‖2 +
1
m
m∑
j=1
(
min
λj0,µj1,...,µ
j
l
max
y1∈{0,1}n1 ,...,yl∈{0,1}nl , and y∈{0,1}n
l∑
k=1
wk · φ(xj,yl)
− λj · (U(xj)y − b)−
l∑
k=1
µjk · (Aky − yk) +
∑
i
(yi − 2yiyji )−
l∑
k=1
wk · φ(xj,yjl)
)
.
(6.3)
In the above objective function, we have replaced the usual min-max form of learning by a min-min for-
mulation using the dual variables, which we make explicit by rewriting learning with the above objective
function as
arg min
w1,...,wk,(λj0,µj1,...,µ
j
l )
m
j=1
β
2
l∑
k=1
‖wk‖2 +
1
m
m∑
j=1
(
max
y1∈{0,1}n1 ,...,yl∈{0,1}nl , and y∈{0,1}n
l∑
k=1
wk · φ(xj,yl)
− λj · (U(xj)y − b)−
l∑
k=1
µjk · (Aky − yk) +
∑
i
(yi − 2yiyji )−
l∑
k=1
wk · φ(xj,yjl)
)
.
(6.4)
This implies that we can now simultaneously perform gradient descent on the weight parameters w as
well as the dual variables. The resulting algorithm is presented in Algorithm 12. Notably in lines 8-13,
instead of taking the Lagrange relaxation-based inference to convergence, we only take a single gradient step
over the primal and dual variables, while simultaneously updating the weight vectors. This technique of
interleaving gradient steps over the dual variables and the weight parameters rather than waiting for the
inference step to finish was also deployed by Meshi et al. [2010] for learning pairwise Markov networks with
LP relaxed inference. However, the above formulation we have is more general applicable to a wider variety
of scoring functions and constraints.
123
Algorithm 12 Algorithm for learning with Lagrange relaxation.
1: Input: Training data, D = {(xj,yj)}mj=1, step sizes ηt, number of iteration T , and regularization penalty
β
2: Initialize: ∀j = 1, . . . ,m, λj = 0, ∀k = 1, . . . , l, w1k ← 0, and ∀j = 1, . . . ,m, ∀k = 1, . . . , l, µ
j
k = 0
3: for t = 1 . . . T do
4: j ← Uniform({1, . . . ,m})
5: ŷ← H(1− 2yj − (λj)TU(x)−
∑l
k=1(µ
j
k)
TAk)
6: λj ← max(λj + η(Uŷ − b), 0)
7: for k = 1, . . . , l do
8: ŷk ← arg maxyk∈{0,1}nk w
t
k · φ(x,yk)− µ
j
k · yk
9: µjk ← µ
j
k + η(Akŷ − ŷk)
10: sgk ← βwtk + φ(xj, ŷk)− φ(xj,yjk)
11: wt+1k ← wtk − ηtsgk
12: end for
13: update ηt to get ηt+1
14: end for
6.1.3 Understanding UEM
In Chapter 4, we presented Unified Expectation Maximization (UEM), which is a family of EM-style algo-
rithms selected using temperature parameter. We presented experiments relating the quality of initialization
and model mismatch to the temperature parameter γ. We also showed how tuning this parameter can result
in potential improvements. However, more research is needed to theoretically understand the reasons for
this improvement. In particular, establishing relationship between γ and other factors like model mismatch,
initialization, and the resulting entropy of the final distribution (i.e. Pw(y|x) and not the posterior q(y).)
6.1.4 Linear Time Streaming Clustering
In Chapter 5, we presented the Latent Left-Linking model (L3M) for clustering. While L3M can cluster
items in a streaming order as they arrive, our clustering algorithm is quadratic in complexity and requires
us to store all the seen items. The same is true for the sum-link algorithm [Haider et al., 2007]. For both of
these algorithms, the score to decide whether to connect an item i to a cluster c = {j1, . . . , jl} is given by
the function form
score(i, c) = f(w · φ(i, j1), . . . ,w · φ(i, jl)) ,
which necessitates storing all the items in order to compute the similarities using w and φ. This is not
suitable for very large data streams where one desires linear complexity in the number of items — more
precisely O(nk) time clustering where n is the number of items and k is the number of clusters, and very
likely k  n.
In order to achieve this, one needs to devise a function g and features φ′ such that the above score can
124
be compactly approximated as
score(i, c) = f(w · φ′(i, g(j1, . . . , jl)),
so that instead of storing all the items in a cluster and compute pairwise similarities with each item, we
only need to represent the cluster by some kind of aggregated statistics g(j1, . . . , jl). Furthermore, we also
need that g should be computable in an incremental online fashion i.e. if item i joins the cluster c then we
should be able to compute g(j1, . . . , jl, i) from g(j1, . . . , jl) in O(1) time. This is true for many aggregated
statistics e.g. average vector space representation of all the items (e.g. words) in a cluster.
However, in many cases, such an approximation is challenging. For instance when using pairwise features
based on string-edit-distance between two items that are strings, it is difficult to represent the sum of string-
edit-distances between item i and items in the cluster c as a function of item i and a compact combination of
items in c. Some research in coreference clustering across documents [Rao et al., 2010, Singh et al., 2011] has
indeed focused on getting around these issues and scaling up feature-based clustering to a large number of
items. However, these techniques are specific to coreference resolution. More research is needed in creating
principled models for fast (linear time) and more generally applicable discriminative supervised clustering
and studying the kind of approximation achieved in such models.
125
Appendix A
A.1 Derivations for technical results in Section 4.4
Our goal here is to provide a general solution of the constrained E-step optimization problem presented in
Equation (4.9) for γ > 0. The above problem can be explicitly expressed in terms of variables q(y), ∀y ∈ Y(x)
as
min −
∑
y∈Y(x) q(y) logPw(y|x) + γ
∑
q(y) log q(y) (A.1)
s.t.
∑
y∈Y(x) q(y)U(x)y ≤ b, (A.2)
q(y) ≥ 0,∀y ∈ Y(x), (A.3)∑
y∈Y(x) q(y) = 1 . (A.4)
Note that while log q(y) is not well-defined for y = 0, but it is known that the entropy function is well
defined for all probability distributions using the fact that x log x→ 0 as x→ 0. Thus we do not impose a
strict inequality constraint at (A.3). However, for the moment, we remove the constraints in Equation (A.3).
Our plan is to show that the solution we obtain after removal of these constraints naturally satisfy these
constraints. We get back to this at the end of the proof.
Without Equation (A.3), the Lagrangian of Equation (A.1) can be written as:
Lg(q(y),λ, µ) = γ
∑
q(y) log q(y)−
∑
y∈Y(x)
q(y) logPw(y|x)+µ(
∑
y∈Y(x)
q(y)−1)+λT (
∑
y∈Y(x)
q(y)U(x)y−b) ,
(A.5)
where λ is a collection of dual variables, one for each expectation constraint in Equation A.2, and µ is the
dual variable corresponding to the constraint (A.4).
The Lagrangian optimization problem now is
max
λ≥0,µ
min
q
Lg(q,λ, µ) . (A.6)
126
The KKT conditions can be used to characterize the saddle point of the above Lagrangian. One of the
KKT conditions states
∂Lg(q(y),λ, µ)
∂q(y)
= γ log q(y) + γ − logPw(y|x) + µ+ λTU(x)y = 0 ,
which implies
q(y) = Pw(y|x)
1
γ exp(
−λTU(x)y
γ
) exp(−µ
γ
− 1) (A.7)
Applying another KKT condition we get
∂Lg(q(y),λ, µ)
∂µ
=
∑
y∈Y(x)
q(y)− 1 = 0 .
Combining the above with Equation (A.7), we get
q(y) =
Pw(y|x)
1
γ exp(−λ
TU(x)y
γ )∑
y′∈Y(x) Pw(y
′|x)
1
γ exp(−λ
TU(x)y′
γ )
=
Pw(y|x)
1
γ exp(−λ
TU(x)y
γ )
Zγ(λ)
, (A.8)
where Zγ(λ) is the normalization. Furthermore, we get
µ = γ(logZγ(λ)− 1) .
Substituting both of these equations in Equation (A.6) yields
max
λ≥0
−λTb− γ logZγ(λ) , (A.9)
which is the dual of Equation A.1. The gradient of the dual w.r.t. the dual variables is
−b +
∑
y∈Y(x)
Pw(y|x)
1
γ exp(−λ
TU(x)y
γ )
Zγ(λ)
U(x)y = −b +
∑
y∈Y(x)
q(y)U(x)y . (A.10)
The form of primal variables in terms of dual variables (Equation (A.8)) and the gradient of the dual variables
in terms of primal (Equation (A.10)) are the key expressions used in our algorithm in Section 4.4. Also note
that the values of q(y) obtained in (A.8) are non-negative and hence it is safe to ignore the positivity
constraint in the beginning.
127
Notably, in the absence of domain specific constraints, there are no dual variables λ, and q becomes
q(y) =
Pw(y|x)
1
γ∑
y′∈Y(x) Pw(y
′|x)
1
γ
, (A.11)
for γ > 0. For γ = 0, we have a linear programming problem with simplex constraints. Since the simplex
constraints are totally unimodular [Schrijver, 1986], one of the optima occurs at an integral point which is
given by q(y) = Iy=argmaxy′ Pw(y′|x).
A.2 Proofs for Chapter 3
This supplement provides the proof for all the theorems and corollaries in Chapter 3 on Decomposed Learn-
ing (DecL.) We provide the proofs as well as the theorem statements for the ease of understanding while
borrowing the notation from the main chapter.
Theorem 3.3.1 DecL is exact if ∀w ∈ W ∗,∃ > 0, such that ∀w′ ∈ B(w, ), ∀(xj,yj) ∈ D the
following condition holds for nbr(yj): if ∃y ∈ Y(xj) that is not separated correctly by w′ then there exists
y′ ∈ nbr(yj) which is also not separately correctly by w′ i.e. ∀w′ ∈ B(w, ) we have
∃y ∈ Y(xj),w′ · φ(xj,y) + ∆(yj,y) > w′ · φ(xj,yj)
⇒ ∃y′ ∈ nbr(yj),w′ · φ(xj,y′) + ∆(yj,y′) > w′ · φ(xj,yj)
(A.12)
Proof. Consider an  > 0 for which the condition mentioned in the theorem statement holds true for all
(xj,yj) ∈ D. Since W ∗ ⊆ W dec (Observation 2), to show exactness (W dec = W ∗), it is sufficient to show
W dec ⊆ W ∗. That is we want to show that ∀w ∈ Rd, if w ∈ W dec then w ∈ W ∗. Suppose there exists
a w ∈ W dec with w /∈ W ∗; we will show by contradiction that no such w exists thus proving the required
condition. Naturally w 6= w∗.
Consider any w∗ ∈W ∗ (recall that by Assumption 1), W ∗ is non-empty) and define wt = (1− t)w∗+ tw
for t ∈ [0, 1] as a convex combination of w∗ and wt. By convexity of W dec (Observation 3), wt ∈W dec ∀t ∈
[0, 1] because w∗ and w are in W dec.
Define m = max{t ∈ [0, 1]|wt ∈ W ∗}. Since W ∗ is closed (Observation 3) and we know that w1 = w /∈
W ∗, we get that m < 1. Furthermore, due to convexity and closedness of W ∗, we have that ∀δ ∈ (0, 1−m],
wm+δ /∈W ∗, but we do have wm+δ ∈W dec and wm ∈W ∗.
Now select a δ such that ‖wm+δ −wm‖ < ‖ and wm+δ ∈ W dec (any δ < min( ‖w−w∗‖ , 1 −m) works.)
Let the corresponding weight vector be w′ = wm+δ (w
′ ∈ W dec.) In order to prove by contradiction that
128
our assumption is wrong and that no such w exists, it is sufficient to show that w′ /∈W dec.
Note that since ‖w′ −wm‖ ≤ , w′ /∈W dec easily follows as
w′ /∈W ∗ ⇒ ∃(xj,yj) ∈ D,y ∈ Y(xj),w′ · φ(xj,y) + ∆(yj,y) > w′ · φ(xj,yj)(W ∗is closed)
⇒ ∃y′ ∈ nbr(yj),w′ · φ(xj,y′) + ∆(yj,y′) > w′ · φ(xj,yj) (Equation (A.12)) ⇒ w′ /∈W dec ,
(A.13)
which completes the proof.
Corollary 3.3.2 DecL is exact if ∆ is subadditive and ∀w ∈ W ∗,∃ > 0 such that ∀w′ ∈ B(w, ),
∀(xj,yj) ∈ D, ∀y ∈ Y, s(y,yj) can be partitioned into sets s1, . . . , sl (i.e. ∪li=1si = s(y,yj) and si ∩ sk = ∅
for all i, k, i 6= k) such that ∀k ∈ {1, . . . , l}, (ysk ,y
j
−sk) ∈ nbr(y
j,Sj) (in other words, ∀sk,∃s ∈ Sj such
that sk ⊆ s) and
w′φ(xj,y)−w′φ(xj,yj) ≤
l∑
k=1
(
w′ · φ(xj, (ysk ,y
j
−sk)))−w
′ · φ(xj,yj)
)
. (A.14)
Proof. Consider any yj and y ∈ Y(xj). Assume for a given w′, s(yj,y) can be partitioned into sets s1, . . . , sl
such that (ysk ,y
j
−sk) ∈ nbr(y
j,Sj) ∀k ∈ {1, . . . , l}, and such that condition (3.7) holds. Now we have
∑l
k=1
(
w′ · φ(xj, (ysk ,yj−sk))−w
′ · φ(xj,yj) + ∆(yj, (ysk ,yj−sk))
)
≥ w′ · φ(xj,y)−w′φ(xj,yj) +
l∑
k=1
∆(yj, (ysk ,y
j
−sk)) (from (3.7))
≥ w′ · φ(xj,y)−w′ · φ(xj,yj) + ∆(yj,y) (∆ subadditive) .
Thus if w′φ · (xj,y)−w′ ·φ(xj,yj) + ∆(yj,y) > 0 then for some sk, w′ ·φ(xj, (ysk ,yj−sk))−w
′ ·φ(xj,yj) +
∆(yj, (ysk ,y
j
−sk)) > 0. Hence we have found a (ysk ,y
j
−sk) ∈ nbr(y
j,Sj) which satisfies the required
condition in Theorem 3.3.1. This implies exactness.
Corollary 3.3.3 If Y is specified by k OR constraints, then Decl-(k + 1) is exact for subadditive ∆.
Proof. Let Y be specified by k OR constraints: O1(y), . . . , Ok(y)⇔ y ∈ Y. We will show that DecL-(k + 1)
satisfies Corollary 3.3.2 and hence is exact. We will provide a constructive proof where we will generate
appropriate decompositions.
Consider any two y1,y2 ∈ Y. We will generate a decomposition S with sets s1, . . . , sl which a) partition
s(y1,y2), b) satisfy |si| ≤ k+ 1 ∀i = 1, . . . , l, and c) satisfy (y2si ,y
1
−si) ∈ Y, ∀i = 1, . . . , l (i.e. is feasible).
129
Since our scoring function is singleton, the partitioning condition automatically implies
w · φ(x,y2)−w · φ(x,y1) =
l∑
i=1
w · φ(x, (y2si ,y
1
−si))−w · φ(x,y
1) ,
which is the required condition in Corollary 3.3.2.
Recall that s(y1,y2) = {i|y1i 6= y2i } is the set indexing different bit values in y1 and y2. Let s1 the set of
all indices in s(y1,y2) such that changing the bit in y1 corresponding to any index in s1 will violate some
constraints: s1 = {i ∈ s(y1,y2)|(y2i ,y1−i) /∈ Y}. Let s2 = s(y1,y2) \ s1 be the rest of the bits. Intuitively
speaking, flipping bits in s1 violates some constraints which are then re-satisfied by flipping bits in s2.
Now, we present an algorithmic recipe for generating the required sets s1, . . . , sl which proceeds by
changing or the flipping bits in y1 from the set s1 that violate some constraints, and then changing bits in
s2 to satisfy those constraints.
1. Initialize S → φ. We will build up the decomposition S during this algorithm. Recall that S is a set
of sets where each set contains a few variables that we perform inference together on.
2. If s1 = ∅, go to step 5. Else, pick some t ∈ s1 and remove t from s1. Let s = {t}; change the bit y1t in
y1, resulting in some constraints getting violated.
3. In order to satisfy any violated constraints, change a minimal set of bits from s(y1,y2) \ s such that
all the constraints are re-satisfied. Add the set of bits which are changed to s.
4. If none of the sets in S overlap with s, then include s in S:
S ← S ∪ {s}
and go to step 2. Otherwise, merge s with all the sets in S that overlap with s and remove those sets
from S:
s← s ∪
(
∪s′∈S:s∩s′ 6=∅s′
)
, S ← S \s′∈S:s∩s′ 6=∅ s′
thereby creating a larger set in S. Go to step 3.
5. Let s3 = s2 \ (∪s∈Ss) be the rest of the variables in s2 which haven’t yet been considered and which
don’t violate any constraint when changed (by definition of s2). We distribute each of these variables
into singleton sets in the decomposition: S ← S ∪ {{i} : i ∈ s3}.
6. Return the decomposition S
130
Note that, we have to merge the sets sharing a variable in step 4 as we are trying to creating a partition
of s(y1,y2). The main task is to show that sizes of the sets don’t exceed k+ 1 after merging. To show that
the above procedure generates the required decompositions, we make a sequence of easy observations.
1. Steps 1-4 are guaranteed to converge since y2 ∈ Y (so in the worst case, we can include all the bits in
s(y1,y2) into one set.)
2. As the constraints we are dealing with are OR constraints, to satisfy a violated constraint, at most one
bit needs to be appropriately changed.
3. If a changed bit contributes a ‘1’ to a constraint thereby satisfying it, the constraint remains satisfied
regardless of the value of any other bits.
4. Our algorithm maintains the invariant that for all s ∈ S, (y2s,y1−s) ∈ Y. This is by construction as
each set s is included in S in step 4 if it satisfies all the constraints or is included in step 5 containing
a variable from s2, changing which do not violate any constraints.
5. Take the first two observations and consider step 3 and 4 of the algorithm. If during construction of
s, an OR constraint first gets violated, but is then satisfied by changing of appropriate bits, then it
remains satisfied even when more variables are added to set s. In other words, when looping between
steps 3 and 4, any constraint in the set of all constraints, is violated at most once.
6. The last observation, combined with second observation, implies that at most one variable per con-
straint is changed during steps 3 and 4 as step 3 changes a minimal set of bits to satisfy the constraints.
This implies that at any stage in the loop, s contains at most 1 + k variables — one corresponding to
step 2 plus at most k corresponding to each constraint.
7. The sets in S form a partition of s(y1,y2) which is by construction.
Thus we have found the required partition of s(y1,y2) into sets s1, . . . , sl in S (its a valid partition because
of Observation 7 above) with (y2si ,y
1
−si) ∈ Y, ∀i = 1, . . . , l (Observation 4 above), with |si| ≤ k + 1,∀i
(Observation 6.)
Corollary 3.3.4 DecL is exact if ∆ is concave and the following holds for nbr(yj), ∀(xj,yj) ∈ D, and
∀y ∈ Y. Starting at yj, if we flip the labels in s(yj,y) one-by-one in any order, then we generate at least
one y′ ∈ nbr(yj).
131
Proof. Consider w′ ∈ B(w, ) for a given w ∈ W ∗ and a given  such that w′ /∈ W ∗. This implies that ∃
an input-output pair (xj,yj) ∈ D, ∃y such that we have w′ · φ(y,xj) + ∆(y,yj) > w′ · φ(yj,xj). Then from
Theorem 3.3.1, it suffices to show that ∃y′ ∈ nbr(yj) such that w′ · φ(y′,xj) + ∆(y′,yj) > w′ · φ(yj,xj).
Now, we are ready to prove our result. W.l.o.g., assume that s(yj,y) = {1, . . . , t} i.e. they differ on
labels y1, . . . , yt. So we obtain:
w′ ·φ(y,xj)+∆(y,yj) > w′ ·φ(yj,xj)⇒
n∑
i=1
(
yi − yji
)
w′i ·xj > −∆(y,yj)⇒
t∑
i=1
(
yi − yji
)
w′i ·xj > −∆(t) .
(A.15)
Also, w.l.o.g., assume that
(
yi − yji
)
w′i ·xj decreases as i goes from 1 to t which implies that ∀t′ ∈ {1, . . . , t},
we have
t′∑
i=1
(
yi − yji
)
w′i · xj ≥
t′
t
t∑
i=1
(
yi − yji
)
w′i · xj . (A.16)
If we change the bits 1, . . . , t in increasing order, then given the condition in the theorem, we are given that
we generate, say by changing bits 1, . . . , t′, an output y′ ∈ nbr(yj). Now, we have
w′ · φ(y′,xj)−w′ · φ(yj,xj) =
t′∑
i=1
(
yi − yji
)
w′i · xj ≥
t′
t
t∑
i=1
(
yi − yji
)
w′i · xj (from (A.16))
≥ − t
′
t
∆(y,yj) (from (A.15) ≥ − t
′
t
(
t
t′
∆(y′,yj)
)
(from concavity) = −∆(y′,yj)
⇒ w′ · φ(y′,xj) + ∆(y′,yj) ≥ w′ · φ(yj,xj) ,
which is what we wanted to show.
Theorem A.2.1. For PMNs where Assumption 2 is satisfied and with subadditive ∆, DecL with Spair is
exact.
Proof. We show that Spair satisfies Corollary 3.3.2 and hence leads to exactness. Consider some w∗ ∈
W ∗, and w ∈ B(w∗, ) for some  > 0. Recall that for a pairwise potential function ψuv = wuv ·
φuv(·, ·,x) is said to be submodular if (ψuv(1, 1) + ψuv(0, 0)) − (ψuv(1, 0) + ψuv(0, 1)) > 0 and supermod-
ular if (ψuv(1, 1) + ψuv(0, 0)) − (ψuv(1, 0) + ψuv(0, 1)) < 0. Also, recall Assumption 2: ∀(u, v) ∈ E,∀xj ∈
D,∀w∗ ∈W ∗, w∗uv ·φuv(·, ·,xj) is either (strictly) submodular or supermodular. Also, we know if any given
φuv is submodular or supermodular. Since the above inequalities are strict, it is easy to see that if we pick
a small enough , all w ∈ B(w∗, ) also satisfies these inequalities.
Now consider a (xj,yj) ∈ D and we have defined Ej = {(u, v) ∈ E|(φuv is submodular and yju = yjv) or
(φuv is supermodular and y
j
u 6= yjv)}. The corresponding decomposition is Spair(yj) = {c1, . . . , cl} where
132
c1, . . . , cl correspond to the indices of the connected componenets in E
j . Let E−j = E \ Ej .
Consider a y ∈ Y. For k = 1, . . . , l, define y[k] = (yck ,yj−ck) that is y[k] is produced by replacing all
labels of yj listed in ck by corresponding ones from y; clearly y[k] ∈ nbr(yj,Spair(yj)).
Corollary 3.3.2 requires us to show that
∑l
k=1
(
w · φ(y[k],xj)−w · φ(yj,xj; w)
)
≥ w · φ(y,xj; w)−w ·
φ(yj,xj). In order to show this, consider
(
l∑
k=1
(
w · φ(y[k],xj)−w · φ(yj,xj)
))
−
(
w · φ(y,xj)−w · φ(yj,xj)
)
= 2
∑
(u,v)∈E−j
(
wuv · φuv(yju, yv,xj) + wuv · φuv(yu, yjv,xj)− φuv(yu, yv,xj)− φuv(yju, yjv,xj)
)
.
Recall that for any (u, v) ∈ E−j , we have {(φuv is supermodular and yju = yjv) or (φuv is submodular and yju 6=
yjv)}. Thus for each edge e = (u, v) ∈ E−j , it is easy to see after exhaustively checking all 8 possible assign-
ments to yu, yv, y
j
u, and y
j
v, that wuv ·φuv(yju, yv,xj) + wuv ·φuv(yu, yjv,xj)−φuv(yu, yv,xj)−φuv(yju, yjv,xj).
Hence the R.H.S. above is non-negative. Thus for w, we have
l∑
k=1
(
f(y[k],xj; w)− f(yj,xj; w)
)
≥ f(y,xj; w)− f(yj,xj; w) ,
which is the required condition in Cor. 3.3.2.
A.3 Proofs for Chapter 5
The main paper (Equation (5.6)) presents the probability of a clustering C as per the L3M model as:
Pr[C; d,w] =
md∏
i=1
∑
0≤j<i exp
(
1
γ (w · φ(i, j))
)
C(i, j)∑
0≤j<i exp
(
1
γ (w · φ(i, j))
) =
md∏
i=1
Zi(C; d,w, γ)
md∏
i=1
Zi(d,w, γ)
=
Z(C; d,w, γ)
Z(d,w, γ)
,
where Z(d,w, γ) =
md∏
i=1
Zi(d,w, γ) is the partition function and Z(C; d,w, γ) =
md∏
i=1
Zi(C; d,w, γ).
The probability of a clustering C as per the left-linking tree model is expressed (Equation (5.9) in
Chapter 5) as the sum of the probabilities of all the left-linking trees consistent with C:
Pr′[C; d,w] =
∑
z∈Zcd
Pr[z; d,w] =
1
T (d,w, γ)
∑
z∈Zcd
exp
 1
γ
 ∑
(i,j)∈z
w · φ(i, j)
 .
Now, we want to prove Theorem 5.3.1 stated in the paper.
133
Theorem 5.3.1 The probability of a clustering as per the left-linking tree model, expressed in Equa-
tions (5.6), is the same as probability of clustering for L3M as expressed in Equations (5.9), i.e. Pr′[C; d,w] =
Pr[C; d,w].
We prove the theorem below.
Proof. We will focus on the proof with γ > 0. As the functions in Equations (5.6) and Equations (5.9) are
bounded and continuous, we shall see that the same result will hold for γ → 0.
First we will prove that the two partitions functions are the same: T (d,w, γ) = Z(d,w, γ). The proof
for the equivalence of the numerators for Equations (5.6) and Equations (5.9) will be analogous.
Below, we prove T (d,w, γ) = Z(d,w, γ) by induction on the number of items, md. We abuse the notation
and write Z(n,w, γ) as the partition function for L3M when considering only the first n items. We use the
notation T (n,w, γ) analogously.
Base case: md = 1. With just one actual item and one dummy item 0, Z(1,w, γ) = exp(
1
γ (w ·φ(1, 0))) =
exp(0) = 1. Also there is only one left-linking tree possible (with item 0 as the root and 1 as its only child),
and so T (1,w, γ) = exp( 1γ (w · φ(1, 0))) = 1. Thus the hypothesis holds for md = 1.
Now, lets assume that the induction hypothesis holds for md = n− 1 for n ≥ 2. That is we have
T (n− 1,w, γ) = Z(n− 1,w, γ)
⇒
∑
z∈Zn−1
exp
 1
γ
 ∑
(i,j)∈z
w · φ(i, j)
 = n−1∏
i=1
 ∑
0≤j<i
exp
(
1
γ
(w · φ(i, j))
) , (A.17)
where Zn−1 is the set of left-linking trees over n− 1 items.
Our goal is to prove the same holds for md = n. Now consider the expression for T (n,w, γ):
∑
z∈Zn
exp
 1
γ
 ∑
(i,j)∈z
w · φ(i, j)
 , (A.18)
where Zn is the set of left-linking trees over n items. Notice that for a left-linking tree, the edge connecting
item n to its parent is independent of the remaining edges. In other words, z is a valid left-linking tree
over n items iff by removing the item n and its associated edge, we get a valid left-linking tree over n − 1
items. Thus we can construct Zn, the set of all left-linking trees over n items by taking Zn−1, the set of
all left-linking trees over n − 1 items, and connecting item n to any of the previous n items (0, . . . , n − 1)
i.e. Zn = {z ∪ {(n, j)}|z ∈ Zn−1, j ∈ {0, . . . , n − 1}}. This implies that we can re-write the expression in
134
Equation (A.18) as
∑
0≤j<n, z′∈Zn−1
exp
(
1
γ
(w · φ(n, j))
)
× exp
 1
γ
 ∑
(i,k)∈z′
w · φ(i, k)

=
 ∑
0≤j<n
exp
(
1
γ
(w · φ(n, j))
)×
 ∑
z∈Zn−1
exp
 1
γ
 ∑
(i,k)∈z′
w · φ(i, k)

=
 ∑
0≤j<n
exp
(
1
γ
(w · φ(n, j))
)n−1∏
i=1
 ∑
0≤k<i
exp
(
1
γ
(w · φ(i, k))
) (by Eq. (A.17))
=
n∏
i=1
 ∑
0≤j<i
exp
(
1
γ
(w · φ(i, j))
) ,
which is the same as Z(n,w, γ). Hence our proof is complete and the two partition functions are the same.
One can analogously prove that the numerator of Equations (5.6) and (5.9) are the same i.e.
Z(C; d,w, γ) =
md∏
i=1
 ∑
0≤j<i
exp
(
1
γ
(w · φ(i, j))
)
C(i, j)
 = ∑
z∈Zcd
exp
 1
γ
 ∑
(i,j)∈z
w · φ(i, j)
 .
This implies that Pr′[C; d,w] = Pr[C; d,w] for γ > 0. As the two probability functions are always bounded
and continuous for γ > 0, the equivalence of the two probabilities holds as γ → 0.
As γ → 0, the function in Equations (5.6) converge to a Kronecker delta function as explained in
Section 5.3.1. Also, for γ → 0, the function in Equation (5.9) converges to a Kronecker delta function which
is 1 for the clustering consistent with the maximum weight left-linking tree, and 0 else where as explained
in Section 5.3.2. Thus for γ = 0, it is assumed that the functions in Equations (5.6) and (5.6) are replaced
by appropriate Kronecker delta functions and their equivalence continues to hold.
135
References
Nir Ailon, Moses Charikar, and Alantha Newman. Aggregating inconsistent information: Ranking and
clustering. J. ACM, 55(5), November 2008.
A. Bagga and B. Baldwin. Algorithms for scoring coreference chains. In In The First International Conference
on Language Resources and Evaluation Workshop on Linguistics Coreference, 1998.
N. Bansal, A. Blum, and S. Chawla. Correlation clustering. In FOCS, 2002.
R. Barzilay and M. Lapata. Aggregation via Set Partitioning for Natural Language Generation. In Proc. of
HLT/NAACL, 2006.
K. Bellare, G. Druck, and A. McCallum. Alternating projections for learning with expectation constraints.
In UAI, 2009.
E. Bengtson and D. Roth. Understanding the value of features for coreference resolution. In EMNLP, 2008.
D. P. Bertsekas. Nonlinear Programming. Athena Scientific, 2nd edition, 1999.
J. Besag. Spatial interaction and the statistical analysis of lattice systems. Journal of the Royal Statistical
Society, 1974.
J. Besag. On the statistical analysis of dirty pictures. Journal of the Royal Statistical Society, 1986.
D. Blei, A. Ng, and M. Jordan. Latent dirichlet allocation. Journal of Machine Learning Research, 2003.
D. M. Blei and P. I. Frazier. Distance dependent chinese restaurant processes. JMLR, 2011.
Stephen Boyd and Almir Mutapcic. Stochastic subgradient methods, 2007.
Y. Boykov, O. Veksler, and R. Zabih. Markov random fields with efficient approximations. In CVPR, 1998.
Yuri Boykov, Olga Veksler, and Ramin Zabih. Fast approximate energy minimization via graph cuts.
IEEE Trans. Pattern Anal. Mach. Intell., pages 1222–1239, 2001. doi: 10.1109/34.969114. URL http:
//dx.doi.org/10.1109/34.969114.
Peter Brown, Stephen Della Pietra, Vincent Della Pietra, and Robert Mercer. The mathematics of statistical
machine translation: parameter estimation. Computational Linguistics, 1993.
K.-W. Chang, R. Samdani, A. Rozovskaya, N. Rizzolo, M. Sammons, and D. Roth. Inference protocols for
coreference resolution. In CoNLL Shared Task, 2011.
K.-W. Chang, R. Samdani, A. Rozovskaya, M. Sammons, and D. Roth. Illinois-coref: The UI system in the
CoNLL-2012 Shared Task. In CoNLL Shared Task, 2012.
M. Chang. Structured prediction with indirect supervision, 2011. URL http://cogcomp.cs.illinois.
edu/papers/Chang11.pdf.
M. Chang, L. Ratinov, and D. Roth. Guiding semi-supervision with constraint-driven learning. In ACL,
2007.
136
Chandra Chekuri, Sanjeev Khanna, Joseph (Seffi) Naor, and Leonid Zosin. Approximation algorithms for
the metric labeling problem via a new linear programming formulation. In Proceedings of the twelfth
annual ACM-SIAM symposium on Discrete algorithms, SODA ’01, pages 109–118. Society for Industrial
and Applied Mathematics, 2001. ISBN 0-89871-490-7.
Y. Choi and C. Cardie. Adapting a polarity lexicon using integer linear programming for domainspecific
sentiment classification. In EMNLP, 2009.
C. I. Chow and C. N. Liu. Approximating discrete probability distributions with dependence trees. IEEE
Transactions on Information Theory, 14:462–467, 1968.
J. Clarke and M. Lapata. Global inference for sentence compression: An integer linear programming ap-
proach. Journal of Artificial Intelligence Research (JAIR), 2008.
James Clarke and Mirella Lapata. Constraint-based sentence compression: An integer programming ap-
proach. In ACL, 2006.
M. Collins. Discriminative training methods for hidden Markov models: Theory and experiments with
perceptron algorithms. In EMNLP, 2002.
Thomas H. Cormen, Clifford Stein, Ronald L. Rivest, and Charles E. Leiserson. Introduction to Algorithms.
McGraw-Hill Higher Education, 2nd edition, 2001. ISBN 0070131511.
K. Crammer and Y. Singer. Ultraconservative online algorithms for multiclass problems. Journal of Machine
Learning Research, 2001.
K. Crammer and Y. Singer. On the algorithmic implementation of multiclass kernel-based vector machines.
JMLR, 2002.
K. Crammer, O. Dekel, J. Keshet, S. Shalev-Shwartz, and Y. Singer. Online passive-aggressive algorithms.
Journal of Machine Learning Research, 2006.
H. Daumé III, J. Langford, and D. Marcu. Search-based structured prediction. 2009.
A. P. Dempster, N. M. Laird, and D. B. Rubin. Maximum likelihood from incomplete data via the EM
algorithm. Journal of the Royal Statistical Society, 1977.
Paramveer S. Dhillon, S. Sathiya Keerthi, Kedar Bellare, Olivier Chapelle, and S. Sundararajan. Deter-
ministic annealing for semi-supervised structured output learning. In Proceedings of the International
Conference on Artificial Intelligence and Statistics, 2012.
J. V. Dillon and G. Lebanon. Stochastic composite likelihood. Journal of Machine Learning Research, 2010.
G. Druck and A. Mccallum. High-performance semi-supervised learning using discriminatively constrained
generative models. In ICML, 2010.
T. Finley and T. Joachims. Supervised clustering with support vector machines. In ICML, 2005.
T. Finley and T. Joachims. Training structural svms when exact inference is intractable. In ICML, 2008.
David A. Forsyth and Jean Ponce. Computer Vision: A Modern Approach. Prentice Hall Professional
Technical Reference, 2002. ISBN 0130851981.
E. B. Fowlkes and C. L. Mallows. A method for comparing two hierarchical clusterings. Journal of the
American Statistical Association, 1983.
K. Ganchev, J.V. Graca, and B. Taskar. Better alignments = better translations. In ACL, 2008a.
K. Ganchev, J. Graça, J. Gillenwater, and B. Taskar. Posterior regularization for structured latent variable
models. Journal of Machine Learning Research, 2010.
137
Kuzman Ganchev, Joao Graca, John Blitzer, and Ben Taskar. Multi-view learning over structured and
non-identical outputs. In Uncertainty in Artificial Intelligence, 2008b.
M. Gaudioso, G. Giallombardo, and G. Miglionico. An incremental method for solving convex finite min-max
problems. Math. Oper. Res., 2006.
K. Gimpel and N. A. Smith. Softmax-margin CRFs: Training log-linear models with cost functions. In
NAACL, 2010.
Amir Globerson and Tommi Jaakkola. Fixing max-product: Convergent message passing algorithms for map
lp-relaxations. In John C. Platt, Daphne Koller, Yoram Singer, and Sam T. Roweis, editors, Advances in
Neural Information Processing Systems 20, Proceedings of the Twenty-First Annual Conference on Neural
Information Processing Systems, Vancouver, British Columbia, Canada, December 3-6, 2007. MIT Press,
2007. doi: http://books.nips.cc/papers/files/nips20/NIPS2007 0940.pdf.
Shantanu Godbole and Sunita Sarawagi. Discriminative methods for multi-labeled classification. In In
Proceedings of the 8th Pacific-Asia Conference on Knowledge Discovery and Data Mining, pages 22–30.
Springer, 2004.
D. Greig, B. Porteous, and A. Seheult. Exact maximum a posteriori estimation for binary images. Journal
of the Royal Statistical Society, 1989.
T. Grenager, D. Klein, and C. Manning. Unsupervised learning of field segmentation models for information
extraction. In ACL, 2005.
S. Guha, A. Meyerson, N. Mishra, R. Motwani, and L. O’Callaghan. Clustering data streams: Theory and
practice. IEEE Trans. on Knowl. and Data Eng., 2003.
A. Guillory, E. Chastain, and J. Bilmes. Active learning as non-convex optimization. JMLR, 2009.
Inc. Gurobi Optimization. Gurobi optimizer reference manual, 2013. URL http://www.gurobi.com.
A. Haghighi and D. Klein. Prototype-driven learning for sequence models. In Proc. of HTL-NAACL, 2006.
P. Haider, U. Brefeld, and T. Scheffer. Supervised clustering of streaming data for email batch detection.
In Zoubin Ghahramani, editor, ICML, 2007.
S. Har-Peled, D. Roth, and D. Zimak. Constraint classification for multiclass classification and ranking. In
NIPS, 2003.
T. Hofmann. Unsupervised learning by probabilistic latent semantic analysis. MlJ, 2001.
K. Hornik, M. Stinchcombe, and H. White. Multilayer feedforward networks are universal approximators.
Neural Netw., 2(5):359–366, July 1989. ISSN 0893-6080.
Thorsten Joachims. A support vector method for multivariate performance measures. In Proceedings of the
22nd international conference on Machine learning, ICML ’05, pages 377–384, New York, NY, USA, 2005.
ACM.
M. Kearns, Y. Mansour, and A. Y. Ng. An information-theoretic analysis of hard and soft assignment
methods for clustering. In ICML, 1997.
Joseph Keshet. Large margin algorithms for discriminative continuous speech recognition. PhD thesis,
Hebrew University, 2007.
D. Klein and C. D. Manning. Corpus-based induction of syntactic structure: models of dependency and
constituency. In ACL, 2004.
P. Koehn. Europarl: A multilingual corpus for evaluation of machine translation. 2002.
138
V. Kolmogorov and R. Zabih. What energy functions can be minimized via graph cuts. IEEE Transactions
on Pattern Analysis and Machine Intelligence, 2004.
Vladimir Kolmogorov. Convergent tree-reweighted message passing for energy minimization. IEEE Trans.
Pattern Anal. Mach. Intell., 28(10):1568–1583, October 2006. ISSN 0162-8828.
Nikos Komodakis, Nikos Paragios, and Georgios Tziritas. Mrf optimization via dual decomposition: Message-
passing revisited. In In ICCV, 2007.
T. Koo, A. M. Rush, M. Collins, T. Jaakkola, and D. Sontag. Dual decomposition for parsing with non-
projective head automata. In EMNLP, 2010.
Terry Koo, Amir Globerson, Xavier Carreras, and Michael Collins. Structured prediction models via the
matrix-tree theorem. In Proceedings of the 2007 Joint Conference of EMNLP-CoNLL, 2007.
Frank R. Kschischang, Brendan J. Frey, and Hans-Andrea Loeliger. Factor graphs and the sum-product
algorithm. IEEE TRANSACTIONS ON INFORMATION THEORY, 47:498–519, 1998.
Sandra Kubler, Ryan McDonald, Joakim Nivre, and Graeme Hirst. Dependency Parsing. Morgan and
Claypool Publishers, 2009. ISBN 1598295969, 9781598295962.
A. Kulesza. Approximate learning for structured prediction problems. University of Pennsylvania WPE-II
report, November 2009.
A. Kulesza and F. Pereira. Structured learning with approximate inference. In NIPS. 2008.
P. Kumar, B. Packer, and D. Koller. Self-paced learning for latent variable models. In NIPS, 2010.
S. Lacoste-Julien, M. Jaggi, M. Schmidt, and P. Pletscher. Block-coordinate frank-wolfe optimization for
structural svms. In ICML, 2013.
Simon Lacoste-Julien, Mark W. Schmidt, and Francis Bach. A simpler approach to obtaining an o(1/t)
convergence rate for the projected stochastic subgradient method. CoRR, abs/1212.2002, 2012.
J. Lafferty, A. McCallum, and F. Pereira. Conditional random fields: Probabilistic models for segmenting
and labeling sequence data. In ICML, 2001.
P. Lambert, A. De Gispert, R. Banchs, and J. Marino. Guidelines for word alignment evaluation and manual
alignment. Language Resources and Evaluation, 2005.
Y. LeCun, L. Bottou, G. Orr, and K. Muller. Efficient backprop. In G. Orr and Muller K., editors, Neural
Networks: Tricks of the trade. Springer, 1998.
Yann Lecun, Lon Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to document
recognition. In Proceedings of the IEEE, pages 2278–2324, 1998.
H. Lee, Y. Peirsman, A. Chang, N. Chambers, M. Surdeanu, and D. Jurafsky. Stanford’s multi-pass sieve
coreference resolution system at the conll-2011 shared task. In Proceedings of the CoNLL-2011 Shared
Task, 2011.
D. D. Lewis, Y. Yang, T. G. Rose, and F. Li. Rcv1: A new benchmark collection for text categorization
research. JMLR, 2004.
P. Liang, D. Klein, and M. I. Jordan. Agreement-based learning. In NIPS, 2008.
Percy Liang and Michael I. Jordan. An asymptotic analysis of generative, discriminative, and pseudolike-
lihood estimators. In Proceedings of the 25th international conference on Machine learning, ICML ’08,
pages 584–591, 2008. ISBN 978-1-60558-205-4.
139
Percy Liang, Ben Taskar, and Dan Klein. Alignment by agreement. In Proceedings of the main confer-
ence on Human Language Technology Conference of the North American Chapter of the Association of
Computational Linguistics, HLT-NAACL ’06, pages 104–111, Stroudsburg, PA, USA, 2006. Association for
Computational Linguistics. doi: 10.3115/1220835.1220849. URL http://dx.doi.org/10.3115/1220835.
1220849.
Bruce G. Lindsay. Composite likelihood methods. Contemporary Methods, 1988.
Ben London, Bert Huang, Benjamin Taskar, and Lise Getoor. Collective stability in structured predic-
tion: Generalization from one example. In Proceedings of the 30th International Conference on Machine
Learning (ICML-13), 2013.
X. Luo. On coreference resolution performance metrics. In EMNLP, 2005.
G. S. Mann and A. McCallum. Generalized expectation criteria for semi-supervised learning with weakly
labeled data. JMLR, 11, 2010.
A. Martins, N. A. Smith, and E. Xing. Concise integer linear programming formulations for dependency
parsing. In ACL, 2009.
André F. T. Martins, Noah A. Smith, Eric P. Xing, Pedro M. Q. Aguiar, and Mário A. T. Figueiredo. Turbo
parsers: dependency parsing by approximate variational inference. In Proceedings of the 2010 Conference
on Empirical Methods in Natural Language Processing, EMNLP ’10, 2010.
A. Mccallum and B. Wellner. Toward conditional models of identity uncertainty with application to proper
noun coreference. In NIPS, 2003.
A. McCallum, D. Freitag, and F. Pereira. Maximum entropy markov models for information extraction and
segmentation. In ICML, 2000.
Andrew K. McCallum, Ronald Rosenfeld, Tom M. Mitchell, and Andrew Y. Ng. Improving text classification
by shrinkage in a hierarchy of classes. In ICML, 1998.
M. Meilă. Comparing clusterings—an information based distance. J. Multivar. Anal., 2007.
Talya Meltzer, Amir Globerson, and Yair Weiss. Convergent message passing algorithms - a unifying view.
In In Proc. Twenty-eighth Conference on Uncertainty in Artificial Intelligence (UAI 09, 2009.
Bernard Merialdo. Tagging text with a probabilistic model. Computational Linguistics, 1994.
O. Meshi, D. Sontag, T. Jaakkola, and A. Globerson. Learning efficiently with approximate inference via
dual losses. In ICML, 2010.
R. C. Moore, W. Yih, and A. Bode. Improved discriminative bilingual word alignment. In ACL, 2006.
R. M. Neal and G. E. Hinton. A new view of the EM algorithm that justifies incremental, sparse and other
variants. In M. I. Jordan, editor, Learning in Graphical Models. 1998.
V. Ng. Supervised noun phrase coreference research: the first fifteen years. In ACL, 2010.
Vincent Ng and Claire Cardie. Improving machine learning approaches to coreference resolution. In ACL,
2002.
Kamal Nigam, Andrew Kachites Mccallum, Sebastian Thrun, and Tom Mitchell. Text classification from
labeled and unlabeled documents using EM. Machine Learning, 2000.
NIST. The ACE evaluation plan., 2004. URL http://www.itl.nist.gov/iad/mig//tests/ace/ace04/
index.html.
Sebastian Nowozin. Constructing composite likelihoods in general random fields. In ICML workshop on
Inferning: Interactions between Inference and Learning, 2013.
140
F. J. Och and H. Ney. Improved statistical alignment models. In ACL, 2000.
F. J. Och and H. Ney. A systematic comparison of various statistical alignment models. CL, 29, 2003.
D. Pascal and J. Baldridge. Global joint models for coreference resolution and named entity classification.
In Procesamiento del Lenguaje Natural, 2009.
Judea Pearl. Probabilistic reasoning in intelligent systems: networks of plausible inference. 1988.
Slav Petrov and Dan Klein. Discriminative log-linear grammars with latent variables. In In Proceedings of
NIPS 20, 2008.
P. Pletscher, C. S. Ong, and J. M. Buhmann. Entropy and margin maximization for structured output
learning. In ECML PKDD, 2010.
S. Pradhan, L. Ramshaw, M. Marcus, M. Palmer, R. Weischedel, and N. Xue. Conll-2011 shared task:
Modeling unrestricted coreference in ontonotes. In CoNLL, 2011.
S. Pradhan, A. Moschitti, N. Xue, O. Uryupina, and Y. Zhang. CoNLL-2012 shared task: Modeling multi-
lingual unrestricted coreference in OntoNotes. In CoNLL 2012, 2012.
V. Punyakanok, D. Roth, W. Yih, and D. Zimak. Learning and inference over constrained output. In IJCAI,
2005.
V. Punyakanok, D. Roth, and W. Yih. The importance of syntactic parsing and inference in semantic role
labeling. Computational Linguistics, 2008.
Ariadna Quattoni, Michael Collins, and Trevor Darrell. Conditional random fields for object recognition. In
In NIPS, pages 1097–1104. MIT Press, 2004.
Ariadna Quattoni, Sybor Wang, Louis-Philippe Morency, Michael Collins, and Trevor Darrell. Hidden
conditional random fields. IEEE Trans. Pattern Anal. Mach. Intell., 2007. ISSN 0162-8828.
L. R. Rabiner. A tutorial on hidden Markov models and selected applications in speech recognition. Pro-
ceedings of the IEEE, 1989.
K. Raghunathan, H. Lee, S. Rangarajan, N. Chambers, M. Surdeanu, D. Jurafsky, and C. Manning. A
multi-pass sieve for coreference resolution. In EMNLP, 2010.
Delip Rao, Paul McNamee, and Mark Dredze. Streaming cross document entity coreference resolution. In
Proceedings of the 23rd International Conference on Computational Linguistics: Posters, COLING ’10,
pages 1050–1058. Association for Computational Linguistics, 2010.
S. Ravi and K. Knight. Minimized models for unsupervised part-of-speech tagging. ACL, 1(August), 2009.
N. Rizzolo and D. Roth. Modeling Discriminative Global Inference. In Proceedings of the First International
Conference on Semantic Computing (ICSC), 2007.
K. Rose. Deterministic annealing for clustering, compression, classification, regression, and related optimiza-
tion problems. In IEEE, pages 2210–2239, 1998.
D. Roth. On the hardness of approximate reasoning. Artificial Intelligence, 1996.
D. Roth and K. Small. Interactive feature space construction using semantic information. In Proc. of the
Annual Conference on Computational Natural Language Learning (CoNLL), 2009.
D. Roth and W. Yih. A linear programming formulation for global inference in natural language tasks. In
Hwee Tou Ng and Ellen Riloff, editors, CoNLL, 2004.
D. Roth and W. Yih. Integer linear programming inference for conditional random fields. In ICML, 2005.
141
D. Roth and W. Yih. Global inference for entity and relation identification via a linear programming
formulation. In Lise Getoor and Ben Taskar, editors, Introduction to Statistical Relational Learning, 2007.
A. M. Rush and M. Collins. Exact decoding of syntactic translation models through lagrangian relaxation.
In ACL, 2011.
A. M. Rush, D. Sontag, M. Collins, and T. Jaakkola. On dual decomposition and linear programming
relaxations for natural language processing. In EMNLP, 2010.
R. Samdani and D. Roth. Efficient decomposed learning for structured prediction. In ICML, 6 2012. URL
http://cogcomp.cs.illinois.edu/papers/SamdaniRo12.pdf.
R. Samdani, M. Chang, and D. Roth. Unified expectation maximization. In NAACL, 2012a.
R. Samdani, M. Chang, and D. Roth. A framework for tuning posterior entropy in unsupervised learning.
In ICML workshop on Inferning: Interactions between Inference and Learning, 2012b.
A. Schrijver. Theory of linear and integer programming. John Wiley & Sons, Inc., 1986.
A. G. Schwing, T. Hazan, M. Pollefeys, and R. Urtasun. Efficient structured prediction with latent variables
for general graphical models. In ICML, 2012.
S. Shalev-Shwartz, Y. Singer, and N. Srebro. Pegasos: primal estimated sub-gradient solver for SVM. In
Zoubin Ghahramani, editor, ICML, 2007.
Shai Shalev-Shwartz, Yoram Singer, Nathan Srebro, and Andrew Cotter. Pegasos: primal estimated sub-
gradient solver for svm. Math. Program., 127(1):3–30, March 2011.
Ohad Shamir and Tong Zhang. Stochastic gradient descent for non-smooth optimization: Convergence
results and optimal averaging schemes. In ICML, 2013.
D. Shen, Q. Yang, J.-T. Sun, and Z. Chen. Thread detection in dynamic text message streams. In SIGIR,
2006.
Sameer Singh, Amarnag Subramanya, Fernando Pereira, and Andrew McCallum. Large-scale cross-document
coreference using distributed inference and hierarchical models. In Proceedings of the 49th Annual Meeting
of the Association for Computational Linguistics: Human Language Technologies - Volume 1, HLT ’11,
pages 793–803. Association for Computational Linguistics, 2011. ISBN 978-1-932432-87-9.
N. Smith and J. Eisner. Contrastive estimation: Training log-linear models on unlabeled data. In ACL,
2005.
N. A. Smith and J. Eisner. Annealing techniques for unsupervised statistical language learning. In ACL,
2004.
Noah A. Smith. Linguistic Structure Prediction. Synthesis Lectures on Human Language Technologies.
Morgan and Claypool, May 2011.
Marina Sokolova and Guy Lapalme. A systematic analysis of performance measures for classification tasks.
Inf. Process. Manage., 45(4):427–437, July 2009. ISSN 0306-4573.
D. Sontag. Approximate Inference in Graphical Models using LP Relaxations. PhD thesis, Massachusetts
Institute of Technology, Department of Electrical Engineering and Computer Science, 2010.
D. Sontag, O. Meshi, T. Jaakkola, and A. Globerson. More data means less inference: A pseudo-max
approach to structured learning. In NIPS. 2010.
David Sontag, Amir Globerson, and Tommi Jaakkola. Introduction to dual decomposition for inference. In
Suvrit Sra, Sebastian Nowozin, and Stephen J. Wright, editors, Optimization for Machine Learning. MIT
Press, 2011.
142
W. M. Soon, H. T. Ng, and D. C. Y. Lim. A machine learning approach to coreference resolution of noun
phrases. Comput. Linguist., 2001.
V. I. Spitkovsky, H. Alshawi, D. Jurafsky, and C. D. Manning. Viterbi training improves unsupervised
dependency parsing. In CoNLL, 2010.
V. Srikumar and D. Roth. A joint model for extended semantic role labeling. In EMNLP, 2011.
Bharath Sriperumbudur and Gert Lanckriet. On the convergence of the concave-convex procedure. In
Y. Bengio, D. Schuurmans, J. Lafferty, C. K. I. Williams, and A. Culotta, editors, Advances in Neural
Information Processing Systems 22, pages 1759–1767, 2009.
E. Stamatatos. A survey of modern authorship attribution methods. J. Am. Soc. Inf. Sci. Technol., 2009.
V. Stoyanov, N. Gilbert, C. Cardie, and E. Riloff. Conundrums in noun phrase coreference resolution:
making sense of the state-of-the-art. In ACL, 2009.
Veselin Stoyanov and Jason Eisner. Easy-first coreference resolution. In COLING, pages 2519–2534, 2012.
C. Sutton and A. McCallum. Piecewise pseudolikelihood for efficient training of conditional random fields.
In Zoubin Ghahramani, editor, ICML, 2007.
C. Sutton and A. Mccallum. Piecewise training for structured prediction. Machine Learning, 2009.
M. Szummer, P. Kohli, and D. Hoiem. Learning crfs using graph cuts. In ECCV, 2008.
B. Taskar, C. Guestrin, and D. Koller. Max-margin markov networks. In NIPS, 2004.
B. Taskar, S. Lacoste-Julien, and D. Klein. A discriminative matching approach to word alignment. In
HLT-EMNLP, 2005.
I. Tsochantaridis, T. Hofmann, T. Joachims, and Y. Altun. Support vector machine learning for interde-
pendent and structured output spaces. In ICML, 2004.
N. Ueda and R. Nakano. Deterministic annealing em algorithm. Neural Network, 1998.
M. Vilain, J. Burger, J. Aberdeen, D. Connolly, and L. Hirschman. A model-theoretic coreference scoring
scheme. In Proceedings of the 6th conference on Message understanding, 1995.
A. Viterbi. Error bounds for convolutional codes and an asymptotically optimum decoding algorithm.
Information Theory, IEEE Transactions on, 13(2):260–269, April 1967.
S. Vogel, H. Ney, and C. Tillmann. Hmm-based word alignment in statistical translation. In COLING, 1996.
Martin Wainwright, Tommi Jaakkola, and Alan Willsky. Map estimation via agreement on (hyper)trees:
Message-passing and linear programming approaches. IEEE Transactions on Information Theory, 51:
3697–3717, 2002.
Martin Wainwright, Tommi Jaakkola, and Alan Willsky. Tree consistency and bounds on the performance of
the max-product algorithm and its generalizations. Statistics and Computing, 14(2):143–166, April 2004.
ISSN 0960-3174.
Martin J. Wainwright. Estimating the ”wrong” graphical model: Benefits in the computation-limited setting.
J. Mach. Learn. Res., 7, December 2006.
Yair Weiss, Chen Yanover, and Talya Meltzer. Linear programming and variants of belief propagation. In
Markov Random Fields for Vision and Image Processing. MIT Press, 2011.
T. Werner. What is decreased by the max-sum arc consistency algorithm? In Zoubin Ghahramani, editor,
ICML, 2007.
143
C. F. J. Wu. On the convergence properties of the em algorithm. The Annals of Statistics, 1983.
E. P. Xing, A. Y. Ng, M. I. Jordan, and S. Russell. Distance metric learning, with application to clustering
with side-information. In NIPS, 2002.
J. S. Yedidia, W. T. Freeman, and Y. Weiss. Constructing free-energy approximations and generalized belief
propagation algorithms. IEEE Transactions on Information Theory, 2005.
C. Yu and T. Joachims. Learning structural svms with latent variables. In ICML, 2009.
A. L. Yuille and A. Rangarajan. The concave-convex procedure. Neural Computation, 2003.
Tong Zhang. Solving large scale linear prediction problems using stochastic gradient descent algorithms. In
ICML, 2004.
144
